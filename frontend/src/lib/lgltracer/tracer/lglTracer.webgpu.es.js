class e{constructor(e,t,r=1,s=!0){this._device=e,this._canvas=t,this._context=t.getContext("webgpu"),this._configure={alphaMode:s?"premultiplied":"opaque",device:this._device,format:this.format,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC},this._context.configure(this._configure),this.pixelRatio=r}get device(){return this._device}get configure(){return this._configure}get format(){return navigator.gpu.getPreferredCanvasFormat()}get width(){return this._canvas.width}get height(){return this._canvas.height}get size(){return{width:this.width,height:this.height,depthOrArrayLayers:1}}getContext(){return this._context}getTexture(){return this._context.getCurrentTexture()}createCurrentTextureView(){return this._context.getCurrentTexture().createView()}}class t extends Array{constructor(e=0,r=e,s=r){return"string"==typeof e&&([e,r,s]=t.hexToRGB(e)),e>1&&(e/=255,r/=255,s/=255),super(e,r,s),this}get isColor(){return!0}get r(){return this[0]}set r(e){this[0]=e}get g(){return this[1]}set g(e){this[1]=e}get b(){return this[2]}set b(e){this[2]=e}set(e,r,s){return"string"==typeof e&&([e,r,s]=t.hexToRGB(e)),e.length?this.copy(e):(this[0]=e,this[1]=r,this[2]=s,this)}copy(e){return this[0]=e[0],this[1]=e[1],this[2]=e[2],this}fromHex(e){const r=t.hexToRGB(e);this.fromArray(r)}getHex(){const[e,t,r]=this,s=e=>Math.round(255*e).toString(16).padStart(2,"0");return`#${s(e)}${s(t)}${s(r)}`}static hexToRGB(e){4===e.length&&(e=e[0]+e[1]+e[1]+e[2]+e[2]+e[3]+e[3]);const t=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(e);return t||console.warn(`Unable to convert hex string ${e} to rgb values`),[parseInt(t[1],16)/255,parseInt(t[2],16)/255,parseInt(t[3],16)/255]}static rgbToHex(e){e.length&&3==e.length||console.error(`Unable to convert rgb array ${e} to hex value`);let t="#";for(let r=0;r<e.length;r++){let s=Number(e[r]).toString(16);s.length<2&&(s="0"+s),t+=s}return t}static hslToRGB(e,t,r){let s,i,a;if(0==t)s=i=a=r;else{let n=function(e,t,r){return r<0&&(r+=1),r>1&&(r-=1),r<1/6?e+6*(t-e)*r:r<.5?t:r<2/3?e+(t-e)*(2/3-r)*6:e},o=r<.5?r*(1+t):r+t-r*t,l=2*r-o;s=n(l,o,e+1/3),i=n(l,o,e),a=n(l,o,e-1/3)}return[s,i,a]}static rgbToHsl(e,t,r){e/=255,t/=255,r/=255;let s,i,a=Math.max(e,t,r),n=Math.min(e,t,r),o=(a+n)/2;if(a==n)s=i=0;else{let l=a-n;switch(i=o>.5?l/(2-a-n):l/(a+n),a){case e:s=(t-r)/l+(t<r?6:0);break;case t:s=(r-e)/l+2;break;case r:s=(e-t)/l+4}s/=6}return[s,i,o]}static rgbToHsv(e,t,r){let s,i,a;e/=255,t/=255,r/=255;let n=Math.min(e,t,r),o=a=Math.max(e,t,r),l=o-n;if(o==n)s=0;else{switch(o){case e:s=(t-r)/l+(t<r?6:0);break;case t:s=2+(r-e)/l;break;case r:s=4+(e-t)/l}s=Math.round(60*s)}return i=0==o?0:1-n/o,i=Math.round(100*i),a=Math.round(100*a),[s,i,a]}fromArray(e,t=0){return this[0]=e[t],this[1]=e[t+1],this[2]=e[t+2],this}toArray(){return Array.from(this)}SRGBToLinearSingle(e){return e<.04045?.0773993808*e:Math.pow(.9478672986*e+.0521327014,2.4)}SRGBToLinear(){return this[0]=this.SRGBToLinearSingle(this[0]),this[1]=this.SRGBToLinearSingle(this[1]),this[2]=this.SRGBToLinearSingle(this[2]),this}LinearToSRGBSingle(e){return e<.0031308?12.92*e:1.055*Math.pow(e,.41666)-.055}LinearToSRGB(){return this[0]=this.LinearToSRGBSingle(this[0]),this[1]=this.LinearToSRGBSingle(this[1]),this[2]=this.LinearToSRGBSingle(this[2]),this}luminance(){return.2126*this[0]+.7152*this[1]+.0722*this[2]}addColor(e,t){return this[0]=e[0]+t[0],this[1]=e[1]+t[1],this[2]=e[2]+t[2],this}scale(e){return this[0]=this[0]*e,this[1]=this[1]*e,this[2]=this[2]*e,this}}function r(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function s(e,t,r){let s=t[0],i=t[1],a=t[2],n=t[3],o=t[4],l=t[5],u=t[6],c=t[7],d=t[8],h=t[9],p=t[10],f=t[11],m=t[12],g=t[13],x=t[14],b=t[15],v=r[0],L=r[1],y=r[2],S=r[3];return e[0]=v*s+L*o+y*d+S*m,e[1]=v*i+L*l+y*h+S*g,e[2]=v*a+L*u+y*p+S*x,e[3]=v*n+L*c+y*f+S*b,v=r[4],L=r[5],y=r[6],S=r[7],e[4]=v*s+L*o+y*d+S*m,e[5]=v*i+L*l+y*h+S*g,e[6]=v*a+L*u+y*p+S*x,e[7]=v*n+L*c+y*f+S*b,v=r[8],L=r[9],y=r[10],S=r[11],e[8]=v*s+L*o+y*d+S*m,e[9]=v*i+L*l+y*h+S*g,e[10]=v*a+L*u+y*p+S*x,e[11]=v*n+L*c+y*f+S*b,v=r[12],L=r[13],y=r[14],S=r[15],e[12]=v*s+L*o+y*d+S*m,e[13]=v*i+L*l+y*h+S*g,e[14]=v*a+L*u+y*p+S*x,e[15]=v*n+L*c+y*f+S*b,e}function i(e,t){let r=t[0]+t[5]+t[10],s=0;return r>0?(s=2*Math.sqrt(r+1),e[3]=.25*s,e[0]=(t[6]-t[9])/s,e[1]=(t[8]-t[2])/s,e[2]=(t[1]-t[4])/s):t[0]>t[5]&&t[0]>t[10]?(s=2*Math.sqrt(1+t[0]-t[5]-t[10]),e[3]=(t[6]-t[9])/s,e[0]=.25*s,e[1]=(t[1]+t[4])/s,e[2]=(t[8]+t[2])/s):t[5]>t[10]?(s=2*Math.sqrt(1+t[5]-t[0]-t[10]),e[3]=(t[8]-t[2])/s,e[0]=(t[1]+t[4])/s,e[1]=.25*s,e[2]=(t[6]+t[9])/s):(s=2*Math.sqrt(1+t[10]-t[0]-t[5]),e[3]=(t[1]-t[4])/s,e[0]=(t[8]+t[2])/s,e[1]=(t[6]+t[9])/s,e[2]=.25*s),e}function a(e,t){let r=t[0],s=t[1],i=t[2],a=t[3],n=r+r,o=s+s,l=i+i,u=r*n,c=s*n,d=s*o,h=i*n,p=i*o,f=i*l,m=a*n,g=a*o,x=a*l;return e[0]=1-d-f,e[1]=c+x,e[2]=h-g,e[3]=0,e[4]=c-x,e[5]=1-u-f,e[6]=p+m,e[7]=0,e[8]=h+g,e[9]=p-m,e[10]=1-u-d,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}class n extends Array{constructor(e=1,t=0,r=0,s=0,i=0,a=1,n=0,o=0,l=0,u=0,c=1,d=0,h=0,p=0,f=0,m=1){return super(e,t,r,s,i,a,n,o,l,u,c,d,h,p,f,m),this}get isMatrix4(){return!0}set x(e){this[12]=e}get x(){return this[12]}set y(e){this[13]=e}get y(){return this[13]}set z(e){this[14]=e}get z(){return this[14]}set w(e){this[15]=e}get w(){return this[15]}set(e,t,r,s,i,a,n,o,l,u,c,d,h,p,f,m){return e.length?this.copy(e):(function(e,t,r,s,i,a,n,o,l,u,c,d,h,p,f,m,g){e[0]=t,e[1]=r,e[2]=s,e[3]=i,e[4]=a,e[5]=n,e[6]=o,e[7]=l,e[8]=u,e[9]=c,e[10]=d,e[11]=h,e[12]=p,e[13]=f,e[14]=m,e[15]=g}(this,e,t,r,s,i,a,n,o,l,u,c,d,h,p,f,m),this)}translate(e,t=this){return function(e,t,r){let s,i,a,n,o,l,u,c,d,h,p,f,m=r[0],g=r[1],x=r[2];t===e?(e[12]=t[0]*m+t[4]*g+t[8]*x+t[12],e[13]=t[1]*m+t[5]*g+t[9]*x+t[13],e[14]=t[2]*m+t[6]*g+t[10]*x+t[14],e[15]=t[3]*m+t[7]*g+t[11]*x+t[15]):(s=t[0],i=t[1],a=t[2],n=t[3],o=t[4],l=t[5],u=t[6],c=t[7],d=t[8],h=t[9],p=t[10],f=t[11],e[0]=s,e[1]=i,e[2]=a,e[3]=n,e[4]=o,e[5]=l,e[6]=u,e[7]=c,e[8]=d,e[9]=h,e[10]=p,e[11]=f,e[12]=s*m+o*g+d*x+t[12],e[13]=i*m+l*g+h*x+t[13],e[14]=a*m+u*g+p*x+t[14],e[15]=n*m+c*g+f*x+t[15])}(this,t,e),this}rotateX(e,t=this){return function(e,t,r){let s=Math.sin(r),i=Math.cos(r),a=t[4],n=t[5],o=t[6],l=t[7],u=t[8],c=t[9],d=t[10],h=t[11];t!==e&&(e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[4]=a*i+u*s,e[5]=n*i+c*s,e[6]=o*i+d*s,e[7]=l*i+h*s,e[8]=u*i-a*s,e[9]=c*i-n*s,e[10]=d*i-o*s,e[11]=h*i-l*s}(this,t,e),this}rotateY(e,t=this){return function(e,t,r){let s=Math.sin(r),i=Math.cos(r),a=t[0],n=t[1],o=t[2],l=t[3],u=t[8],c=t[9],d=t[10],h=t[11];t!==e&&(e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=a*i-u*s,e[1]=n*i-c*s,e[2]=o*i-d*s,e[3]=l*i-h*s,e[8]=a*s+u*i,e[9]=n*s+c*i,e[10]=o*s+d*i,e[11]=l*s+h*i}(this,t,e),this}rotateZ(e,t=this){return function(e,t,r){let s=Math.sin(r),i=Math.cos(r),a=t[0],n=t[1],o=t[2],l=t[3],u=t[4],c=t[5],d=t[6],h=t[7];t!==e&&(e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=a*i+u*s,e[1]=n*i+c*s,e[2]=o*i+d*s,e[3]=l*i+h*s,e[4]=u*i-a*s,e[5]=c*i-n*s,e[6]=d*i-o*s,e[7]=h*i-l*s}(this,t,e),this}scale(e,t=this){return function(e,t,r){let s=r[0],i=r[1],a=r[2];e[0]=t[0]*s,e[1]=t[1]*s,e[2]=t[2]*s,e[3]=t[3]*s,e[4]=t[4]*i,e[5]=t[5]*i,e[6]=t[6]*i,e[7]=t[7]*i,e[8]=t[8]*a,e[9]=t[9]*a,e[10]=t[10]*a,e[11]=t[11]*a,e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]}(this,t,"number"==typeof e?[e,e,e]:e),this}multiply(e,t){return t?s(this,e,t):s(this,this,e),this}identity(){return r(this),this}copy(e){var t,r;return r=e,(t=this)[0]=r[0],t[1]=r[1],t[2]=r[2],t[3]=r[3],t[4]=r[4],t[5]=r[5],t[6]=r[6],t[7]=r[7],t[8]=r[8],t[9]=r[9],t[10]=r[10],t[11]=r[11],t[12]=r[12],t[13]=r[13],t[14]=r[14],t[15]=r[15],this}fromPerspective({fov:e,aspect:t,near:r,far:s}={}){return function(e,t,r,s,i){let a=1/Math.tan(t/2),n=1/(s-i);e[0]=a/r,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=a,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=(i+s)*n,e[11]=-1,e[12]=0,e[13]=0,e[14]=2*i*s*n,e[15]=0}(this,e,t,r,s),this}fromOrthogonal({left:e,right:t,bottom:r,top:s,near:i,far:a}){return function(e,t,r,s,i,a,n){let o=1/(t-r),l=1/(s-i),u=1/(a-n);e[0]=-2*o,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=-2*l,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=2*u,e[11]=0,e[12]=(t+r)*o,e[13]=(i+s)*l,e[14]=(n+a)*u,e[15]=1}(this,e,t,r,s,i,a),this}fromQuaternion(e){return a(this,e),this}setPosition(e){return this.x=e[0],this.y=e[1],this.z=e[2],this}transpose(e=this){return function(e,t){if(e===t){let r=t[1],s=t[2],i=t[3],a=t[6],n=t[7],o=t[11];e[1]=t[4],e[2]=t[8],e[3]=t[12],e[4]=r,e[6]=t[9],e[7]=t[13],e[8]=s,e[9]=a,e[11]=t[14],e[12]=i,e[13]=n,e[14]=o}else e[0]=t[0],e[1]=t[4],e[2]=t[8],e[3]=t[12],e[4]=t[1],e[5]=t[5],e[6]=t[9],e[7]=t[13],e[8]=t[2],e[9]=t[6],e[10]=t[10],e[11]=t[14],e[12]=t[3],e[13]=t[7],e[14]=t[11],e[15]=t[15]}(this,e),this}inverse(e=this){return function(e,t){let r=t[0],s=t[1],i=t[2],a=t[3],n=t[4],o=t[5],l=t[6],u=t[7],c=t[8],d=t[9],h=t[10],p=t[11],f=t[12],m=t[13],g=t[14],x=t[15],b=r*o-s*n,v=r*l-i*n,L=r*u-a*n,y=s*l-i*o,S=s*u-a*o,M=i*u-a*l,T=c*m-d*f,G=c*g-h*f,_=c*x-p*f,P=d*g-h*m,B=d*x-p*m,R=h*x-p*g,w=b*R-v*B+L*P+y*_-S*G+M*T;w&&(w=1/w,e[0]=(o*R-l*B+u*P)*w,e[1]=(i*B-s*R-a*P)*w,e[2]=(m*M-g*S+x*y)*w,e[3]=(h*S-d*M-p*y)*w,e[4]=(l*_-n*R-u*G)*w,e[5]=(r*R-i*_+a*G)*w,e[6]=(g*L-f*M-x*v)*w,e[7]=(c*M-h*L+p*v)*w,e[8]=(n*B-o*_+u*T)*w,e[9]=(s*_-r*B-a*T)*w,e[10]=(f*S-m*L+x*b)*w,e[11]=(d*L-c*S-p*b)*w,e[12]=(o*G-n*P-l*T)*w,e[13]=(r*P-s*G+i*T)*w,e[14]=(m*v-f*y-g*b)*w,e[15]=(c*y-d*v+h*b)*w)}(this,e),this}compose(e,t,r){return function(e,t,r,s){let i=t[0],a=t[1],n=t[2],o=t[3],l=i+i,u=a+a,c=n+n,d=i*l,h=i*u,p=i*c,f=a*u,m=a*c,g=n*c,x=o*l,b=o*u,v=o*c,L=s[0],y=s[1],S=s[2];e[0]=(1-(f+g))*L,e[1]=(h+v)*L,e[2]=(p-b)*L,e[3]=0,e[4]=(h-v)*y,e[5]=(1-(d+g))*y,e[6]=(m+x)*y,e[7]=0,e[8]=(p+b)*S,e[9]=(m-x)*S,e[10]=(1-(d+f))*S,e[11]=0,e[12]=r[0],e[13]=r[1],e[14]=r[2],e[15]=1}(this,e,t,r),this}getRotation(e){return i(e,this),this}extractRotation(e){let t=[];return i(t,e),a(this,t),this}fromRotation(e,t){return function(e,t,r){let s,i,a,n=r[0],o=r[1],l=r[2],u=Math.sqrt(n*n+o*o+l*l);Math.abs(u)<1e-6||(u=1/u,n*=u,o*=u,l*=u,s=Math.sin(t),i=Math.cos(t),a=1-i,e[0]=n*n*a+i,e[1]=o*n*a+l*s,e[2]=l*n*a-o*s,e[3]=0,e[4]=n*o*a-l*s,e[5]=o*o*a+i,e[6]=l*o*a+n*s,e[7]=0,e[8]=n*l*a+o*s,e[9]=o*l*a-n*s,e[10]=l*l*a+i,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1)}(this,e,t),this}getTranslation(e){var t,r;return r=this,(t=e)[0]=r[12],t[1]=r[13],t[2]=r[14],this}getScaling(e){return function(e,t){let r=t[0],s=t[1],i=t[2],a=t[4],n=t[5],o=t[6],l=t[8],u=t[9],c=t[10];e[0]=Math.sqrt(r*r+s*s+i*i),e[1]=Math.sqrt(a*a+n*n+o*o),e[2]=Math.sqrt(l*l+u*u+c*c)}(e,this),this}getMaxScaleOnAxis(){return function(e){let t=e[0],r=e[1],s=e[2],i=e[4],a=e[5],n=e[6],o=e[8],l=e[9],u=e[10];const c=t*t+r*r+s*s,d=i*i+a*a+n*n,h=o*o+l*l+u*u;return Math.sqrt(Math.max(c,d,h))}(this)}lookAt(e,t,r){return function(e,t,r,s){let i=t[0],a=t[1],n=t[2],o=s[0],l=s[1],u=s[2],c=i-r[0],d=a-r[1],h=n-r[2],p=c*c+d*d+h*h;p>0&&(p=1/Math.sqrt(p),c*=p,d*=p,h*=p);let f=l*h-u*d,m=u*c-o*h,g=o*d-l*c;p=f*f+m*m+g*g,p>0&&(p=1/Math.sqrt(p),f*=p,m*=p,g*=p),e[0]=f,e[1]=m,e[2]=g,e[3]=0,e[4]=d*g-h*m,e[5]=h*f-c*g,e[6]=c*m-d*f,e[7]=0,e[8]=c,e[9]=d,e[10]=h,e[11]=0,e[12]=i,e[13]=a,e[14]=n,e[15]=1}(this,e,t,r),this}lookAtTarget(e,t,s){return function(e,t,s,i){let a,n,o,l,u,c,d,h,p,f,m=t[0],g=t[1],x=t[2],b=i[0],v=i[1],L=i[2],y=s[0],S=s[1],M=s[2];Math.abs(m-y)<1e-6&&Math.abs(g-S)<1e-6&&Math.abs(x-M)<1e-6?r(e):(d=m-y,h=g-S,p=x-M,f=1/Math.sqrt(d*d+h*h+p*p),d*=f,h*=f,p*=f,a=v*p-L*h,n=L*d-b*p,o=b*h-v*d,f=Math.sqrt(a*a+n*n+o*o),f?(f=1/f,a*=f,n*=f,o*=f):(a=0,n=0,o=0),l=h*o-p*n,u=p*a-d*o,c=d*n-h*a,f=Math.sqrt(l*l+u*u+c*c),f?(f=1/f,l*=f,u*=f,c*=f):(l=0,u=0,c=0),e[0]=a,e[1]=l,e[2]=d,e[3]=0,e[4]=n,e[5]=u,e[6]=h,e[7]=0,e[8]=o,e[9]=c,e[10]=p,e[11]=0,e[12]=-(a*m+n*g+o*x),e[13]=-(l*m+u*g+c*x),e[14]=-(d*m+h*g+p*x),e[15]=1)}(this,e,t,s),this}determinant(){return function(e){let t=e[0],r=e[1],s=e[2],i=e[3],a=e[4],n=e[5],o=e[6],l=e[7],u=e[8],c=e[9],d=e[10],h=e[11],p=e[12],f=e[13],m=e[14],g=e[15];return(t*n-r*a)*(d*g-h*m)-(t*o-s*a)*(c*g-h*f)+(t*l-i*a)*(c*m-d*f)+(r*o-s*n)*(u*g-h*p)-(r*l-i*n)*(u*m-d*p)+(s*l-i*o)*(u*f-c*p)}(this)}fromArray(e,t=0){for(var r=0;r<16;r++)this[r]=e[r+t];return this}toArray(e=[],t=0){let r=this;return e[t]=r[0],e[t+1]=r[1],e[t+2]=r[2],e[t+3]=r[3],e[t+4]=r[4],e[t+5]=r[5],e[t+6]=r[6],e[t+7]=r[7],e[t+8]=r[8],e[t+9]=r[9],e[t+10]=r[10],e[t+11]=r[11],e[t+12]=r[12],e[t+13]=r[13],e[t+14]=r[14],e[t+15]=r[15],e}static copyTo(e=[],t=[]){e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]}}function o(e,t,r){let s=t[0],i=t[1],a=t[2],n=t[3],o=t[4],l=t[5],u=t[6],c=t[7],d=t[8],h=r[0],p=r[1],f=r[2],m=r[3],g=r[4],x=r[5],b=r[6],v=r[7],L=r[8];return e[0]=h*s+p*n+f*u,e[1]=h*i+p*o+f*c,e[2]=h*a+p*l+f*d,e[3]=m*s+g*n+x*u,e[4]=m*i+g*o+x*c,e[5]=m*a+g*l+x*d,e[6]=b*s+v*n+L*u,e[7]=b*i+v*o+L*c,e[8]=b*a+v*l+L*d,e}new n;class l extends Array{constructor(e=1,t=0,r=0,s=0,i=1,a=0,n=0,o=0,l=1){return super(e,t,r,s,i,a,n,o,l),this}get isMatrix3(){return!0}set(e,t,r,s,i,a,n,o,l){return e.length?this.copy(e):(function(e,t,r,s,i,a,n,o,l,u){e[0]=t,e[1]=r,e[2]=s,e[3]=i,e[4]=a,e[5]=n,e[6]=o,e[7]=l,e[8]=u}(this,e,t,r,s,i,a,n,o,l),this)}transpose(){return function(e){let t;t=e[1],e[1]=e[3],e[3]=t,t=e[2],e[2]=e[6],e[6]=t,t=e[5],e[5]=e[7],e[7]=t}(this),this}inverse(e=this){return function(e,t){let r=t[0],s=t[1],i=t[2],a=t[3],n=t[4],o=t[5],l=t[6],u=t[7],c=t[8],d=c*n-o*u,h=-c*a+o*l,p=u*a-n*l,f=r*d+s*h+i*p;f&&(f=1/f,e[0]=d*f,e[1]=(-c*s+i*u)*f,e[2]=(o*s-i*n)*f,e[3]=h*f,e[4]=(c*r-i*l)*f,e[5]=(-o*r+i*a)*f,e[6]=p*f,e[7]=(-u*r+s*l)*f,e[8]=(n*r-s*a)*f)}(this,e),this}translate(e,t=this){return function(e,t,r){let s=t[0],i=t[1],a=t[2],n=t[3],o=t[4],l=t[5],u=t[6],c=t[7],d=t[8],h=r[0],p=r[1];e[0]=s,e[1]=i,e[2]=a,e[3]=n,e[4]=o,e[5]=l,e[6]=h*s+p*n+u,e[7]=h*i+p*o+c,e[8]=h*a+p*l+d}(this,t,e),this}rotate(e,t=this){return function(e,t,r){let s=t[0],i=t[1],a=t[2],n=t[3],o=t[4],l=t[5],u=t[6],c=t[7],d=t[8],h=Math.sin(r),p=Math.cos(r);e[0]=p*s+h*n,e[1]=p*i+h*o,e[2]=p*a+h*l,e[3]=p*n-h*s,e[4]=p*o-h*i,e[5]=p*l-h*a,e[6]=u,e[7]=c,e[8]=d}(this,t,e),this}scale(e,t=this){return function(e,t,r){let s=r[0],i=r[1];e[0]=s*t[0],e[1]=s*t[1],e[2]=s*t[2],e[3]=i*t[3],e[4]=i*t[4],e[5]=i*t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8]}(this,t,e),this}multiply(e,t){return t?o(this,e,t):o(this,this,e),this}identity(){var e;return(e=this)[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=1,e[5]=0,e[6]=0,e[7]=0,e[8]=1,this}copy(e){var t,r;return r=e,(t=this)[0]=r[0],t[1]=r[1],t[2]=r[2],t[3]=r[3],t[4]=r[4],t[5]=r[5],t[6]=r[6],t[7]=r[7],t[8]=r[8],this}fromMatrix4(e){var t,r;return r=e,(t=this)[0]=r[0],t[1]=r[1],t[2]=r[2],t[3]=r[4],t[4]=r[5],t[5]=r[6],t[6]=r[8],t[7]=r[9],t[8]=r[10],this}fromQuaternion(e){return function(e,t){let r=t[0],s=t[1],i=t[2],a=t[3],n=r+r,o=s+s,l=i+i,u=r*n,c=s*n,d=s*o,h=i*n,p=i*o,f=i*l,m=a*n,g=a*o,x=a*l;e[0]=1-d-f,e[3]=c-x,e[6]=h+g,e[1]=c+x,e[4]=1-u-f,e[7]=p-m,e[2]=h-g,e[5]=p+m,e[8]=1-u-d}(this,e),this}fromBasis(e,t,r){return this.set(e[0],e[1],e[2],t[0],t[1],t[2],r[0],r[1],r[2]),this}getNormalMatrix(e){return function(e,t){let r=t[0],s=t[1],i=t[2],a=t[3],n=t[4],o=t[5],l=t[6],u=t[7],c=t[8],d=t[9],h=t[10],p=t[11],f=t[12],m=t[13],g=t[14],x=t[15],b=r*o-s*n,v=r*l-i*n,L=r*u-a*n,y=s*l-i*o,S=s*u-a*o,M=i*u-a*l,T=c*m-d*f,G=c*g-h*f,_=c*x-p*f,P=d*g-h*m,B=d*x-p*m,R=h*x-p*g,w=b*R-v*B+L*P+y*_-S*G+M*T;w&&(w=1/w,e[0]=(o*R-l*B+u*P)*w,e[1]=(l*_-n*R-u*G)*w,e[2]=(n*B-o*_+u*T)*w,e[3]=(i*B-s*R-a*P)*w,e[4]=(r*R-i*_+a*G)*w,e[5]=(s*_-r*B-a*T)*w,e[6]=(m*M-g*S+x*y)*w,e[7]=(g*L-f*M-x*v)*w,e[8]=(f*S-m*L+x*b)*w)}(this,e),this}clone(){return(new l).copy(this)}fromArray(e,t=0){for(var r=0;r<9;r++)this[r]=e[r+t];return this}toArray(){return Array.from(this)}toWebGPUFormat(){const e=new Float32Array(12);return e[3]=0,e[7]=0,e[11]=0,e[0]=this[0],e[1]=this[1],e[2]=this[2],e[4]=this[3],e[5]=this[4],e[6]=this[5],e[8]=this[6],e[9]=this[7],e[10]=this[8],e}}function u(e,t,r){return e[0]=t[0]+r[0],e[1]=t[1]+r[1],e[2]=t[2]+r[2],e}function c(e,t,r){return e[0]=t[0]-r[0],e[1]=t[1]-r[1],e[2]=t[2]-r[2],e}function d(e,t,r){return e[0]=t[0]*r,e[1]=t[1]*r,e[2]=t[2]*r,e}function h(e,t){let r=t[0],s=t[1],i=t[2],a=r*r+s*s+i*i;return a>0&&(a=1/Math.sqrt(a),e[0]=t[0]*a,e[1]=t[1]*a,e[2]=t[2]*a),e}function p(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]}function f(e,t,r){let s=t[0],i=t[1],a=t[2],n=r[3]*s+r[7]*i+r[11]*a+r[15];return n=n||1,e[0]=(r[0]*s+r[4]*i+r[8]*a+r[12])/n,e[1]=(r[1]*s+r[5]*i+r[9]*a+r[13])/n,e[2]=(r[2]*s+r[6]*i+r[10]*a+r[14])/n,e}function m(e,t,r){let s=t[0],i=t[1],a=t[2];return e[0]=s*r[0]+i*r[3]+a*r[6],e[1]=s*r[1]+i*r[4]+a*r[7],e[2]=s*r[2]+i*r[5]+a*r[8],e}const g=function(){let e=[];return function(t,r,s,i,a,n){let o,l;for(r||(r=3),s||(s=0),l=i?Math.min(i*r+s,t.length):t.length,o=s;o<l;o+=r)e[0]=t[o],e[1]=t[o+1],e[2]=t[o+2],a(e,e,n),t[o]=e[0],t[o+1]=e[1],t[o+2]=e[2];return t}}();function x(e,t,r){let s=t[0],i=t[1],a=t[2],n=t[3],o=r[0],l=r[1],u=r[2],c=r[3];return e[0]=s*c+n*o+i*u-a*l,e[1]=i*c+n*l+a*o-s*u,e[2]=a*c+n*u+s*l-i*o,e[3]=n*c-s*o-i*l-a*u,e}const b=function(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e},v=function(e,t,r,s,i){return e[0]=t,e[1]=r,e[2]=s,e[3]=i,e},L=function(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]+e[3]*t[3]},y=function(e,t){let r=t[0],s=t[1],i=t[2],a=t[3],n=r*r+s*s+i*i+a*a;return n>0&&(n=1/Math.sqrt(n),e[0]=r*n,e[1]=s*n,e[2]=i*n,e[3]=a*n),e};class S extends Array{constructor(e=0,t=0,r=0,s=1){return super(e,t,r,s),this.onChange=()=>{},this}get isQuaternion(){return!0}get x(){return this[0]}set x(e){this[0]=e,this.onChange()}get y(){return this[1]}set y(e){this[1]=e,this.onChange()}get z(){return this[2]}set z(e){this[2]=e,this.onChange()}get w(){return this[3]}set w(e){this[3]=e,this.onChange()}identity(){var e;return(e=this)[0]=0,e[1]=0,e[2]=0,e[3]=1,this.onChange(),this}set(e,t,r,s){return e.length?this.copy(e):(v(this,e,t,r,s),this.onChange(),this)}rotateX(e){return function(e,t,r){r*=.5;let s=t[0],i=t[1],a=t[2],n=t[3],o=Math.sin(r),l=Math.cos(r);e[0]=s*l+n*o,e[1]=i*l+a*o,e[2]=a*l-i*o,e[3]=n*l-s*o}(this,this,e),this.onChange(),this}rotateY(e){return function(e,t,r){r*=.5;let s=t[0],i=t[1],a=t[2],n=t[3],o=Math.sin(r),l=Math.cos(r);e[0]=s*l-a*o,e[1]=i*l+n*o,e[2]=a*l+s*o,e[3]=n*l-i*o}(this,this,e),this.onChange(),this}rotateZ(e){return function(e,t,r){r*=.5;let s=t[0],i=t[1],a=t[2],n=t[3],o=Math.sin(r),l=Math.cos(r);e[0]=s*l+i*o,e[1]=i*l-s*o,e[2]=a*l+n*o,e[3]=n*l-a*o}(this,this,e),this.onChange(),this}inverse(e=this){return function(e,t){let r=t[0],s=t[1],i=t[2],a=t[3],n=r*r+s*s+i*i+a*a,o=n?1/n:0;e[0]=-r*o,e[1]=-s*o,e[2]=-i*o,e[3]=a*o}(this,e),this.onChange(),this}conjugate(e=this){var t,r;return r=e,(t=this)[0]=-r[0],t[1]=-r[1],t[2]=-r[2],t[3]=r[3],this.onChange(),this}copy(e){return b(this,e),this.onChange(),this}normalize(e=this){return y(this,e),this.onChange(),this}multiply(e,t){return t?x(this,e,t):x(this,this,e),this.onChange(),this}dot(e){return L(this,e)}fromMatrix3(e){return function(e,t){let r,s=t[0]+t[4]+t[8];if(s>0)r=Math.sqrt(s+1),e[3]=.5*r,r=.5/r,e[0]=(t[5]-t[7])*r,e[1]=(t[6]-t[2])*r,e[2]=(t[1]-t[3])*r;else{let s=0;t[4]>t[0]&&(s=1),t[8]>t[3*s+s]&&(s=2);let i=(s+1)%3,a=(s+2)%3;r=Math.sqrt(t[3*s+s]-t[3*i+i]-t[3*a+a]+1),e[s]=.5*r,r=.5/r,e[3]=(t[3*i+a]-t[3*a+i])*r,e[i]=(t[3*i+s]+t[3*s+i])*r,e[a]=(t[3*a+s]+t[3*s+a])*r}}(this,e),this.onChange(),this}fromEuler(e){return function(e,t,r="YXZ"){let s=Math.sin(.5*t[0]),i=Math.cos(.5*t[0]),a=Math.sin(.5*t[1]),n=Math.cos(.5*t[1]),o=Math.sin(.5*t[2]),l=Math.cos(.5*t[2]);"XYZ"===r?(e[0]=s*n*l+i*a*o,e[1]=i*a*l-s*n*o,e[2]=i*n*o+s*a*l,e[3]=i*n*l-s*a*o):"YXZ"===r?(e[0]=s*n*l+i*a*o,e[1]=i*a*l-s*n*o,e[2]=i*n*o-s*a*l,e[3]=i*n*l+s*a*o):"ZXY"===r?(e[0]=s*n*l-i*a*o,e[1]=i*a*l+s*n*o,e[2]=i*n*o+s*a*l,e[3]=i*n*l-s*a*o):"ZYX"===r?(e[0]=s*n*l-i*a*o,e[1]=i*a*l+s*n*o,e[2]=i*n*o-s*a*l,e[3]=i*n*l+s*a*o):"YZX"===r?(e[0]=s*n*l+i*a*o,e[1]=i*a*l+s*n*o,e[2]=i*n*o-s*a*l,e[3]=i*n*l-s*a*o):"XZY"===r&&(e[0]=s*n*l-i*a*o,e[1]=i*a*l-s*n*o,e[2]=i*n*o+s*a*l,e[3]=i*n*l+s*a*o)}(this,e,e.order),this}slerp(e,t,r){return function(e,t,r,s){let i,a,n,o,l,u=t[0],c=t[1],d=t[2],h=t[3],p=r[0],f=r[1],m=r[2],g=r[3];a=u*p+c*f+d*m+h*g,a<0&&(a=-a,p=-p,f=-f,m=-m,g=-g),1-a>1e-6?(i=Math.acos(a),n=Math.sin(i),o=Math.sin((1-s)*i)/n,l=Math.sin(s*i)/n):(o=1-s,l=s),e[0]=o*u+l*p,e[1]=o*c+l*f,e[2]=o*d+l*m,e[3]=o*h+l*g}(this,e,t,r),this}fromArray(e,t=0){return this[0]=e[t],this[1]=e[t+1],this[2]=e[t+2],this[3]=e[t+3],this}toArray(){return Array.from(this)}}function M(e,t,r){return e[0]=t[0]+r[0],e[1]=t[1]+r[1],e}function T(e,t,r){return e[0]=t[0]-r[0],e[1]=t[1]-r[1],e}function G(e,t,r){return e[0]=t[0]*r,e[1]=t[1]*r,e}function _(e){var t=e[0],r=e[1];return Math.sqrt(t*t+r*r)}class P extends Array{constructor(e=0,t=e){return super(e,t),this}get isVector2(){return!0}get x(){return this[0]}set x(e){this[0]=e}get y(){return this[1]}set y(e){this[1]=e}get width(){return this[0]}set width(e){this[0]=e}get height(){return this[1]}set height(e){this[1]=e}set(e,t=e){return e.length?this.copy(e):(function(e,t,r){e[0]=t,e[1]=r}(this,e,t),this)}copy(e){var t,r;return r=e,(t=this)[0]=r[0],t[1]=r[1],this}add(e,t){return t?M(this,e,t):M(this,this,e),this}sub(e,t){return t?T(this,e,t):T(this,this,e),this}multiply(e){var t,r,s;return e.length?(r=this,s=e,(t=this)[0]=r[0]*s[0],t[1]=r[1]*s[1]):G(this,this,e),this}divide(e){var t,r,s;return e.length?(r=this,s=e,(t=this)[0]=r[0]/s[0],t[1]=r[1]/s[1]):G(this,this,1/e),this}scale(e){return G(this,this,e),this}distance(e){return e?(t=this,s=(r=e)[0]-t[0],i=r[1]-t[1],Math.sqrt(s*s+i*i)):_(this);var t,r,s,i}squaredDistance(e){return e?(t=this,s=(r=e)[0]-t[0],i=r[1]-t[1],s*s+i*i):function(e){var t=e[0],r=e[1];return t*t+r*r}(this);var t,r,s,i}len(){return _(this)}squaredLength(){return this.squaredDistance()}negate(e=this){var t,r;return r=e,(t=this)[0]=-r[0],t[1]=-r[1],this}inverse(e=this){var t,r;return r=e,(t=this)[0]=1/r[0],t[1]=1/r[1],this}normalize(){var e,t,r,s,i;e=this,r=(t=this)[0],s=t[1],(i=r*r+s*s)>0&&(i=1/Math.sqrt(i),e[0]=t[0]*i,e[1]=t[1]*i)}dot(e){return r=e,(t=this)[0]*r[0]+t[1]*r[1];var t,r}cross(e,t){return s=t,(r=e)[0]*s[1]-r[1]*s[0];var r,s}lerp(e,t,r){!function(e,t,r,s){var i=t[0],a=t[1];e[0]=i+s*(r[0]-i),e[1]=a+s*(r[1]-a)}(this,e,t,r)}applyMatrix3(e){var t,r,s,i,a;return t=this,s=e,i=(r=this)[0],a=r[1],t[0]=s[0]*i+s[3]*a+s[6],t[1]=s[1]*i+s[4]*a+s[7],this}applyMatrix4(e){return function(e,t,r){let s=t[0],i=t[1];e[0]=r[0]*s+r[4]*i+r[12],e[1]=r[1]*s+r[5]*i+r[13]}(this,this,e),this}equals(e){return r=e,(t=this)[0]===r[0]&&t[1]===r[1];var t,r}clone(){return new P(this[0],this[1])}fromArray(e,t=0){return this[0]=e[t],this[1]=e[t+1],this}toArray(){return Array.from(this)}}class B extends Array{constructor(e=0,t=e,r=e){return super(e,t,r),this.constant=1,this}get isVector3(){return!0}get x(){return this[0]}set x(e){this[0]=e}get y(){return this[1]}set y(e){this[1]=e}get z(){return this[2]}set z(e){this[2]=e}set(e,t=e,r=e){return e.length?this.copy(e):(function(e,t,r,s){e[0]=t,e[1]=r,e[2]=s}(this,e,t,r),this)}copy(e){var t,r;return r=e,(t=this)[0]=r[0],t[1]=r[1],t[2]=r[2],this}add(e,t){return t?u(this,e,t):u(this,this,e),this}sub(e,t){return t?c(this,e,t):c(this,this,e),this}multiply(e){var t,r,s;return e.length?(r=this,s=e,(t=this)[0]=r[0]*s[0],t[1]=r[1]*s[1],t[2]=r[2]*s[2]):d(this,this,e),this}divide(e){var t,r,s;return e.length?(r=this,s=e,(t=this)[0]=r[0]/s[0],t[1]=r[1]/s[1],t[2]=r[2]/s[2]):d(this,this,1/e),this}scale(e){return d(this,this,e),this}distance(e){return e?function(e,t){let r=t[0]-e[0],s=t[1]-e[1],i=t[2]-e[2];return Math.sqrt(r*r+s*s+i*i)}(this,e):function(e){let t=e[0],r=e[1],s=e[2];return Math.sqrt(t*t+r*r+s*s)}(this)}squaredDistance(e){return e?function(e,t){let r=t[0]-e[0],s=t[1]-e[1],i=t[2]-e[2];return r*r+s*s+i*i}(this,e):function(e){let t=e[0],r=e[1],s=e[2];return t*t+r*r+s*s}(this)}squaredLength(){return this.squaredDistance()}negate(e=this){var t,r;return r=e,(t=this)[0]=-r[0],t[1]=-r[1],t[2]=-r[2],this}reflect(e){let t=e.clone();return this.sub(t.multiply(2*this.dot(e)))}inverse(e=this){var t,r;return r=e,(t=this)[0]=1/r[0],t[1]=1/r[1],t[2]=1/r[2],this}normalize(){return h(this,this),this}dot(e){return p(this,e)}cross(e,t){return function(e,t,r){let s=t[0],i=t[1],a=t[2],n=r[0],o=r[1],l=r[2];e[0]=i*l-a*o,e[1]=a*n-s*l,e[2]=s*o-i*n}(this,e,t),this}lerp(e,t,r){return function(e,t,r,s){let i=t[0],a=t[1],n=t[2];e[0]=i+s*(r[0]-i),e[1]=a+s*(r[1]-a),e[2]=n+s*(r[2]-n)}(this,e,t,r),this}hermite(e,t,r,s,i){return function(e,t,r,s,i,a){let n=a*a,o=n*(2*a-3)+1,l=n*(a-2)+a,u=n*(a-1),c=n*(3-2*a);e[0]=t[0]*o+r[0]*l+s[0]*u+i[0]*c,e[1]=t[1]*o+r[1]*l+s[1]*u+i[1]*c,e[2]=t[2]*o+r[2]*l+s[2]*u+i[2]*c}(this,e,t,r,s,i),this}bezier(e,t,r,s,i){return function(e,t,r,s,i,a){let n=1-a,o=n*n,l=a*a,u=o*n,c=3*a*o,d=3*l*n,h=l*a;e[0]=t[0]*u+r[0]*c+s[0]*d+i[0]*h,e[1]=t[1]*u+r[1]*c+s[1]*d+i[1]*h,e[2]=t[2]*u+r[2]*c+s[2]*d+i[2]*h}(this,e,t,r,s,i),this}applyMatrix4(e){return f(this,this,e),this}applyMatrix3(e){return m(this,this,e),this}applyQuaternion(e){return function(e,t,r){let s=t[0],i=t[1],a=t[2],n=r[0],o=r[1],l=r[2],u=r[3],c=u*s+o*a-l*i,d=u*i+l*s-n*a,h=u*a+n*i-o*s,p=-n*s-o*i-l*a;e[0]=c*u+p*-n+d*-l-h*-o,e[1]=d*u+p*-o+h*-n-c*-l,e[2]=h*u+p*-l+c*-o-d*-n}(this,this,e),this}setFromMatrixPosition(e){return this.x=e[12],this.y=e[13],this.z=e[14],this}angle(e){return function(e,t){let r=[...e],s=[...t];h(r,r),h(s,s);let i=p(r,s);return i>1?0:i<-1?Math.PI:Math.acos(i)}(this,e)}equals(e){return r=e,(t=this)[0]===r[0]&&t[1]===r[1]&&t[2]===r[2];var t,r}clone(){return new B(this[0],this[1],this[2])}fromArray(e,t=0){return this[0]=e[t],this[1]=e[t+1],this[2]=e[t+2],this}min(e){return this[0]=Math.min(this[0],e.x),this[1]=Math.min(this[1],e.y),this[2]=Math.min(this[2],e.z),this}max(e){return this[0]=Math.max(this[0],e.x),this[1]=Math.max(this[1],e.y),this[2]=Math.max(this[2],e.z),this}toArray(){return Array.from(this)}static copyTo(e,t){e[0]=t[0],e[1]=t[1],e[2]=t[2]}}const R=[new B,new B,new B,new B,new B,new B,new B,new B];class w{constructor(e=new B(1/0),t=new B(-1/0)){this.min=e,this.max=t}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(e){return this.isEmpty()?e.set(0,0,0):e.add(this.min,this.max).multiply(.5)}getSize(e){return this.isEmpty()?e.set(0,0,0):e.sub(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}intersectsBox(e){return!(e.max.x<this.min.x||e.min.x>this.max.x||e.max.y<this.min.y||e.min.y>this.max.y||e.max.z<this.min.z||e.min.z>this.max.z)}setFromPoints(e){this.makeEmpty();for(let t=0,r=e.length;t<r;t++)this.expandByPoint(e[t]);return this}applyMatrix4(e){return this.isEmpty()||(R[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(e),R[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(e),R[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(e),R[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(e),R[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(e),R[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(e),R[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(e),R[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(e),this.setFromPoints(R)),this}}class I{constructor(){this.focus=10,this.aperture=0,this.zoom=1,this.tempVec3a=new B,this.tempVec3b=new B,this.type="PerspectiveCamera",this.viewToWorldMat=new n,this.worldToViewMat=new n,this.viewToClipMat=new n,this.clipToViewMat=new n,this.position=new B}copy(e){return this.type=e.type,this.focus=e.focus,this.aperture=e.aperture,this.zoom=e.zoom,this.viewToWorldMat.copy(e.viewToWorldMat),this.worldToViewMat.copy(e.worldToViewMat),this.viewToClipMat.copy(e.viewToClipMat),this.clipToViewMat.copy(e.clipToViewMat),this.position.copy(e.position),this}clone(){return(new I).copy(this)}updateFrustum(){this.frustum||(this.frustum=[new B,new B,new B,new B,new B,new B]);const e=(new n).multiply(this.viewToClipMat,this.worldToViewMat);this.frustum[0].set(e[3]-e[0],e[7]-e[4],e[11]-e[8]).constant=e[15]-e[12],this.frustum[1].set(e[3]+e[0],e[7]+e[4],e[11]+e[8]).constant=e[15]+e[12],this.frustum[2].set(e[3]+e[1],e[7]+e[5],e[11]+e[9]).constant=e[15]+e[13],this.frustum[3].set(e[3]-e[1],e[7]-e[5],e[11]-e[9]).constant=e[15]-e[13],this.frustum[4].set(e[3]-e[2],e[7]-e[6],e[11]-e[10]).constant=e[15]-e[14],this.frustum[5].set(e[3]+e[2],e[7]+e[6],e[11]+e[10]).constant=e[15]+e[14];for(let t=0;t<6;t++){const e=1/this.frustum[t].distance();this.frustum[t].multiply(e),this.frustum[t].constant*=e}}frustumIntersectsMesh(e){if(!e.geometry.position)return!0;if(!e.geometry.aabb)return!0;const t=e.geometry.aabb;t.getCenter(this.tempVec3a);const r=this.tempVec3a,s=t.min.distance(t.max)/2;r.applyMatrix4(e.localToWorldMat);const i=s*e.localToWorldMat.getMaxScaleOnAxis();return this.frustumIntersectsSphere(r,i)}frustumIntersectsSphere(e,t){const r=this.tempVec3b;for(let s=0;s<6;s++){const i=this.frustum[s];if(r.copy(i).dot(e)+i.constant<-t)return!1}return!0}}class z{constructor(e=new F,t=new N){this.geometry=e,this.material=t,this.visible=!0,this.tlasMask=!1,this.localToWorldMat=new n}get worldToLocalMat(){return(new n).inverse(this.localToWorldMat)}copy(e){return this.geometry=e.geometry,this.material.copy(e.material),this.localToWorldMat.copy(e.localToWorldMat),this}clone(e=!0){let t=this.material;e&&(t=this.material.clone());const r=new z(this.geometry,t);return r.localToWorldMat.copy(this.localToWorldMat),r}}class W{constructor(e=new B,t=0,r=new B,s=0,i=new B,a=0,n=new B,o=!0){this.position=e,this.radius=t,this.emission=r,this.area=s,this.p1=i,this.type=a,this.p2=n,this.visible=o}copy(e){return this.position.copy(e.position),this.radius=e.radius,this.emission.copy(e.emission),this.area=e.area,this.p1.copy(e.p1),this.type=e.type,this.p2.copy(e.p2),this.visible=e.visible,this}clone(){return new W(this.position,this.radius,this.emission,this.area,this.p1,this.type,this.p2,this.visible)}}class X{constructor(e,t){this.array=e,this.itemSize=t}getItem(e,t){const r=this.array,s=this.itemSize,i=t*s;for(let a=0;a<s;a++)e[a]=r[i+a]}get count(){return this.array.length/this.itemSize}}class C{constructor(e,t,r,s){this.position=e,this.normal=t,this.uv=r,this.indices=s}}class F extends C{constructor(){const e=new Float32Array([.5,.5,.5,.5,.5,-.5,.5,-.5,.5,.5,-.5,-.5,-.5,.5,-.5,-.5,.5,.5,-.5,-.5,-.5,-.5,-.5,.5,-.5,.5,-.5,.5,.5,-.5,-.5,.5,.5,.5,.5,.5,-.5,-.5,.5,.5,-.5,.5,-.5,-.5,-.5,.5,-.5,-.5,-.5,.5,.5,.5,.5,.5,-.5,-.5,.5,.5,-.5,.5,.5,.5,-.5,-.5,.5,-.5,.5,-.5,-.5,-.5,-.5,-.5]),t=new Float32Array([1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1]),r=new Float32Array([0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,0]),s=new Uint16Array([0,2,1,2,3,1,4,6,5,6,7,5,8,10,9,10,11,9,12,14,13,14,15,13,16,18,17,18,19,17,20,22,21,22,23,21]);super(new X(e,3),new X(t,3),new X(r,2),new X(s,1)),this.name="LGL_DefaultCubeGeometry",this.aabb=new w(new B(-.5,-.5,-.5),new B(.5,.5,.5))}}class A{constructor(e){this.image=e,this.isTexture=!0,this.uvTransMat=new l,this.wrapS=0,this.wrapT=0,this.flipY=!1}}class D{constructor(){this.name="",this.type="",this.isRayTracingMaterial=!0}setValues(e){if(void 0!==e)for(const t in e){const r=e[t];if(void 0===r){console.warn(`${this.name}: ${t} parameter is undefined.`);continue}const s=this[t];void 0!==s&&(s&&s.isColor?s.set(r):s&&s.isVector3&&r&&r.isVector3?s.copy(r):this[t]=r)}}copy(e){}}class N extends D{constructor(e){super(),this.type="PrincipleBSDF",this.workflow="Metalness",this.color=new t(1,1,1),this.roughness=.5,this.metalness=0,this.transmission=0,this.ior=1.5,this.clearcoat=0,this.clearcoatRoughness=0,this.sheen=0,this.sheenTint=.5,this.specularTint=0,this.atDistance=1,this.extinction=new t(1,1,1),this.anisotropic=0,this.subsurface=0,this.subsurfaceColor=new t(1,1,1),this.subsurfaceMFP=.05,this.emissiveColor=new t(0,0,0),this.normalScale=new P(1,1),this.opacity=1,this.map=null,this.normalMap=null,this.roughnessMap=null,this.metalnessMap=null,this.emissiveMap=null,this.specularColor=new t(1,1,1),this.glossiness=1,this.specularMap=null,this.glossinessMap=null,this.setValues(e)}isIncludeTexture(){return!!(this.map||this.normalMap||this.roughnessMap||this.metalnessMap||this.emissiveMap||this.specularMap||this.glossinessMap)}copy(e){return this.name=`copy_${e.name}`,this.type=e.type,this.workflow=e.workflow,this.color=(new t).copy(e.color),this.roughness=e.roughness,this.metalness=e.metalness,this.transmission=e.transmission,this.ior=e.ior,this.specularTint=e.specularTint,this.clearcoat=e.clearcoat,this.clearcoatRoughness=e.clearcoatRoughness,this.sheen=e.sheen,this.sheenTint=e.sheenTint,this.atDistance=e.atDistance,this.anisotropic=e.anisotropic,this.extinction=(new t).copy(e.extinction),this.subsurface=e.subsurface,this.subsurfaceColor=(new t).copy(e.subsurfaceColor),this.subsurfaceMFP=e.subsurfaceMFP,this.emissiveColor=(new t).copy(e.emissiveColor),this.normalScale=(new P).copy(e.normalScale),this.opacity=e.opacity,this.map=e.map,this.normalMap=e.normalMap,this.roughnessMap=e.roughnessMap,this.metalnessMap=e.metalnessMap,this.emissiveMap=e.emissiveMap,this.specularColor=(new t).copy(e.specularColor),this.glossiness=e.glossiness,this.specularMap=e.specularMap,this.glossinessMap=e.glossinessMap,this}clone(){return(new N).copy(this)}}class V{constructor(e,t,r="f32",s=1,i=GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM){switch(this.rg=e,r){case"u32":this.data=new Uint32Array(s);break;case"f32":this.data=new Float32Array(s);break;case"i32":this.data=new Int32Array(s)}this.rawBuffer=e.resourcePool.getOrCreateResource(t,{size:this.data.byteLength,usage:i}).raw}setData(e,t){this.data[e]=t}submit(){this.rg.device.queue.writeBuffer(this.rawBuffer,0,this.data)}destroy(){this.rawBuffer.destroy()}}const U={i32:{align:4,size:4,count:1},u32:{align:4,size:4,count:1},f32:{align:4,size:4,count:1},atomic:{align:4,size:4,count:1},"vec2<f32>":{align:8,size:8,count:2},"vec3<f32>":{align:16,size:12,count:3},"vec4<f32>":{align:16,size:16,count:4},"vec2<u32>":{align:8,size:8,count:2},"vec3<u32>":{align:16,size:12,count:3},"vec4<u32>":{align:16,size:16,count:4},"vec2<i32>":{align:8,size:8,count:2},"vec3<i32>":{align:16,size:12,count:3},"vec4<i32>":{align:16,size:16,count:4},"mat2x2<f32>":{align:8,size:16,count:4},"mat3x3<f32>":{align:16,size:48,count:12},"mat4x4<f32>":{align:16,size:64,count:16}};function E(e){return Boolean(e&&"object"==typeof e&&(Array.isArray(e)||ArrayBuffer.isView(e)&&!(e instanceof DataView)))}class k{static get desc(){throw new Error("This method must be implemented!")}static getStride(){const e=this.desc;let t=Math.max(...e.map((e=>this.getMemberAlignment(e)))),r=0;for(const s of e){const e=this.getMemberAlignment(s),t=r%e;r%e!=0&&(r+=e-t),r+=this.getMemberSize(s)}return r%t!=0&&(r+=t-r%t),r}static getMemberAlignment(e){return U[e.type].align}static getMemberSize(e){return U[e.type].size}constructor(e){const t=this.constructor.desc,r=/<(.*?)>/,s=[];for(const i of t){const t={};t.name=i.name,t.type=i.type;const a=e[i.name];if(void 0===a)throw new Error(`Unexpected member value for: ${i.name}`);t.value=a,t.count=U[i.type].count;if((E(a)?a:[a]).length!==t.count)throw new Error(`Unexpected member length: ${i.name} ${a}`);if(1===t.count)t.format=t.type;else{let e=t.type.match(r);if(!e)throw new Error(`Unexpected member format: ${t.type}`);t.format=e[1]}s.push(t)}this.members=s}toArrayBuffer(){const e=new ArrayBuffer(this.constructor.getStride()),t=new DataView(e);let r=0;for(const s of this.members){let e=r+this.constructor.getMemberSize(s);for(let i=0;i<s.count;i++){const e=E(s.value)?s.value:[s.value];switch(s.format){case"i32":t.setInt32(r,e[i],!0);break;case"f32":t.setFloat32(r,e[i],!0);break;case"u32":t.setUint32(r,e[i],!0);break;default:throw new Error(`Unsupported member type: ${s.format}`)}r+=4}r=e}return e}}const K=4,H=!0,Z=!0,O=4,Y=!1,q={size:1,usage:GPUBufferUsage.UNIFORM},J={size:{width:1,height:1},format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING};class Q{constructor(e){this.device=e,this.passNodes=[],this.resourceNodes=[],this.frameGraphPasses=[],this.computePipelines=new Map,this.renderPipelines=new Map,this.bindGroups=new Map,this.needsResize=!1,this.resourcePool=new se(e),this.samplers={llc:e.createSampler({magFilter:"linear",minFilter:"linear",addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge"}),llr:e.createSampler({magFilter:"linear",minFilter:"linear",addressModeU:"repeat",addressModeV:"repeat"}),nnc:e.createSampler({magFilter:"nearest",minFilter:"nearest",addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge"}),nnr:e.createSampler({magFilter:"nearest",minFilter:"nearest",addressModeU:"repeat",addressModeV:"repeat"})}}async getOrCreateComputePipeline(e,t,r){const{device:s}=this,i=`${e}-${t}`;if(this.computePipelines.get(i))return this.computePipelines.get(i);{const e=await s.createComputePipelineAsync({layout:"auto",compute:{module:s.createShaderModule({code:r}),entryPoint:"main"}});return this.computePipelines.set(i,e),e}}getComputePipeline(e,t=""){const r=`${e}-${t}`;return this.computePipelines.get(r)}getRenderPipeline(e,t=""){const r=`${e}-${t}`;return this.renderPipelines.get(r)}setRenderPipeline(e,t="",r){const s=`${e}-${t}`;return this.renderPipelines.set(s,r)}getPassResFromPool(e){const{resourcePool:t}=this;if(e){const r=this.getResourceNode(e).resource;return t.getOrCreateResource(r.name,r.descriptor,r.syncResize)}}getPassRawResFromPool(e){return this.getPassResFromPool(e).raw}getRawResFromPool(e){return this.resourcePool.getResourceByName(e).raw}getBindGroupByHandles(e,t,r,s){var i;let a="";r.forEach((e=>{const t=this.getResourceNode(e).resource,r=t.name,s=JSON.stringify(t.descriptor);a+=`-${r}/${s}`}));const n=`${e}-${a}`;if(this.bindGroups.get(n))return this.bindGroups.get(n);{const e=[];if(r.forEach(((t,r)=>{const s=this.getPassResFromPool(t),{raw:i,type:a}=s;e.push({binding:r,resource:"Texture"==a?i.createView():{buffer:i}})})),null==(i=null==s?void 0:s.samplers)?void 0:i.length){const t=e.length;s.samplers.forEach(((r,s)=>{const i=this.samplers[r];e.push({binding:t+s,resource:i})}))}const a=this.device.createBindGroup({layout:t.getBindGroupLayout(0),entries:e});return this.bindGroups.set(n,a),a}}getBindGroup(e,t,r,s){const i=[...r.reads,...r.writes];return this.getBindGroupByHandles(e,t,i,s)}checkResourceNodeCache(e){let t=null;return this.resourceNodes.forEach(((r,s)=>{if(e==r.resource.name)return t=new te,void(t.index=s)})),t}importResource(e,t=!1){const r=new ee;return r.name=e,r.imported=!0,r.syncResize=t,this.createResourceNode(r)}createTexture(e,t=J,r=!1){const s=new ee;return s.name=e,s.descriptor=t,s.syncResize=r,this.createResourceNode(s)}createBuffer(e,t=q,r=!1){const s=new ee;return s.name=e,s.descriptor=t,s.syncResize=r,this.createResourceNode(s)}createResourceNode(e){const t=this.checkResourceNodeCache(e.name);if(t)return t;const r=new re;r.resource=e,this.resourceNodes.push(r);const s=new te;return s.index=this.resourceNodes.length-1,s}getPass(e){return this.frameGraphPasses.find((t=>t.name===e))}getResourceNode(e){return this.resourceNodes[e.index]}addPass(e,t){const r=new j;r.execute=t.execute.bind(t),t.tearDown&&(r.tearDown=t.tearDown.bind(t)),r.name=e;const s=new $;return s.name=e,this.passNodes.push(s),this.frameGraphPasses.push(r),t.setup(this,s,r),r}setDebugHookPass(){this.passNodes[this.passNodes.length-1].name}addDebugHook(){}execute(e){this.compile(),this.executePassNodes(e)}compile(){for(const t of this.passNodes)t.refCount=t.writes.length+(t.hasSideEffect?1:0),t.reads.forEach((e=>{this.resourceNodes[e.index].readerCount++}));const e=[];for(const t of this.resourceNodes)0===t.readerCount&&e.push(t);for(;e.length;){const t=e.pop(),r=t&&t.writer;if(r&&0==--r.refCount)for(const s of r.reads){const t=this.resourceNodes[s.index];0==--t.readerCount&&e.push(t)}}this.resourceNodes.forEach((e=>{e.resource.refs+=e.readerCount}))}executePassNodes(e){for(const[t,r]of this.passNodes.entries())if(r.refCount){const s=this.frameGraphPasses[t];s.execute(this,s,r,e)}this.reset()}setSize(){this.needsResize=!0,this.destroyPreSizeRes(),this.forceUpdateBG()}forceUpdateBG(){this.bindGroups=new Map}destroyPreSizeRes(){const e=this.resourcePool.getPool();for(const t in e){e[t].syncResize&&this.resourcePool.destoryResourceByName(t)}}reset(){this.passNodes=[],this.resourceNodes=[],this.frameGraphPasses=[]}tearDown(){this.frameGraphPasses.forEach((e=>{e.tearDown&&e.tearDown()})),this.reset()}}class j{}class ${constructor(){this.refCount=0,this.hasSideEffect=!1,this.devirtualize=[],this.destroy=[],this.reads=[],this.writes=[]}read(e){return this.reads.find((t=>t.index===e.index))||this.reads.push(e),e}write(e,t,r=!1){if(this.writes.find((e=>e.index===t.index)))return t;const s=e.getResourceNode(t);s.resource.version++,(s.resource.imported||r)&&(this.hasSideEffect=!0);const i=e.createResourceNode(s.resource);return e.getResourceNode(i).writer=this,r||this.writes.push(i),i}}class ee extends class{}{constructor(){super(...arguments),this.version=0,this.refs=0}devirtualize(){}destroy(){}}class te{}class re{constructor(){this.readerCount=0}}class se{constructor(e){this.device=e,this.resourcePool={}}getOrCreateResource(e,t,r=!1){const{device:s}=this;return this.resourcePool[e]||(!function(e){return"format"in e}(t)?this.resourcePool[e]={raw:s.createBuffer(t),type:"Buffer",syncResize:r}:this.resourcePool[e]={raw:s.createTexture(t),type:"Texture",syncResize:r}),this.resourcePool[e]}getResourceByName(e){return this.resourcePool[e]}destoryResourceByName(e){this.resourcePool[e]&&(this.resourcePool[e].raw.destroy(),delete this.resourcePool[e])}setResource(e,t,r,s=!1){this.destoryResourceByName(e),this.resourcePool[e]={raw:t,type:r,syncResize:s}}updateResource(e,t,r,s=!1){this.destoryResourceByName(e),this.resourcePool[e]={raw:t,type:r,syncResize:s}}createOrUpdateResource(e){return this.resourcePool[e.name]&&this.destoryResourceByName(e.name),this.getOrCreateResource(e.name,e.descriptor,e.syncResize),this.resourcePool[e.name]}getPool(){return this.resourcePool}destroy(){for(const e in this.resourcePool){this.resourcePool[e].raw.destroy()}this.resourcePool={}}}function ie(e,t,r){var s;return Object.assign({},r,{lightNum:null==(s=e.lights)?void 0:s.length,enableSSS:e.includeSSS,enableVolume:e.includeVolume,enableAtomsphere:e.includeAtomsphere})}const ae=["color","roughness","metalness","transmission","ior","clearcoat","clearcoatRoughness","sheen","sheenTint","specularTint","atDistance","extinction","anisotropic","subsurface","subsurfaceColor","subsurfaceMFP","normalScale","opacity","specularColor","glossiness","glossiness","emissiveIntensity","emissive"],ne=["map","normalMap","roughnessMap","metalnessMap","specularMap","glossinessMap","emissiveMap"],oe={1e3:0,1001:1,1002:2};function le(e){const t=new Map;for(const r of e){const e=r.material;let s=t.get(e);void 0===s&&(s=t.size,t.set(e,s))}return 0==t.size&&t.set(new D,0),t}function ue(e,t=!1,r=new Map){e.updateMatrixWorld(!0);const s=[],i=[];if(t){const e=new z;e.name="LGLDefaultMesh",e.material.name="LGLDefaultMaterial",e.visible=!1,e.localToWorldMat.scale([1e-4,1e-4,1e-4]),s.push(e)}let a=!1;const n=new Map;e.traverse((e=>{if(e.isMesh){let t=e;if(t.geometry){let e=t.material;if(t.material||(e=new N),!e.isRayTracingMaterial){const r=n.get(e);r?e=r:(e=ge(t.material),n.set(t.material,e))}e.subsurface>0&&(a=!0);let i=r.get(t.geometry.id);i||(i=pe(t.geometry),r.set(t.geometry.id,i));const o=new z(i,e);Fr.linkMeshWithTHREEMesh(o,t),s.push(o)}else console.warn(`${e.name} need geometry data`)}if(e.isLight&&e.visible){const t=ce(e);i.push(t)}}));const o=le(s);return{meshes:s,materialIndexMap:o,materials:Array.from(o.keys()),geometryConvertMap:r,lights:i,includeSSS:a,includeVolume:!1,includeAtomsphere:!1}}function ce(e){const t=new n,r=new S,s=e,i=new W,a=new B;switch(s.updateWorldMatrix(!0,!1),a.setFromMatrixPosition(s.matrixWorld.elements),i.position=a,i.emission=(new B).fromArray(s.color.toArray()).multiply(s.intensity),i.radius=s.radius||0,i.area=0,i.visible=s.visible,i.p1=new B,i.p2=new B,s.type){case"RectAreaLight":if(i.type=0,s.matrix.compose(s.position,s.quaternion,s.scale),t.fromArray(s.matrixWorld.elements),t.getRotation(r),s.width&&s.height){const e=new B(s.width,0,0);e.applyQuaternion(r);const t=new B(0,s.height,0);t.applyQuaternion(r),i.p1.copy(t),i.p2.copy(e),i.area=(new B).cross(i.p1,i.p2).distance()}break;case"PointLight":i.type=2,i.area=0;break;case"DirectionalLight":i.type=1,s.target&&i.p1.fromArray(s.target.position.toArray()),i.area=0;break;case"SpotLight":i.type=3;const e=new B;s.target&&e.fromArray(s.target.position.toArray());const n=(new B).sub(e,a).normalize();i.p1.copy(n),i.p2.x=Math.cos(s.angle),i.p2.y=Math.cos(s.angle*(1-s.penumbra)),i.p2.z=s.decay;break;default:console.warn(`Current no support light type: ${s.type}`)}return Fr.linkLightWithTHREELight(i,e),i}function de(e,t){e.updateMatrixWorld(!0);const r=t||new I;return r.type=e.type,r.viewToWorldMat.fromArray(e.matrixWorld.elements),r.worldToViewMat.fromArray(e.matrixWorldInverse.elements),r.clipToViewMat.fromArray(e.projectionMatrixInverse.elements),r.viewToClipMat.fromArray(e.projectionMatrix.elements),r.position.fromArray(e.position.toArray()),null!=e.aperture&&(r.aperture=e.aperture||0),null!=e.focus&&(r.focus=e.focus||0),null!=e.zoom&&(r.zoom=e.zoom||1),r}function he(e,t){const r=e.getAttribute(t);return(null==r?void 0:r.isInterleavedBufferAttribute)?r.clone():r}function pe(e){var t,r;const s=he(e,"position"),i=he(e,"normal"),a=he(e,"uv"),n=e.getIndex(),o=new C(s&&new X(s.array,s.itemSize),i&&new X(i.array,i.itemSize),a&&new X(a.array,a.itemSize),n&&new X(n.array,n.itemSize));return o.id=`LGL_${e.id}`,o.name=`LGL_${e.name}`,e.boundingBox||e.computeBoundingBox(),o.aabb=new w,o.aabb.min.fromArray(null==(t=e.boundingBox)?void 0:t.min.toArray()),o.aabb.max.fromArray(null==(r=e.boundingBox)?void 0:r.max.toArray()),o}function fe(e,t){ne.forEach((r=>{const s=e[r],i=t[r];s&&(s.updateMatrix(),i.uvTransMat.fromArray(s.matrix.toArray()),i.wrapS=oe[s.wrapS],i.wrapT=oe[s.wrapT])}))}function me(e){if(!e)return null;const t=new A(e.image);return t.flipY=e.flipY,t}function ge(e,t){var r,s,i,a,n,o,l,u,c;Array.isArray(e)&&(e=e[0]);const d=t||new N;return d.name=`LGL_${e.name}`,function(e,t){ae.forEach((r=>{if(null==e[r]&&null==e.userData[r])switch(r){case"emissive":e.userData[r]=t.emissiveColor.toArray();break;case"emissiveIntensity":e.userData[r]=1;break;default:e.userData[r]=t[r].toArray?t[r].toArray():t[r]}}))}(e,d),e.color?d.color.fromArray(e.color.toArray()):d.color.fromArray(e.userData.color),d.roughness=null!=(r=e.roughness)?r:e.userData.roughness,d.metalness=null!=(s=e.metalness)?s:e.userData.metalness,d.transmission=null!=(i=e.transmission)?i:e.userData.transmission,d.ior=null!=(a=e.ior)?a:e.userData.ior,e.emissive?d.emissiveColor.fromArray(e.emissive.toArray()).scale(e.emissiveIntensity):d.emissiveColor.fromArray(e.userData.emissive).scale(e.userData.emissiveIntensity),e.normalScale?d.normalScale.fromArray(e.normalScale.toArray()):d.normalScale.fromArray(e.userData.normalScale),d.clearcoat=null!=(n=e.clearcoat)?n:e.userData.clearcoat,d.clearcoatRoughness=null!=(o=e.clearcoatRoughness)?o:e.userData.clearcoatRoughness,d.sheen=null!=(l=e.sheen)?l:e.userData.sheen,d.sheenTint=null!=(u=e.sheenTint)?u:e.userData.sheenTint,d.opacity=null!=(c=e.opacity)?c:e.userData.opacity,d.map=me(e.map),d.normalMap=me(e.normalMap),d.emissiveMap=me(e.emissiveMap),d.roughnessMap=me(e.roughnessMap),d.metalnessMap=me(e.metalnessMap),e.isGLTFSpecularGlossinessMaterial&&(d.workflow="Specular",d.specularColor.fromArray(e.specular.toArray()),d.glossiness=e.glossiness,d.specularMap=me(e.specularMap),d.glossinessMap=me(e.glossinessMap)),d.subsurface=e.userData.subsurface,d.subsurfaceMFP=e.userData.subsurfaceMFP,d.subsurfaceColor.fromArray(e.userData.subsurfaceColor),d.specularTint=e.userData.specularTint,d.atDistance=e.userData.atDistance,d.extinction.fromArray(e.userData.extinction),d.anisotropic=e.userData.anisotropic,fe(e,d),d}const xe=be();function be(){const e=new ArrayBuffer(4),t=new Float32Array(e),r=new Uint32Array(e),s=new Uint32Array(512),i=new Uint32Array(512);for(let l=0;l<256;++l){const e=l-127;e<-27?(s[l]=0,s[256|l]=32768,i[l]=24,i[256|l]=24):e<-14?(s[l]=1024>>-e-14,s[256|l]=1024>>-e-14|32768,i[l]=-e-1,i[256|l]=-e-1):e<=15?(s[l]=e+15<<10,s[256|l]=e+15<<10|32768,i[l]=13,i[256|l]=13):e<128?(s[l]=31744,s[256|l]=64512,i[l]=24,i[256|l]=24):(s[l]=31744,s[256|l]=64512,i[l]=13,i[256|l]=13)}const a=new Uint32Array(2048),n=new Uint32Array(64),o=new Uint32Array(64);for(let l=1;l<1024;++l){let e=l<<13,t=0;for(;0==(8388608&e);)e<<=1,t-=8388608;e&=-8388609,t+=947912704,a[l]=e|t}for(let l=1024;l<2048;++l)a[l]=939524096+(l-1024<<13);for(let l=1;l<31;++l)n[l]=l<<23;n[31]=1199570944,n[32]=2147483648;for(let l=33;l<63;++l)n[l]=2147483648+(l-32<<23);n[63]=3347054592;for(let l=1;l<64;++l)32!==l&&(o[l]=1024);return{floatView:t,uint32View:r,baseTable:s,shiftTable:i,mantissaTable:a,exponentTable:n,offsetTable:o}}function ve(e,t,r){return.2126*e+.7152*t+.0722*r}function Le(e,t,r){return Math.min(Math.max(e,t),r)}function ye(e,t,r=1e-4){for(let s=0;s<e.length;s++)if(Math.abs(e[s]-t[s])>r)return!1;return!0}function Se(e){return Number(e.replace("px",""))}function Me(e){if(!e.visible)return!1;let t=e.parent;for(;null!==t;){if(!t.visible)return!1;t=t.parent}return!0}function Te(e){if(e instanceof Uint16Array)return e;const t=new Uint16Array(e.length);return e.map(((e,r)=>t[r]=function(e){Math.abs(e)>65504&&console.warn("toHalfFloat(): Value out of range."),e=Math.max(-65504,Math.min(65504,e)),xe.floatView[0]=e;const t=xe.uint32View[0],r=t>>23&511;return xe.baseTable[r]+((8388607&t)>>xe.shiftTable[r])}(e))),t}function Ge(e,t,r=0,s=e.length){let i=r,a=r+s-1;for(;i<a;){const r=i+a>>1;e[r]<t?i=r+1:a=r}return i-r}const _e={width:1,height:1,data:new Float32Array(4)},Pe=class{constructor(e,t){this.device=e,this.resourcePool=t,this.totalSumValue=1}destory(){const{resourcePool:e}=this;e.destoryResourceByName(Pe.ENVMAP_RES_NAME),e.destoryResourceByName(Pe.ENVMAP_MARGINAL_WEIGHTS_RES_NAME),e.destoryResourceByName(Pe.ENVMAP_CONDITIONAL_WEIGHTS_RES_NAME)}load(e){e||(e=_e);const{device:t,resourcePool:r}=this;this.destory();const s=e.width,i=e.height,a=Te(e.data),n={size:{width:s,height:i},format:"rgba16float",usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING},o=t.createTexture(n);t.queue.writeTexture({texture:o},a,{bytesPerRow:2*s*4,rowsPerImage:i},{width:s,height:i,depthOrArrayLayers:1});const{marginalDataArray:l,conditionalDataArray:u,totalSumValue:c}=function(e){const{width:t,height:r,data:s}=e,i=new Float32Array(t*r),a=new Float32Array(t*r),n=new Float32Array(r),o=new Float32Array(r);let l=0,u=0;for(let h=0;h<r;h++){let e=0;for(let r=0;r<t;r++){const n=h*t+r,o=ve(s[4*n+0],s[4*n+1],s[4*n+2]);e+=o,l+=o,i[n]=o,a[n]=e}if(0!==e)for(let r=h*t,s=h*t+t;r<s;r++)i[r]/=e,a[r]/=e;u+=e,n[h]=e,o[h]=u}if(0!==u)for(let h=0,p=n.length;h<p;h++)n[h]/=u,o[h]/=u;const c=new Float32Array(r),d=new Float32Array(t*r);for(let h=0;h<r;h++){const e=Ge(o,(h+1)/r);c[h]=(e+.5)/r}for(let h=0;h<r;h++)for(let e=0;e<t;e++){const r=h*t+e,s=Ge(a,(e+1)/t,h*t,t);d[r]=(s+.5)/t}return{marginalDataArray:c,conditionalDataArray:d,totalSumValue:l}}(e);this.totalSumValue=c;const d={size:{width:i,height:1},format:"r32float",usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING},h=t.createTexture(d);t.queue.writeTexture({texture:h},l,{bytesPerRow:4*i,rowsPerImage:1},{width:i,height:1,depthOrArrayLayers:1});const p={size:{width:s,height:i},format:"r32float",usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING},f=t.createTexture(p);t.queue.writeTexture({texture:f},u,{bytesPerRow:4*s,rowsPerImage:i},{width:s,height:i,depthOrArrayLayers:1}),r.setResource(Pe.ENVMAP_RES_NAME,o,"Texture"),r.setResource(Pe.ENVMAP_MARGINAL_WEIGHTS_RES_NAME,h,"Texture"),r.setResource(Pe.ENVMAP_CONDITIONAL_WEIGHTS_RES_NAME,f,"Texture")}};let Be=Pe;function Re(e,t=!1){const r=new Map;let s=0,i=0,a=0,n=0;const o=[];o.push({vertexSplitIndex:0,indicesSplitIndex:0});for(const l of e){let e=l.geometry;if(null==r.get(e)){e.indices||Ie(e),e.uv||ze(e),t&&(e=we(e,l.localToWorldMat)),e.normal?g(e.normal.array,3,0,void 0,h,void 0):We(e),a+=e.position.count,n+=e.indices.count,o.push({vertexSplitIndex:3*a,indicesSplitIndex:n});const s=r.size;r.set(e,s),l.geometry=e}s+=e.position.count,i+=e.indices.count}return{vertexTotalCount:a,indicesTotalCount:n,geoInfoSplitIndex:o,renderVertexCount:s,renderIndicesCount:i,geometryIndexMap:r}}function we(e,t){const r=new C(new X(e.position.array.slice(),e.position.itemSize),e.normal&&new X(e.normal.array.slice(),e.normal.itemSize),e.uv&&new X(e.uv.array,e.uv.itemSize),e.indices&&new X(e.indices.array,e.indices.itemSize)),s=(new l).getNormalMatrix(t);return g(r.position.array,3,0,null,f,t),r.normal&&g(r.normal.array,3,0,null,m,s),r}function Ie(e){const t=e.position;if(!t)return void console.error("This model no position data");const r=new Uint32Array(t.count);for(let s=0;s<r.length;s++)r[s]=s;return e.indices=new X(r,1),e}function ze(e){const t=e.position,r=new Float32Array(2*t.count);for(let s=0;s<r.length;s++)r[s]=Math.random();return e.uv=new X(r,2),e}function We(e){const t=e.indices.array,r=e.position.array;e.normal=new X(new Float32Array(r.length),3);const s=e.normal.array,i=new B,a=new B,n=new B,o=new B,l=new B,u=new B,c=t.length;let d,h,p;for(let f=0;f<c;){t?(d=t[f++],h=t[f++],p=t[f++]):(d=f++,h=f++,p=f++),i.set(r[3*d],r[3*d+1],r[3*d+2]),a.set(r[3*h],r[3*h+1],r[3*h+2]),n.set(r[3*p],r[3*p+1],r[3*p+2]),o.sub(i,a),l.sub(a,n),u.cross(o,l);for(let e=0;e<3;e++)s[3*d+e]=s[3*d+e]+u[e],s[3*h+e]=s[3*h+e]+u[e],s[3*p+e]=s[3*p+e]+u[e]}for(let f=0;f<s.length;)u.set(s[f],s[f+1],s[f+2]),u.normalize(),s[f++]=u[0],s[f++]=u[1],s[f++]=u[2]}function Xe(e,t,r){const s=[],{renderVertexCount:i,renderIndicesCount:a}=r;for(const o of e){let e=o.geometry;const r=o.material;let i=t.get(r);s.push({geometry:e,materialIndex:i})}const n=function(e,t,r){const s=new X(new Float32Array(3*t),3),i=new X(new Float32Array(3*t),3),a=new X(new Float32Array(2*t),2),n=new X(new Uint32Array(r),1),o=new X(new Int32Array(2*t),2),l=new C(s,i,a,n);l.materialMeshIndex=o;let u=0,c=0,d=0;for(const{geometry:h,materialIndex:p}of e){const e=h.position.count;["position","normal","uv"].forEach((e=>{h[e]&&l[e].array.set(h[e].array,u*h[e].itemSize)}));const t=h.indices.array;for(let r=0;r<t.length;r++)n.array[c+r]=u+t[r];for(let r=0;r<2*e;)o.array[2*u+r++]=p,o.array[2*u+r++]=d;u+=e,c+=t.length,d++}return l}(s,i,a);return{geometry:n,vertexCount:i,IndicesCount:a,visible:!0}}Be.ENVMAP_RES_NAME="EnvMapTexture",Be.ENVMAP_MARGINAL_WEIGHTS_RES_NAME="EnvMapMarginalWeightsTexture",Be.ENVMAP_CONDITIONAL_WEIGHTS_RES_NAME="EnvMapConditionalWeightsTexture";var Ce=()=>"struct VertexOutput{@builtin(position)position : vec4<f32>,@location(0)uv : vec2<f32>};@vertex fn main(@builtin(vertex_index)VertexIndex : u32)->VertexOutput{var output : VertexOutput;output.uv=vec2<f32>(f32((VertexIndex<<1)&2),f32(VertexIndex&2));output.position=vec4<f32>(output.uv*2.0-1.0,0.0,1.0);return output;}";var Fe=()=>"@group(0)@binding(0)var inputTex : texture_2d<f32>;@group(0)@binding(1)var screenSampler : sampler;struct VertexOutput{@builtin(position)position : vec4<f32>,@location(0)uv : vec2<f32>};@fragment fn main(vo : VertexOutput)->@location(0)vec4<f32>{var uv=vo.uv;uv.y=1.-uv.y;return textureSample(inputTex,screenSampler,uv);}";async function Ae(e,t){const r=new Map;let s=0;t.forEach((e=>{Object.keys(e).forEach((t=>{var i;if(null==(i=e[t])?void 0:i.isTexture){const i=e[t].image;let a=r.get(i);if(void 0===a&&s<255){a=r.size;const n=e[t].flipY;i.flipY=n,r.set(i,a),s++}}}))}));let i,a=Array.from(r.keys());return 255==s&&console.warn("Material limit exceeded. Some material information will be lost"),0==a.length?i=function(e){return e.createTexture({size:{width:1,height:1,depthOrArrayLayers:2},format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT})}(e):(1==a.length&&(a=[a[0],a[0]]),i=await async function(e,t){const r=e.createSampler({addressModeU:"repeat",addressModeV:"repeat",magFilter:"linear",minFilter:"linear",mipmapFilter:"linear"}),s=await e.createRenderPipelineAsync({layout:"auto",vertex:{module:e.createShaderModule({code:Ce()}),entryPoint:"main"},fragment:{module:e.createShaderModule({code:Fe()}),entryPoint:"main",targets:[{format:"rgba8unorm"}]},primitive:{topology:"triangle-list"}}),i=e.createTexture({size:{width:2048,height:2048,depthOrArrayLayers:t.length},format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT}),a=e.createCommandEncoder(),n=[];for(let o=0;o<t.length;o++){const l=t[o],u=e.createTexture({size:{width:l.width,height:l.height},format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT});n.push(u),e.queue.copyExternalImageToTexture({source:l,flipY:!!l.flipY},{texture:u},{width:l.width,height:l.height});const c=u,d=e.createBindGroup({layout:s.getBindGroupLayout(0),entries:[{binding:0,resource:c.createView()},{binding:1,resource:r}]}),h=i.createView({dimension:"2d",baseArrayLayer:o,arrayLayerCount:1}),p=a.beginRenderPass({colorAttachments:[{view:h,clearValue:{r:0,g:0,b:0,a:1},loadOp:"clear",storeOp:"store"}]});p.setPipeline(s),p.setBindGroup(0,d),p.draw(6,1,0,0),p.end()}return e.queue.submit([a.finish()]),await e.queue.onSubmittedWorkDone(),n.forEach((e=>e.destroy())),i}(e,a)),{textureImages:a,textureImageMap:r,textureArrayRes:i}}function De(e,t){return(null==t?void 0:t.image)?e.get(t.image):-1}function Ne(e,t,r){const s=[];t.map((e=>{s.push(...e.color),s.push("Metalness"===e.workflow?0:1),s.push(Le(e.roughness,.001,1)),s.push(e.metalness),s.push(e.transmission),s.push(e.ior),s.push(e.sheen),s.push(e.sheenTint),s.push(e.clearcoat),s.push(e.clearcoatRoughness),s.push(...e.emissiveColor),s.push(e.opacity),s.push(e.specularTint),s.push(e.atDistance),s.push(...e.normalScale),s.push(...e.subsurfaceColor),s.push(e.subsurface),s.push(...e.extinction),s.push(Math.max(e.subsurfaceMFP,.01)),s.push(...e.specularColor),s.push(e.glossiness),s.push(0,0,0,0,0,0,0,0)}));const i=40*Float32Array.BYTES_PER_ELEMENT,a=i*t.length,n=e.createBuffer({mappedAtCreation:!0,size:a,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC}),o=new Float32Array(n.getMappedRange());return o.set(s,0),t.map(((e,t)=>{const s=i*t+32*Float32Array.BYTES_PER_ELEMENT,a=new Int32Array(o.buffer,s,8);a[0]=De(r,e.map),a[1]=De(r,e.normalMap),a[2]=De(r,e.roughnessMap),a[3]=De(r,e.metalnessMap),a[4]=De(r,e.emissiveMap),a[5]=De(r,e.specularMap),a[6]=De(r,e.glossinessMap),a[7]=0})),n.unmap(),n}async function Ve(e,t){const{textureImageMap:r,textureArrayRes:s}=await Ae(e,t);return{textureImageMap:r,materialBuffer:Ne(e,t,r),textureArrayRes:s}}function Ue(e){const{mapNum:t,perMatrixLength:r,perWrappingDataLength:s,bufferSize:i}=function(e){const t=ne.length;return{mapNum:t,perMatrixLength:12,perWrappingDataLength:4,bufferSize:e.size*t*16}}(e),a=new Float32Array(i),n=new l,o=t*r,u=t*s+o;return e.forEach(((e,t)=>{ne.forEach(((i,l)=>{const c=t[`${i}`];let d=n.toWebGPUFormat();c&&(d=c.uvTransMat.toWebGPUFormat());const h=u*e;for(let e=0;e<r;e++)a[h+l*r+e]=d[e];let p=0,f=0;c&&(p=c.wrapS,f=c.wrapT);const m=h+o+l*s;a[m+0]=p,a[m+1]=f,a[m+2]=0,a[m+3]=0}))})),{bufferSize:i,uvTransformBufferData:a}}function Ee(e,t,r){const{uvTransformBufferData:s}=Ue(t);e.queue.writeBuffer(r,0,s)}function ke(e,t){const{bufferSize:r,uvTransformBufferData:s}=Ue(t),i=e.createBuffer({mappedAtCreation:!0,size:r*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST});return new Float32Array(i.getMappedRange()).set(s,0),i.unmap(),i}function Ke(e,t){const r=256*Float32Array.BYTES_PER_ELEMENT,s=e.createBuffer({size:r,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});return He(e,s,t),s}function He(e,t,r){if(!r||!(null==r?void 0:r.length)){const r=new Float32Array(256);return void e.queue.writeBuffer(t,0,r)}const s=new Float32Array(256);let i=0;return r.forEach(((e,t)=>{if(t>=16)return;const r=function(e){return[...e.position,e.radius,...e.emission,e.area,...e.p1,e.type,...e.p2,Number(e.visible)]}(e);s.set(r,i),i+=16})),e.queue.writeBuffer(t,0,s),t}class Ze{constructor(e){this.device=e,this.device=e,this.data=new Float32Array(8),this.input={buffer:e.createBuffer({size:this.data.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),data:this.data.buffer,min:this.data.subarray(0,3),range:this.data.subarray(4,7),triangleCount:new Uint32Array(this.data.buffer,28,1)}}get buffer(){return this.input.buffer}set(e,t){const{device:r,input:s}=this;B.copyTo(s.min,e.min),B.copyTo(s.range,(new B).sub(e.max,e.min)),s.triangleCount[0]=t,r.queue.writeBuffer(s.buffer,0,s.data)}destroy(){const{input:e}=this;e.buffer.destroy()}}function Oe(e){var t=e-1;return t|=t>>1,t|=t>>2,t|=t>>4,t|=t>>8,(t|=t>>16)+1}function Ye(e,t,r){var s=[],i=[],a=Math.ceil(t/e.limits.maxComputeWorkgroupsPerDimension),n=e.createBuffer({size:256*a,usage:GPUBufferUsage.UNIFORM,mappedAtCreation:!0}),o=null;if(r){var l=r;r.buffer&&(l=r.buffer),l.byteLength,o=new Uint8Array(l)}for(var u=n.getMappedRange(),c=0;c<a;++c){s.push(256*c),c+1<a?i.push(e.limits.maxComputeWorkgroupsPerDimension):i.push(t%e.limits.maxComputeWorkgroupsPerDimension);var d=new Uint32Array(u,256*c,2);if(d[0]=e.limits.maxComputeWorkgroupsPerDimension*c,d[1]=t,o)new Uint8Array(u,256*c+8,248).set(o)}return n.unmap(),{nOffsets:a,gpuBuffer:n,dynamicOffsets:s=new Uint32Array(s),dispatchSizes:i}}class qe{constructor(e){this.device=e,this.bgLayout=this.device.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}}]}),this.radixSortBGLayout=this.device.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]}),this.mergeBGLayout=this.device.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:3,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]}),this.numWorkGroupsBGLayout=this.device.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}}]}),this.pushConstantsBGLayout=this.device.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{hasDynamicOffset:!0,type:"uniform"}}]}),this.sortPipeline=this.device.createComputePipeline({layout:this.device.createPipelineLayout({bindGroupLayouts:[this.bgLayout,this.radixSortBGLayout,this.pushConstantsBGLayout]}),compute:{module:this.device.createShaderModule({code:"struct PushConstants {\n\n\twork_group_offset : u32,\n  \n  }\n  \n  \n  \n  struct BufferInfo {\n  \n\tsize : u32,\n  \n  }\n  \n  \n  \n  alias RTArr = array<u32>;\n  \n  \n  \n  alias RTArr_1 = array<u32>;\n  \n  \n  \n  struct Keys {\n  \n\tkeys : RTArr_1,\n  \n  }\n  \n  \n  \n  struct Values {\n  \n\tvalues : RTArr_1,\n  \n  }\n  \n  \n  \n  @group(2) @binding(0) var<uniform> x_11 : PushConstants;\n  \n  \n  \n  var<private> gl_GlobalInvocationID : vec3<u32>;\n  \n  \n  \n  @group(0) @binding(0) var<uniform> x_30 : BufferInfo;\n  \n  \n  \n  var<workgroup> key_buf : array<u32, 64u>;\n  \n  \n  \n  var<private> gl_LocalInvocationID : vec3<u32>;\n  \n  \n  \n  @group(1) @binding(0) var<storage, read_write> x_46 : Keys;\n  \n  \n  \n  var<workgroup> val_buf : array<u32, 64u>;\n  \n  \n  \n  @group(1) @binding(1) var<storage, read_write> x_58 : Values;\n  \n  \n  \n  var<workgroup> scratch : array<u32, 64u>;\n  \n  \n  \n  var<workgroup> total_false : u32;\n  \n  \n  \n  var<workgroup> sorted_key_buf : array<u32, 64u>;\n  \n  \n  \n  var<workgroup> sorted_val_buf : array<u32, 64u>;\n  \n  \n  \n  fn main_1() {\n  \n\tvar item_idx : u32;\n  \n\tvar i : u32;\n  \n\tvar mask : u32;\n  \n\tvar offs : u32;\n  \n\tvar d : i32;\n  \n\tvar a : u32;\n  \n\tvar b : u32;\n  \n\tvar d_1 : i32;\n  \n\tvar a_1 : u32;\n  \n\tvar b_1 : u32;\n  \n\tvar tmp : u32;\n  \n\tvar f : u32;\n  \n\tvar t : u32;\n  \n\tlet x_16 : u32 = x_11.work_group_offset;\n  \n\tlet x_25 : u32 = gl_GlobalInvocationID.x;\n  \n\titem_idx = ((x_16 * 64u) + x_25);\n  \n\tlet x_27 : u32 = item_idx;\n  \n\tlet x_32 : u32 = x_30.size;\n  \n\tif ((x_27 < x_32)) {\n  \n\t  let x_42 : u32 = gl_LocalInvocationID.x;\n  \n\t  let x_47 : u32 = item_idx;\n  \n\t  let x_49 : u32 = x_46.keys[x_47];\n  \n\t  key_buf[x_42] = x_49;\n  \n\t  let x_54 : u32 = gl_LocalInvocationID.x;\n  \n\t  let x_59 : u32 = item_idx;\n  \n\t  let x_61 : u32 = x_58.values[x_59];\n  \n\t  val_buf[x_54] = x_61;\n  \n\t} else {\n  \n\t  let x_65 : u32 = gl_LocalInvocationID.x;\n  \n\t  key_buf[x_65] = 4294967295u;\n  \n\t  let x_69 : u32 = gl_LocalInvocationID.x;\n  \n\t  val_buf[x_69] = 4294967295u;\n  \n\t}\n  \n\ti = 0u;\n  \n\tloop {\n  \n\t  let x_77 : u32 = i;\n  \n\t  if ((x_77 < 32u)) {\n  \n\t  } else {\n  \n\t\tbreak;\n  \n\t  }\n  \n\t  workgroupBarrier();\n  \n\t  let x_84 : u32 = i;\n  \n\t  mask = bitcast<u32>((1i << x_84));\n  \n\t  let x_89 : u32 = gl_LocalInvocationID.x;\n  \n\t  let x_91 : u32 = gl_LocalInvocationID.x;\n  \n\t  let x_93 : u32 = key_buf[x_91];\n  \n\t  let x_94 : u32 = mask;\n  \n\t  scratch[x_89] = bitcast<u32>(select(1i, 0i, ((x_93 & x_94) != 0u)));\n  \n\t  offs = 1u;\n  \n\t  d = 32i;\n  \n\t  loop {\n  \n\t\tlet x_110 : i32 = d;\n  \n\t\tif ((x_110 > 0i)) {\n  \n\t\t} else {\n  \n\t\t  break;\n  \n\t\t}\n  \n\t\tworkgroupBarrier();\n  \n\t\tlet x_113 : u32 = gl_LocalInvocationID.x;\n  \n\t\tlet x_114 : i32 = d;\n  \n\t\tif ((x_113 < bitcast<u32>(x_114))) {\n  \n\t\t  let x_120 : u32 = offs;\n  \n\t\t  let x_122 : u32 = gl_LocalInvocationID.x;\n  \n\t\t  a = ((x_120 * ((2u * x_122) + 1u)) - 1u);\n  \n\t\t  let x_128 : u32 = offs;\n  \n\t\t  let x_130 : u32 = gl_LocalInvocationID.x;\n  \n\t\t  b = ((x_128 * ((2u * x_130) + 2u)) - 1u);\n  \n\t\t  let x_135 : u32 = b;\n  \n\t\t  let x_136 : u32 = a;\n  \n\t\t  let x_138 : u32 = scratch[x_136];\n  \n\t\t  let x_140 : u32 = scratch[x_135];\n  \n\t\t  scratch[x_135] = (x_140 + x_138);\n  \n\t\t}\n  \n\t\tlet x_143 : u32 = offs;\n  \n\t\toffs = (x_143 << bitcast<u32>(1i));\n  \n  \n  \n\t\tcontinuing {\n  \n\t\t  let x_145 : i32 = d;\n  \n\t\t  d = (x_145 >> bitcast<u32>(1i));\n  \n\t\t}\n  \n\t  }\n  \n\t  let x_148 : u32 = gl_LocalInvocationID.x;\n  \n\t  if ((x_148 == 0u)) {\n  \n\t\tlet x_155 : u32 = scratch[63i];\n  \n\t\ttotal_false = x_155;\n  \n\t\tscratch[63i] = 0u;\n  \n\t  }\n  \n\t  d_1 = 1i;\n  \n\t  loop {\n  \n\t\tlet x_163 : i32 = d_1;\n  \n\t\tif ((x_163 < 64i)) {\n  \n\t\t} else {\n  \n\t\t  break;\n  \n\t\t}\n  \n\t\tlet x_166 : u32 = offs;\n  \n\t\toffs = (x_166 >> bitcast<u32>(1i));\n  \n\t\tworkgroupBarrier();\n  \n\t\tlet x_169 : u32 = gl_LocalInvocationID.x;\n  \n\t\tlet x_170 : i32 = d_1;\n  \n\t\tif ((x_169 < bitcast<u32>(x_170))) {\n  \n\t\t  let x_176 : u32 = offs;\n  \n\t\t  let x_178 : u32 = gl_LocalInvocationID.x;\n  \n\t\t  a_1 = ((x_176 * ((2u * x_178) + 1u)) - 1u);\n  \n\t\t  let x_184 : u32 = offs;\n  \n\t\t  let x_186 : u32 = gl_LocalInvocationID.x;\n  \n\t\t  b_1 = ((x_184 * ((2u * x_186) + 2u)) - 1u);\n  \n\t\t  let x_192 : u32 = a_1;\n  \n\t\t  let x_194 : u32 = scratch[x_192];\n  \n\t\t  tmp = x_194;\n  \n\t\t  let x_195 : u32 = a_1;\n  \n\t\t  let x_196 : u32 = b_1;\n  \n\t\t  let x_198 : u32 = scratch[x_196];\n  \n\t\t  scratch[x_195] = x_198;\n  \n\t\t  let x_200 : u32 = b_1;\n  \n\t\t  let x_201 : u32 = tmp;\n  \n\t\t  let x_203 : u32 = scratch[x_200];\n  \n\t\t  scratch[x_200] = (x_203 + x_201);\n  \n\t\t}\n  \n  \n  \n\t\tcontinuing {\n  \n\t\t  let x_206 : i32 = d_1;\n  \n\t\t  d_1 = (x_206 << bitcast<u32>(1i));\n  \n\t\t}\n  \n\t  }\n  \n\t  workgroupBarrier();\n  \n\t  let x_210 : u32 = gl_LocalInvocationID.x;\n  \n\t  let x_212 : u32 = scratch[x_210];\n  \n\t  f = x_212;\n  \n\t  let x_215 : u32 = gl_LocalInvocationID.x;\n  \n\t  let x_216 : u32 = f;\n  \n\t  let x_218 : u32 = total_false;\n  \n\t  t = ((x_215 - x_216) + x_218);\n  \n\t  let x_221 : u32 = gl_LocalInvocationID.x;\n  \n\t  let x_223 : u32 = key_buf[x_221];\n  \n\t  let x_224 : u32 = mask;\n  \n\t  if (((x_223 & x_224) != 0u)) {\n  \n\t\tlet x_230 : u32 = t;\n  \n\t\tlet x_232 : u32 = gl_LocalInvocationID.x;\n  \n\t\tlet x_234 : u32 = key_buf[x_232];\n  \n\t\tsorted_key_buf[x_230] = x_234;\n  \n\t\tlet x_237 : u32 = t;\n  \n\t\tlet x_239 : u32 = gl_LocalInvocationID.x;\n  \n\t\tlet x_241 : u32 = val_buf[x_239];\n  \n\t\tsorted_val_buf[x_237] = x_241;\n  \n\t  } else {\n  \n\t\tlet x_244 : u32 = f;\n  \n\t\tlet x_246 : u32 = gl_LocalInvocationID.x;\n  \n\t\tlet x_248 : u32 = key_buf[x_246];\n  \n\t\tsorted_key_buf[x_244] = x_248;\n  \n\t\tlet x_250 : u32 = f;\n  \n\t\tlet x_252 : u32 = gl_LocalInvocationID.x;\n  \n\t\tlet x_254 : u32 = val_buf[x_252];\n  \n\t\tsorted_val_buf[x_250] = x_254;\n  \n\t  }\n  \n\t  workgroupBarrier();\n  \n\t  let x_257 : u32 = gl_LocalInvocationID.x;\n  \n\t  let x_259 : u32 = gl_LocalInvocationID.x;\n  \n\t  let x_261 : u32 = sorted_key_buf[x_259];\n  \n\t  key_buf[x_257] = x_261;\n  \n\t  let x_264 : u32 = gl_LocalInvocationID.x;\n  \n\t  let x_266 : u32 = gl_LocalInvocationID.x;\n  \n\t  let x_268 : u32 = sorted_val_buf[x_266];\n  \n\t  val_buf[x_264] = x_268;\n  \n  \n  \n\t  continuing {\n  \n\t\tlet x_270 : u32 = i;\n  \n\t\ti = (x_270 + bitcast<u32>(1i));\n  \n\t  }\n  \n\t}\n  \n\tworkgroupBarrier();\n  \n\tlet x_272 : u32 = item_idx;\n  \n\tlet x_274 : u32 = gl_LocalInvocationID.x;\n  \n\tlet x_276 : u32 = key_buf[x_274];\n  \n\tx_46.keys[x_272] = x_276;\n  \n\tlet x_278 : u32 = item_idx;\n  \n\tlet x_280 : u32 = gl_LocalInvocationID.x;\n  \n\tlet x_282 : u32 = val_buf[x_280];\n  \n\tx_58.values[x_278] = x_282;\n  \n\treturn;\n  \n  }\n  \n  \n  \n  @compute @workgroup_size(64i, 1i, 1i)\n  \n  fn main(@builtin(global_invocation_id) gl_GlobalInvocationID_param : vec3<u32>, @builtin(local_invocation_id) gl_LocalInvocationID_param : vec3<u32>) {\n  \n\tgl_GlobalInvocationID = gl_GlobalInvocationID_param;\n  \n\tgl_LocalInvocationID = gl_LocalInvocationID_param;\n  \n\tmain_1();\n  \n  }\n  \n  "}),entryPoint:"main"}}),this.mergePipeline=this.device.createComputePipeline({layout:this.device.createPipelineLayout({bindGroupLayouts:[this.bgLayout,this.mergeBGLayout,this.numWorkGroupsBGLayout,this.pushConstantsBGLayout]}),compute:{module:this.device.createShaderModule({code:"alias RTArr = array<u32>;\n  \n  \n  \n  alias RTArr_1 = array<u32>;\n  \n  \n  \n  struct InputKeys {\n  \n\tinput_keys : RTArr_1,\n  \n  }\n  \n  \n  \n  struct BufferInfo {\n  \n\tsize : u32,\n  \n  }\n  \n  \n  \n  struct NumWorkGroups {\n  \n\twork_groups_x : u32,\n  \n  }\n  \n  \n  \n  struct PushConstants {\n  \n\twork_group_offset : u32,\n  \n  }\n  \n  \n  \n  alias RTArr_2 = array<u32>;\n  \n  \n  \n  struct OutputKeys {\n  \n\toutput_keys : RTArr_1,\n  \n  }\n  \n  \n  \n  alias RTArr_3 = array<u32>;\n  \n  \n  \n  struct OutputValues {\n  \n\toutput_values : RTArr_1,\n  \n  }\n  \n  \n  \n  struct InputValues {\n  \n\tinput_values : RTArr_1,\n  \n  }\n  \n  \n  \n  @group(1) @binding(0) var<storage, read_write> x_75 : InputKeys;\n  \n  \n  \n  @group(0) @binding(0) var<uniform> x_132 : BufferInfo;\n  \n  \n  \n  @group(2) @binding(0) var<uniform> x_149 : NumWorkGroups;\n  \n  \n  \n  @group(3) @binding(0) var<uniform> x_159 : PushConstants;\n  \n  \n  \n  var<private> gl_WorkGroupID : vec3<u32>;\n  \n  \n  \n  var<private> gl_LocalInvocationID : vec3<u32>;\n  \n  \n  \n  @group(1) @binding(2) var<storage, read_write> x_237 : OutputKeys;\n  \n  \n  \n  @group(1) @binding(3) var<storage, read_write> x_246 : OutputValues;\n  \n  \n  \n  @group(1) @binding(1) var<storage, read_write> x_251 : InputValues;\n  \n  \n  \n  fn next_pow2_u1_(x : ptr<function, u32>) -> u32 {\n  \n\tlet x_23 : u32 = *(x);\n  \n\t*(x) = (x_23 - 1u);\n  \n\tlet x_26 : u32 = *(x);\n  \n\tlet x_30 : u32 = *(x);\n  \n\t*(x) = (x_30 | (x_26 >> bitcast<u32>(1i)));\n  \n\tlet x_32 : u32 = *(x);\n  \n\tlet x_35 : u32 = *(x);\n  \n\t*(x) = (x_35 | (x_32 >> bitcast<u32>(2i)));\n  \n\tlet x_37 : u32 = *(x);\n  \n\tlet x_40 : u32 = *(x);\n  \n\t*(x) = (x_40 | (x_37 >> bitcast<u32>(4i)));\n  \n\tlet x_42 : u32 = *(x);\n  \n\tlet x_45 : u32 = *(x);\n  \n\t*(x) = (x_45 | (x_42 >> bitcast<u32>(8i)));\n  \n\tlet x_47 : u32 = *(x);\n  \n\tlet x_50 : u32 = *(x);\n  \n\t*(x) = (x_50 | (x_47 >> bitcast<u32>(16i)));\n  \n\tlet x_52 : u32 = *(x);\n  \n\treturn (x_52 + 1u);\n  \n  }\n  \n  \n  \n  fn upper_bound_u1_u1_u1_(start : ptr<function, u32>, count : ptr<function, u32>, element : ptr<function, u32>) -> u32 {\n  \n\tvar i : u32;\n  \n\tloop {\n  \n\t  let x_61 : u32 = *(count);\n  \n\t  if ((x_61 > 0u)) {\n  \n\t  } else {\n  \n\t\tbreak;\n  \n\t  }\n  \n\t  let x_66 : u32 = *(start);\n  \n\t  let x_67 : u32 = *(count);\n  \n\t  i = (x_66 + (x_67 / 2u));\n  \n\t  let x_71 : u32 = *(element);\n  \n\t  let x_77 : u32 = i;\n  \n\t  let x_80 : u32 = x_75.input_keys[x_77];\n  \n\t  if ((x_71 >= x_80)) {\n  \n\t\tlet x_84 : u32 = i;\n  \n\t\t*(start) = (x_84 + 1u);\n  \n\t\tlet x_86 : u32 = *(count);\n  \n\t\tlet x_89 : u32 = *(count);\n  \n\t\t*(count) = (x_89 - ((x_86 / 2u) + 1u));\n  \n\t  } else {\n  \n\t\tlet x_92 : u32 = *(count);\n  \n\t\t*(count) = (x_92 / 2u);\n  \n\t  }\n  \n\t}\n  \n\tlet x_94 : u32 = *(start);\n  \n\treturn x_94;\n  \n  }\n  \n  \n  \n  fn lower_bound_u1_u1_u1_(start_1 : ptr<function, u32>, count_1 : ptr<function, u32>, element_1 : ptr<function, u32>) -> u32 {\n  \n\tvar i_1 : u32;\n  \n\tloop {\n  \n\t  let x_102 : u32 = *(count_1);\n  \n\t  if ((x_102 > 0u)) {\n  \n\t  } else {\n  \n\t\tbreak;\n  \n\t  }\n  \n\t  let x_105 : u32 = *(start_1);\n  \n\t  let x_106 : u32 = *(count_1);\n  \n\t  i_1 = (x_105 + (x_106 / 2u));\n  \n\t  let x_109 : u32 = i_1;\n  \n\t  let x_111 : u32 = x_75.input_keys[x_109];\n  \n\t  let x_112 : u32 = *(element_1);\n  \n\t  if ((x_111 < x_112)) {\n  \n\t\tlet x_116 : u32 = i_1;\n  \n\t\t*(start_1) = (x_116 + 1u);\n  \n\t\tlet x_118 : u32 = *(count_1);\n  \n\t\tlet x_121 : u32 = *(count_1);\n  \n\t\t*(count_1) = (x_121 - ((x_118 / 2u) + 1u));\n  \n\t  } else {\n  \n\t\tlet x_124 : u32 = *(count_1);\n  \n\t\t*(count_1) = (x_124 / 2u);\n  \n\t  }\n  \n\t}\n  \n\tlet x_126 : u32 = *(start_1);\n  \n\treturn x_126;\n  \n  }\n  \n  \n  \n  fn main_1() {\n  \n\tvar aligned_size : u32;\n  \n\tvar param : u32;\n  \n\tvar merge_output_size : u32;\n  \n\tvar merge_chunk_size : u32;\n  \n\tvar offs : u32;\n  \n\tvar i_2 : u32;\n  \n\tvar a_in : u32;\n  \n\tvar b_in : u32;\n  \n\tvar base_idx : u32;\n  \n\tvar a_loc : u32;\n  \n\tvar param_1 : u32;\n  \n\tvar param_2 : u32;\n  \n\tvar param_3 : u32;\n  \n\tvar b_loc : u32;\n  \n\tvar param_4 : u32;\n  \n\tvar param_5 : u32;\n  \n\tvar param_6 : u32;\n  \n\tlet x_134 : u32 = x_132.size;\n  \n\tparam = u32(ceil((f32(x_134) / 64.0f)));\n  \n\tlet x_142 : u32 = next_pow2_u1_(&(param));\n  \n\taligned_size = (x_142 * 64u);\n  \n\tlet x_146 : u32 = aligned_size;\n  \n\tlet x_151 : u32 = x_149.work_groups_x;\n  \n\tmerge_output_size = (x_146 / x_151);\n  \n\tlet x_154 : u32 = merge_output_size;\n  \n\tmerge_chunk_size = (x_154 / 2u);\n  \n\tlet x_161 : u32 = x_159.work_group_offset;\n  \n\tlet x_167 : u32 = gl_WorkGroupID.x;\n  \n\tlet x_169 : u32 = merge_output_size;\n  \n\toffs = ((x_161 + x_167) * x_169);\n  \n\ti_2 = 0u;\n  \n\tloop {\n  \n\t  let x_177 : u32 = i_2;\n  \n\t  let x_178 : u32 = merge_chunk_size;\n  \n\t  if ((x_177 < (x_178 / 64u))) {\n  \n\t  } else {\n  \n\t\tbreak;\n  \n\t  }\n  \n\t  let x_182 : u32 = offs;\n  \n\t  let x_183 : u32 = i_2;\n  \n\t  let x_188 : u32 = gl_LocalInvocationID.x;\n  \n\t  a_in = ((x_182 + (x_183 * 64u)) + x_188);\n  \n\t  let x_191 : u32 = offs;\n  \n\t  let x_192 : u32 = merge_chunk_size;\n  \n\t  let x_194 : u32 = i_2;\n  \n\t  let x_198 : u32 = gl_LocalInvocationID.x;\n  \n\t  b_in = (((x_191 + x_192) + (x_194 * 64u)) + x_198);\n  \n\t  let x_202 : u32 = gl_LocalInvocationID.x;\n  \n\t  let x_203 : u32 = i_2;\n  \n\t  base_idx = (x_202 + (x_203 * 64u));\n  \n\t  let x_207 : u32 = base_idx;\n  \n\t  let x_208 : u32 = offs;\n  \n\t  let x_209 : u32 = merge_chunk_size;\n  \n\t  let x_211 : u32 = a_in;\n  \n\t  param_1 = (x_208 + x_209);\n  \n\t  let x_214 : u32 = merge_chunk_size;\n  \n\t  param_2 = x_214;\n  \n\t  let x_217 : u32 = x_75.input_keys[x_211];\n  \n\t  param_3 = x_217;\n  \n\t  let x_218 : u32 = upper_bound_u1_u1_u1_(&(param_1), &(param_2), &(param_3));\n  \n\t  let x_220 : u32 = merge_chunk_size;\n  \n\t  a_loc = ((x_207 + x_218) - x_220);\n  \n\t  let x_223 : u32 = base_idx;\n  \n\t  let x_224 : u32 = b_in;\n  \n\t  let x_226 : u32 = offs;\n  \n\t  param_4 = x_226;\n  \n\t  let x_228 : u32 = merge_chunk_size;\n  \n\t  param_5 = x_228;\n  \n\t  let x_231 : u32 = x_75.input_keys[x_224];\n  \n\t  param_6 = x_231;\n  \n\t  let x_232 : u32 = lower_bound_u1_u1_u1_(&(param_4), &(param_5), &(param_6));\n  \n\t  b_loc = (x_223 + x_232);\n  \n\t  let x_238 : u32 = a_loc;\n  \n\t  let x_239 : u32 = a_in;\n  \n\t  let x_241 : u32 = x_75.input_keys[x_239];\n  \n\t  x_237.output_keys[x_238] = x_241;\n  \n\t  let x_247 : u32 = a_loc;\n  \n\t  let x_252 : u32 = a_in;\n  \n\t  let x_254 : u32 = x_251.input_values[x_252];\n  \n\t  x_246.output_values[x_247] = x_254;\n  \n\t  let x_256 : u32 = b_loc;\n  \n\t  let x_257 : u32 = b_in;\n  \n\t  let x_259 : u32 = x_75.input_keys[x_257];\n  \n\t  x_237.output_keys[x_256] = x_259;\n  \n\t  let x_261 : u32 = b_loc;\n  \n\t  let x_262 : u32 = b_in;\n  \n\t  let x_264 : u32 = x_251.input_values[x_262];\n  \n\t  x_246.output_values[x_261] = x_264;\n  \n  \n  \n\t  continuing {\n  \n\t\tlet x_266 : u32 = i_2;\n  \n\t\ti_2 = (x_266 + bitcast<u32>(1i));\n  \n\t  }\n  \n\t}\n  \n\treturn;\n  \n  }\n  \n  \n  \n  @compute @workgroup_size(64i, 1i, 1i)\n  \n  fn main(@builtin(workgroup_id) gl_WorkGroupID_param : vec3<u32>, @builtin(local_invocation_id) gl_LocalInvocationID_param : vec3<u32>) {\n  \n\tgl_WorkGroupID = gl_WorkGroupID_param;\n  \n\tgl_LocalInvocationID = gl_LocalInvocationID_param;\n  \n\tmain_1();\n  \n  }\n  \n  "}),entryPoint:"main"}})}getAlignedSize(e){return 64*Oe(Math.ceil(e/64))}async sort(e,t,r){var s=Oe(Math.ceil(r/64)),i=64*s,a=Math.log2(s),n={keys:e,values:t},o={keys:this.device.createBuffer({size:4*i,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST}),values:this.device.createBuffer({size:4*i,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST})},l=this.device.createBuffer({size:4,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_SRC,mappedAtCreation:!0});new Uint32Array(l.getMappedRange()).set([r]),l.unmap();for(var u=this.device.createBuffer({size:256*Math.max(a,1),usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_SRC,mappedAtCreation:!0}),c=new Uint32Array(u.getMappedRange()),d=0;d<a;++d)c[64*d]=s/(2<<d);u.unmap();var h=this.device.createBindGroup({layout:this.bgLayout,entries:[{binding:0,resource:{buffer:l}}]}),p=this.device.createBindGroup({layout:this.radixSortBGLayout,entries:[{binding:0,resource:{buffer:n.keys}},{binding:1,resource:{buffer:n.values}}]}),f=[this.device.createBindGroup({layout:this.mergeBGLayout,entries:[{binding:0,resource:{buffer:n.keys}},{binding:1,resource:{buffer:n.values}},{binding:2,resource:{buffer:o.keys}},{binding:3,resource:{buffer:o.values}}]}),this.device.createBindGroup({layout:this.mergeBGLayout,entries:[{binding:0,resource:{buffer:o.keys}},{binding:1,resource:{buffer:o.values}},{binding:2,resource:{buffer:n.keys}},{binding:3,resource:{buffer:n.values}}]})],m=(L=this.device.createCommandEncoder()).beginComputePass(),g=Ye(this.device,s),x=this.device.createBindGroup({layout:this.pushConstantsBGLayout,entries:[{binding:0,resource:{buffer:g.gpuBuffer,size:4}}]});m.setPipeline(this.sortPipeline),m.setBindGroup(0,h),m.setBindGroup(1,p);for(d=0;d<g.nOffsets;++d)m.setBindGroup(2,x,g.dynamicOffsets,d,1),m.dispatchWorkgroups(g.dispatchSizes[d],1,1);m.end(),(m=L.beginComputePass()).setPipeline(this.mergePipeline),m.setBindGroup(0,h);for(d=0;d<a;++d){var b=this.device.createBindGroup({layout:this.numWorkGroupsBGLayout,entries:[{binding:0,resource:{buffer:u,size:4,offset:256*d}}]});g=Ye(this.device,s/(2<<d)),x=this.device.createBindGroup({layout:this.pushConstantsBGLayout,entries:[{binding:0,resource:{buffer:g.gpuBuffer,size:4}}]});m.setBindGroup(1,f[d%2]),m.setBindGroup(2,b);for(var v=0;v<g.nOffsets;++v)m.setBindGroup(3,x,g.dynamicOffsets,v,1),m.dispatchWorkgroups(g.dispatchSizes[v],1,1)}m.end(),this.device.queue.submit([L.finish()]);var L=this.device.createCommandEncoder();a%2==0||(L.copyBufferToBuffer(o.values,0,n.values,0,4*r),L.copyBufferToBuffer(o.keys,0,n.keys,0,4*r)),this.device.queue.submit([L.finish()]),await this.device.queue.onSubmittedWorkDone(),o.keys.destroy(),o.values.destroy(),l.destroy(),u.destroy()}}var Je=()=>"struct SceneAABB{min : vec3<f32>,range : vec3<f32>,triangleCount : u32}@group(0)@binding(0)var<storage,read>position : array<array<f32,3>>;@group(0)@binding(1)var<storage,read>indices : array<array<u32,3>>;@group(0)@binding(2)var<uniform>sceneAABB : SceneAABB;@group(0)@binding(3)var<storage,read_write>mortonBuffer : array<u32>;@group(0)@binding(4)var<storage,read_write>idsBuffer : array<u32>;fn LGL_BS(vIn : u32)->u32{var v=vIn;v=(v*0x00010001u)&0xFF0000FFu;v=(v*0x00000101u)&0x0F00F00Fu;v=(v*0x00000011u)&0xC30C30C3u;v=(v*0x00000005u)&0x49249249u;return v;}fn LGL_BT(xIn : f32,yIn : f32,zIn : f32)->u32{let x=clamp(xIn*1024.,0.,1023.);let y=clamp(yIn*1024.,0.,1023.);let z=clamp(zIn*1024.,0.,1023.);let xx=LGL_BS(u32(x));let yy=LGL_BS(u32(y));let zz=LGL_BS(u32(z));return xx*4+yy*2+zz;}fn LGL_Ad(triIndex : u32)->vec3<u32>{return vec3<u32>(indices[triIndex][0],indices[triIndex][1],indices[triIndex][2]);}fn LGL_Ae(indice : u32)->vec3<f32>{return vec3<f32>(position[indice][0],position[indice][1],position[indice][2]);}@compute @workgroup_size(128,1,1)fn main(@builtin(global_invocation_id)GID : vec3<u32>){if(GID.x>=sceneAABB.triangleCount){return;}let triID=GID.x;let triIndices=LGL_Ad(triID);let pos=(1./3.)*(LGL_Ae(triIndices.x)+LGL_Ae(triIndices.y)+LGL_Ae(triIndices.z));var x=(pos.x-sceneAABB.min.x)/sceneAABB.range.x;var y=(pos.y-sceneAABB.min.y)/sceneAABB.range.y;var z=(pos.z-sceneAABB.min.z)/sceneAABB.range.z;x=clamp(x,0.,1.);y=clamp(y,0.,1.);z=clamp(z,0.,1.);mortonBuffer[triID]=LGL_BT(x,y,z);idsBuffer[triID]=triID;}";class Qe{constructor(e){this.device=e}async compute(e,t,r,s,i,a){const{device:n}=this,o=n.createCommandEncoder(),l=await n.createComputePipelineAsync({layout:"auto",compute:{module:n.createShaderModule({code:Je()}),entryPoint:"main"}}),u=n.createBindGroup({layout:l.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:t}},{binding:1,resource:{buffer:r}},{binding:2,resource:{buffer:s}},{binding:3,resource:{buffer:i}},{binding:4,resource:{buffer:a}}]}),c=o.beginComputePass();c.setPipeline(l),c.setBindGroup(0,u),c.dispatchWorkgroups(Math.ceil(e/128)),c.end(),n.queue.submit([o.finish()]),await n.queue.onSubmittedWorkDone()}}var je=e=>`struct BVHNode{childA: u32,childB: u32,parent: u32,triIndicesID: u32,aabbMin : vec3<f32>,materialID: u32,aabbMax : vec3<f32>,visited: atomic<u32>,}@group(0)@binding(0)var<storage,read>idsBuffer : array<u32>;@group(0)@binding(1)var<storage,read>position : array<array<f32,3>>;@group(0)@binding(2)var<storage,read>indices : array<array<u32,3>>;@group(0)@binding(3)var<storage,read>materialMeshIndexBuffer : array<array<u32,2>>;@group(0)@binding(4)var<storage,read_write>bvhNodes : array<BVHNode>;fn LGL_Ad(triIndex : u32)->vec3<u32>{return vec3<u32>(indices[triIndex][0],indices[triIndex][1],indices[triIndex][2]);}fn LGL_Ae(indice : u32)->vec3<f32>{return vec3<f32>(position[indice][0],position[indice][1],position[indice][2]);}fn LGL_BO(indice : u32)->u32{return materialMeshIndexBuffer[indice][0];}fn LGL_BP(indice : u32)->u32{return materialMeshIndexBuffer[indice][1];}@compute @workgroup_size(128,1,1)fn main(@builtin(global_invocation_id)GID : vec3<u32>){if(GID.x>=${e}){return;}let leafID=${e-1}+GID.x;bvhNodes[leafID].triIndicesID=idsBuffer[GID.x];let triIndices=LGL_Ad(idsBuffer[GID.x]);bvhNodes[leafID].materialID=LGL_BO(triIndices.x);bvhNodes[leafID].childA=LGL_BP(triIndices.x);let posU=LGL_Ae(triIndices.x);let posV=LGL_Ae(triIndices.y);let posW=LGL_Ae(triIndices.z);bvhNodes[leafID].aabbMin=min(posU,min(posV,posW));bvhNodes[leafID].aabbMax=max(posU,max(posV,posW));let internalID=GID.x;if(internalID>=${e-1}){return;}bvhNodes[internalID].parent=0xFFFFFFFF;bvhNodes[internalID].triIndicesID=0xFFFFFFFF;}`;class $e{constructor(e){this.device=e}async compute(e,t,r,s,i,a){const{device:n}=this,o=n.createCommandEncoder(),l=await n.createComputePipelineAsync({layout:"auto",compute:{module:n.createShaderModule({code:je(e)}),entryPoint:"main"}}),u=n.createBindGroup({layout:l.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:t}},{binding:1,resource:{buffer:r}},{binding:2,resource:{buffer:s}},{binding:3,resource:{buffer:i}},{binding:4,resource:{buffer:a}}]}),c=o.beginComputePass();c.setPipeline(l),c.setBindGroup(0,u),c.dispatchWorkgroups(Math.ceil(e/128)),c.end(),n.queue.submit([o.finish()]),await n.queue.onSubmittedWorkDone()}}var et=e=>`struct BVHNode{childA: u32,childB: u32,parent: u32,triIndicesID: u32,aabbMin : vec3<f32>,materialID: u32,aabbMax : vec3<f32>,visited: atomic<u32>,}@group(0)@binding(0)var<storage,read>mortonBuffer : array<u32>;@group(0)@binding(1)var<storage,read_write>bvhNodes : array<BVHNode>;fn delta(a : i32,b : i32,n : u32,ka : u32)->i32{if(b<0||b>i32(n-1)){return-1;}let kb=mortonBuffer[b];if(ka==kb){return i32(32+countLeadingZeros(u32(a)^ u32(b)));}return i32(countLeadingZeros(ka ^ kb));}fn LGL_BQ(n : u32,i : i32)->vec2<i32>{let ki=mortonBuffer[i];let deltaL=delta(i,i-1,n,ki);let deltaR=delta(i,i+1,n,ki);var d : i32;var deltaMin : i32;if(deltaR<deltaL){d=-1;deltaMin=deltaR;}else{d=1;deltaMin=deltaL;}var lMax : i32=2;while(delta(i,i+lMax*d,n,ki)>deltaMin){lMax<<=1;}var l : i32=0;for(var t : i32=lMax>>1;t>0;t>>=1){if(delta(i,i+(l+t)*d,n,ki)>deltaMin){l+=t;}}let j=i+l*d;return select(vec2<i32>(j,i),vec2<i32>(i,j),i<j);}fn LGL_BR(first : i32,last : i32,n : u32)->i32{let firstCode=mortonBuffer[first];let commonPrefix=delta(first,last,n,firstCode);var split=first;var searchStep=last-first;while(searchStep>1){searchStep=(searchStep+1)>>1;let newSplit=split+searchStep;if(newSplit<last){let splitPrefix=delta(first,newSplit,n,firstCode);if(splitPrefix>commonPrefix){split=newSplit;}}};return split;}@compute @workgroup_size(128,1,1)fn main(@builtin(global_invocation_id)GID : vec3<u32>){if(GID.x>=${e-1}){return;}let nodeID=GID.x;let range=LGL_BQ(${e},i32(nodeID));let split=LGL_BR(range.x,range.y,${e});bvhNodes[nodeID].childA=u32(split);bvhNodes[nodeID].childB=u32(split+1);if(range.x==split){bvhNodes[nodeID].childA+=${e-1};}if(range.y==split+1){bvhNodes[nodeID].childB+=${e-1};}bvhNodes[bvhNodes[nodeID].childA].parent=nodeID;bvhNodes[bvhNodes[nodeID].childB].parent=nodeID;}`;class tt{constructor(e){this.device=e}async compute(e,t,r,s){const{device:i}=this,a=i.createCommandEncoder(),n=await i.createComputePipelineAsync({layout:"auto",compute:{module:i.createShaderModule({code:et(e)}),entryPoint:"main"}}),o=i.createBindGroup({layout:n.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:t}},{binding:1,resource:{buffer:s}}]}),l=a.beginComputePass();l.setPipeline(n),l.setBindGroup(0,o),l.dispatchWorkgroups(Math.ceil(e/128)),l.end(),i.queue.submit([a.finish()]),await i.queue.onSubmittedWorkDone()}}var rt=(e,t)=>`struct BVHNode{childA: u32,childB: u32,parent: u32,triIndicesID: u32,aabbMin : vec3<f32>,materialID: u32,aabbMax : vec3<f32>,visited: atomic<u32>,}@group(0)@binding(0)var<storage,read_write>bvhNodes : array<BVHNode>;@compute @workgroup_size(128,1,1)fn main(@builtin(global_invocation_id)GID : vec3<u32>){if(GID.x>=${t}){return;}let leafID=${t-1}+GID.x;var curNodeID=bvhNodes[leafID].parent;var depth=1u;while(curNodeID!=0xFFFFFFFF){if(depth<${e}){curNodeID=bvhNodes[curNodeID].parent;depth++;continue;}else if(depth>${e}){break;}depth++;let visited=atomicAdd(&bvhNodes[curNodeID].visited,1);if(visited==0){break;}let childAID=bvhNodes[curNodeID].childA;let childBID=bvhNodes[curNodeID].childB;bvhNodes[curNodeID].aabbMin=min(bvhNodes[childAID].aabbMin,bvhNodes[childBID].aabbMin);bvhNodes[curNodeID].aabbMax=max(bvhNodes[childAID].aabbMax,bvhNodes[childBID].aabbMax);curNodeID=bvhNodes[curNodeID].parent;}}`;class st{constructor(e){this.device=e}async compute(e,t,r){const{device:s}=this,i=s.createCommandEncoder(),a=await s.createComputePipelineAsync({layout:"auto",compute:{module:s.createShaderModule({code:rt(e,t)}),entryPoint:"main"}}),n=s.createBindGroup({layout:a.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:r}}]}),o=i.beginComputePass();o.setPipeline(a),o.setBindGroup(0,n),o.dispatchWorkgroups(Math.ceil(t/128)),o.end(),s.queue.submit([i.finish()]),await s.queue.onSubmittedWorkDone()}}var it=()=>"@group(0)@binding(0)var outputTex : texture_storage_2d<rgba32float,write>;@compute @workgroup_size(8,8,1)fn main(@builtin(global_invocation_id)GlobalInvocationID : vec3<u32>){let screenSize=textureDimensions(outputTex);if(any(GlobalInvocationID.xy>screenSize)){return;}let screenPos=vec2<i32>(i32(GlobalInvocationID.x),i32(GlobalInvocationID.y));let clearColor=vec4<f32>(0.);textureStore(outputTex,screenPos,clearColor);}";const at=class{constructor(e,t,r){this.device=e,this.context=t,this.rg=r}async createPipeline(){const{rg:e}=this;await e.getOrCreateComputePipeline(at.ID,"",it())}clear(e,t){const{rg:r,device:s,context:i}=this,a=r.getComputePipeline(at.ID,""),n=s.createBindGroup({layout:a.getBindGroupLayout(0),entries:[{binding:0,resource:t.createView()}]}),o=e.beginComputePass();o.setPipeline(a),o.setBindGroup(0,n),o.dispatchWorkgroups(Math.ceil(i.width/8),Math.ceil(i.height/8)),o.end()}};let nt=at;nt.ID="ClearTexPass";var ot=(e,t)=>e`@group(0)@binding(0)var inputTex : texture_2d<f32>;@group(0)@binding(1)var<uniform>setting : Setting;@group(0)@binding(2)var screenSampler : sampler;struct Setting{toneMapping : u32,downsamplingFactor : u32,}struct VertexOutput{@builtin(position)position : vec4<f32>,@location(0)uv : vec2<f32>};fn LGL_Ao(color : vec3<f32>)->vec3<f32>{return clamp((color*(2.51*color+0.03))/(color*(2.43*color+0.59)+0.14),vec3<f32>(0.0),vec3<f32>(1.0));}fn LGL_S(linear : vec3<f32>)->vec3<f32>{return saturate(pow(linear,vec3<f32>(1.0/2.2)));}fn NeutralToneMapping(color: vec3<f32>)->vec3<f32>{let StartCompression=0.8-0.04;let Desaturation=0.15;var toneMappingExposure=1.0;var mappedColor=color*toneMappingExposure;let x=min(mappedColor.r,min(mappedColor.g,mappedColor.b));let offset=select(0.04,x-6.25*x*x,x<0.08);mappedColor=mappedColor-offset;let peak=max(mappedColor.r,max(mappedColor.g,mappedColor.b));if(peak<StartCompression){return mappedColor;}let d=1.0-StartCompression;let newPeak=1.0-d*d/(peak+d-StartCompression);mappedColor=mappedColor*(newPeak/peak);let g=1.0-1.0/(Desaturation*(peak-newPeak)+1.0);return mix(mappedColor,vec3<f32>(newPeak),g);}@fragment fn main(vo : VertexOutput)->@location(0)vec4<f32>{var scaleUV=vo.uv/f32(setting.downsamplingFactor);var accAndAlpha=textureSample(inputTex,screenSampler,scaleUV);var acc=accAndAlpha.rgb;if(setting.toneMapping==1){acc=LGL_Ao(acc);}else if(setting.toneMapping==2){acc=NeutralToneMapping(acc);}acc=LGL_S(acc);
#if ${t.supportCanvasAlpha}
return vec4<f32>(acc*accAndAlpha.a,accAndAlpha.a);
#else
return vec4<f32>(acc,accAndAlpha.a);
#endif
}`;const lt=/#([^\s]*)(\s*)/gm;function ut(e,...t){const r=[];let s={string:"",elseIsValid:!1,expression:!0},i=1;for(let a=0;a<e.length;++a){const n=e[a],o=n.matchAll(lt);let l=0,u=!1;for(const e of o){switch(s.string+=n.substring(l,e.index),e[1]){case"if":if(e.index+e[0].length!=n.length)throw new Error("#if must be immediately followed by a template expression (ie: ${value})");u=!0,r.push(s),i++,s={string:"",elseIsValid:!0,expression:!!t[a]};break;case"elif":if(e.index+e[0].length!=n.length)throw new Error("#elif must be immediately followed by a template expression (ie: ${value})");if(!s.elseIsValid)throw new Error("#elif not preceeded by an #if or #elif");u=!0,s.expression&&r.length!=i&&r.push(s),s={string:"",elseIsValid:!0,expression:!!t[a]};break;case"else":if(!s.elseIsValid)throw new Error("#else not preceeded by an #if or #elif");s.expression&&r.length!=i&&r.push(s),s={string:e[2],elseIsValid:!1,expression:!0};break;case"endif":if(!r.length)throw new Error("#endif not preceeded by an #if");const o=r.length==i?r.pop():s;s=r.pop(),i--,o.expression&&(s.string+=o.string),s.string+=e[2];break;default:s.string+=e[0]}l=e.index+e[0].length}l!=n.length&&(s.string+=n.substring(l,n.length)),!u&&t.length>a&&(s.string+=t[a])}if(r.length)throw new Error("Mismatched #if/#endif count");return s.string}const ct=class{constructor(e,t,r){this.device=e,this.context=t,this.rg=r,this.toneMappingVal=0,this.downsamplingFactor=1}async createPipeline(e){this.renderSetting=e,this.toneMappingVal=e.toneMapping;const{rg:t,device:r,context:s}=this;this.settingBuffer=new V(t,"ScreenPassSettingBuffer","u32",2),this.settingBuffer.setData(0,this.toneMappingVal),this.settingBuffer.setData(1,this.downsamplingFactor),this.settingBuffer.submit(),e.renderToScreen||(this.outputTex=t.resourcePool.getOrCreateResource("ScreenPassOutputTexture",{size:{width:s.width,height:s.height},format:"rgba16float",usage:GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST}).raw);let i=t.getRenderPipeline(ct.ID);i||(i=await r.createRenderPipelineAsync({layout:"auto",vertex:{module:r.createShaderModule({code:Ce()}),entryPoint:"main"},fragment:{module:r.createShaderModule({code:ot(ut,e)}),entryPoint:"main",targets:[{format:e.renderToScreen?"bgra8unorm":"rgba16float"}]},primitive:{topology:"triangle-list"}}),t.setRenderPipeline(ct.ID,"",i))}setSize(){const{rg:e,device:t,context:r,renderSetting:s}=this;s.renderToScreen||(this.outputTex=t.createTexture({size:{width:r.width,height:r.height},format:"rgba16float",usage:GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST}),e.resourcePool.updateResource("ScreenPassOutputTexture",this.outputTex,"Texture"))}setToneMapping(e){const{settingBuffer:t,toneMappingVal:r}=this;r!=e&&(this.toneMappingVal=e,t.setData(0,e),t.submit())}setDownsamplingFactor(e){const{settingBuffer:t,downsamplingFactor:r}=this;r!=e&&(this.downsamplingFactor=e,t.setData(1,e),t.submit())}setInputPass(e){this.inputPass=this.rg.getPass(e)}setup(e,t,r){const s={};s.input=t.read(this.inputPass.data.output),s.settingBuffer=t.read(e.importResource("ScreenPassSettingBuffer")),s.samplers=["llr"],r.data=s,t.hasSideEffect=!0}execute(e,t,r,s){const{context:i,renderSetting:a}=this,n=e.getRenderPipeline(t.name,""),o=e.getBindGroup(t.name,n,r,t.data);let l;l=a.renderToScreen?i.createCurrentTextureView():e.getRawResFromPool("ScreenPassOutputTexture").createView();const u=s.beginRenderPass({colorAttachments:[{view:l,clearValue:{r:0,g:0,b:0,a:1},loadOp:"clear",storeOp:"store"}]});u.setPipeline(n),u.setBindGroup(0,o),u.draw(6,1,0,0),u.end()}};let dt=ct;dt.ID="ScreenPass";class ht extends k{static get desc(){return[{name:"cameraViewMatrix",type:"mat4x4<f32>"},{name:"cameraProjViewMatrix",type:"mat4x4<f32>"},{name:"renderSize",type:"vec2<u32>"}]}}ht.RES_NAME="GBufferUniformBuffer",ht.RES_USAGE=GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST;class pt extends k{static get desc(){return[{name:"localToWorldMat",type:"mat4x4<f32>"},{name:"normalMat",type:"mat3x3<f32>"},{name:"meshID",type:"u32"},{name:"matID",type:"u32"}]}}pt.RES_NAME="GBufferMeshUniformBuffer",pt.RES_USAGE=GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST;class ft extends k{static get desc(){return[{name:"viewToWorldMat",type:"mat4x4<f32>"},{name:"clipToViewMat",type:"mat4x4<f32>"},{name:"sampleCount",type:"u32"},{name:"strataSize",type:"f32"},{name:"jitter",type:"vec2<f32>"},{name:"cameraAperture",type:"f32"},{name:"cameraFocus",type:"f32"}]}}ft.RES_NAME="RTFrameUniformBuffer",ft.RES_USAGE=GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST;class mt extends k{static get desc(){return[{name:"envRotMatrix",type:"mat3x3<f32>"},{name:"invEnvRotMatrix",type:"mat3x3<f32>"},{name:"backgroundColor",type:"vec3<f32>"},{name:"envMapIntensity",type:"f32"},{name:"renderSize",type:"vec2<u32>"},{name:"bounces",type:"i32"},{name:"enableBackgroundColor",type:"u32"},{name:"backgroundAlpha",type:"f32"},{name:"totalSumValue",type:"f32"},{name:"lightNum",type:"u32"}]}}mt.RES_NAME="RTSceneUniformBuffer",mt.RES_USAGE=GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST;class gt extends k{static get desc(){return[{name:"tileOffset",type:"vec2<u32>"},{name:"tileSize",type:"vec2<u32>"},{name:"tileEnable",type:"u32"}]}}gt.RES_NAME="RTTileUniformBuffer",gt.RES_USAGE=GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST;class xt extends k{static get desc(){return[{name:"sigColor",type:"f32"},{name:"sigNormal",type:"f32"},{name:"sigPosition",type:"f32"}]}}xt.RES_NAME="AToursUniformBuffer",xt.RES_USAGE=GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST;var bt=(e,t)=>e`const EPS: f32=1.0e-4;const LGL_A: f32=1000000.0;const LGL_B: f32=3.14159265359;const TWO_LGL_B: f32=6.28318530718;const INV_LGL_B: f32=0.31830988618;const INV_LGL_B2: f32=0.10132118364;const LGL_F: f32=0.001;const LGL_G: f32=99999.0;const LGL_H: f32=1.2;const LGL_I: u32=4;const LGL_J: f32=${t.minIntersectDistance||1e-4};const MAX_ALPHA_DEPTH: u32=${t.LGL_An||3};const LGL_L: i32=32;fn LGL_M(color : vec3<f32>)->f32{return dot(color,vec3<f32>(0.2125999927520752,0.7152000069618225,0.0722000002861023));}fn LGL_N(v : vec3<f32>)->f32{return max(max(v.x,v.y),v.z);}fn LGL_O(v : vec3<f32>)->f32{return((v.x+v.y+v.z)/3.0);}fn LGL_P(color : vec3<f32>)->bool{return length(color)==0.0;}fn LGL_Q(color : vec3<f32>)->bool{return((color.x*color.y*color.z)==0.0);}fn LGL_R(srgb : vec3<f32>)->vec3<f32>{return pow(srgb,vec3<f32>(2.2));}fn LGL_S(linear : vec3<f32>)->vec3<f32>{return pow(linear,vec3<f32>(0.454545));}`;var vt=(e,t)=>e`struct Ray{o: vec3<f32>,d: vec3<f32>};struct Path{ray: Ray,li: vec3<f32>,alpha: f32,beta: vec3<f32>,abort: bool,misWeight: f32,absorption: vec3<f32>,specularBounce: bool};struct LightSampleRec{normal: vec3<f32>,emission: vec3<f32>,direction: vec3<f32>,dist: f32,pdf: f32,};
#if ${"Static"==t.sceneMode}
struct BVHNode{childA: u32,childB: u32,parent: u32,triIndicesID: u32,aabbMin : vec3<f32>,materialID: u32,aabbMax : vec3<f32>,visited: u32,}
#else
struct TLASNode{idInfoOrAABBMin: vec3<f32>,typeFlag: f32,meshInfoOraabbMax: vec3<f32>,nextPtr: f32}struct BLASNode{indicesOrMin: vec3<f32>,typeFlag: f32,aabbMax: vec3<f32>,nextPtr: f32}struct TLASTransNode{LGL_sMat : mat4x4<f32>,LGL_rMat : mat4x4<f32>,}
#endif
struct SurfaceInteraction{hit: bool,isEmitter: bool,t: f32,matID: u32,position: vec3<f32>,normal: vec3<f32>,faceNormal: vec3<f32>,ffnormal: vec3<f32>,tangent: vec3<f32>,bitangent: vec3<f32>,eta: f32,materialType: i32,meshID: u32,roughness: f32};struct BSDFSampleRec{L: vec3<f32>,f: vec3<f32>,pdf: f32};struct Basis{T: vec3<f32>,B: vec3<f32>,N: vec3<f32>};fn LGL_o(coord : vec2<f32>)->vec3<f32>{let worldPos : vec4<f32>=frameUniform.viewToWorldMat*frameUniform.clipToViewMat*vec4<f32>(coord,-1.0,1.0);return worldPos.xyz/worldPos.w;}fn LGL_p(N : vec3<f32>)->Basis{var basis : Basis;basis.N=N;if(N.z<-0.999999){basis.T=vec3<f32>(0.,-1.,0.);basis.B=vec3<f32>(-1.,0.,0.);}else{let a=1.0/(1.+N.z);let b=-N.x*N.y*a;basis.T=vec3<f32>(1.0-N.x*N.x*a,b,-N.x);basis.B=vec3<f32>(b,1.-N.y*N.y*a,-N.y);}return basis;}fn LGL_q(r : Ray,bMin : vec3<f32>,bMax : vec3<f32>,invDir : vec3<f32>,tMax : f32)->bool{let tBot=(bMin-r.o)*invDir;let tTop=(bMax-r.o)*invDir;let tNear=min(tBot,tTop);let tFar=max(tBot,tTop);let t0=max(tNear.x,max(tNear.y,tNear.z));let t1=min(tFar.x,min(tFar.y,tFar.z));return max(0.,t0)<=min(tMax,t1);}fn LGL_r(world : vec3<f32>,basis : Basis)->vec3<f32>{return vec3<f32>(dot(world,basis.T),dot(world,basis.B),dot(world,basis.N));}fn LGL_s(local : vec3<f32>,basis : Basis)->vec3<f32>{return basis.T*local.x+basis.B*local.y+basis.N*local.z;}`;var Lt=(e,t,r=!0)=>e`var<private>seed: u32;fn LGL_Z(frame : u32,vCoord : vec2<f32>,texSize : vec2<u32>){var pixel=vec2<u32>((vCoord*vec2<f32>(texSize)));seed=(pixel.x*1973u+pixel.y*9277u+frame*26699u)|1u;seed=hash();}fn hash()->u32{var state=seed;seed=seed*747796405u+2891336453u;var word=((state>>((state>>28u)+4u))^ state)*277803737u;return(word>>22u)^ word;}fn LGL_a(p: vec2f)->f32{return fract(sin(dot(p,vec2f(12.9898,78.233)))*43758.5453);}fn rand()->f32{return f32(hash())/4294967296.0;}fn rand2()->vec2<f32>{return vec2<f32>(rand(),rand());}fn LGL_b()->f32{var state=seed;seed=seed*747796405u+2891336453u;var p=f32(state)/4294967296.0;p=fract(p*.1031);p*=p+33.33;p*=p+p;return fract(p);}fn LGL_b2()->vec2<f32>{return vec2<f32>(LGL_b(),LGL_b());}
#if ${r}
var<private>sampleIndex: u32=0u;var<private>pixelSeed: f32;fn LGL_c(frame : u32,vCoord : vec2<f32>,texSize : vec2<u32>){var pixelSize=1./vec2<f32>(texSize);let noiseSize=vec2<f32>(textureDimensions(noiseTex));pixelSeed=textureSampleLevel(noiseTex,noiseSampler,vCoord/(pixelSize*noiseSize),0.).r;}fn LGL_cMix(frame : u32,vCoord : vec2<f32>,texSize : vec2<u32>){var pixelSize=1./vec2<f32>(texSize);var pixel=vec2<u32>((vCoord*vec2<f32>(texSize)));seed=(pixel.x*1973u+pixel.y*9277u+frame*26699u)|1u;let noiseSize=vec2<f32>(textureDimensions(noiseTex));pixelSeed=rand()*textureSampleLevel(noiseTex,noiseSampler,vCoord/(pixelSize*noiseSize),0.).r;}struct StratifiedSamplesUniforms{data: array<vec4<f32>,16>,}struct LGL_e{s1: vec2<f32>,s2: vec2<f32>,s3: vec2<f32>,s4: vec2<f32>,}fn LGL_f()->f32{let rowIndex=sampleIndex/4;let columnIndex=sampleIndex % 4;let stratifiedSample=stratifiedSamples.data[rowIndex][columnIndex];sampleIndex++;var random=fract((stratifiedSample+pixelSeed)*frameUniform.strataSize);return EPS+(1.0-2.0*EPS)*random;}fn LGL_fVec2()->vec2<f32>{return vec2<f32>(LGL_f(),LGL_f());}fn LGL_g()->LGL_e{var samples: LGL_e;samples.s1=LGL_fVec2();samples.s2=LGL_fVec2();samples.s3=LGL_fVec2();samples.s4=LGL_fVec2();return samples;}fn getOneTurnHashRandom()->LGL_e{var samples: LGL_e;samples.s1=rand2();samples.s2=rand2();samples.s3=rand2();samples.s4=rand2();return samples;}
#endif
`;var yt=(e,t)=>e`fn LGL_h(p1 : vec2<f32>)->vec2<f32>{var p=2.0*p1-1.0;var greater=abs(p.x)>abs(p.y);var r=select(p.y,p.x,greater);var theta=select(LGL_B*(0.5-0.25*p.x/p.y),0.25*LGL_B*p.y/p.x,greater);return r*vec2<f32>(cos(theta),sin(theta));}fn LGL_i(r1 : f32,r2 : f32)->vec3<f32>{var dir : vec3<f32>;let r=sqrt(r1);let phi=TWO_LGL_B*r2;dir.x=r*cos(phi);dir.y=r*sin(phi);dir.z=sqrt(max(0.0,1.0-dir.x*dir.x-dir.y*dir.y));return dir;}fn LGL_iWithPDF(r1 : f32,r2 : f32,pdf : ptr<function,f32>)->vec3<f32>{var dir : vec3<f32>;let r=sqrt(r1);let phi=TWO_LGL_B*r2;dir.x=r*cos(phi);dir.y=r*sin(phi);dir.z=sqrt(max(0.0,1.0-dir.x*dir.x-dir.y*dir.y));*pdf=abs(dir.z)/LGL_B;return dir;}fn LGL_iPdf(wiL : vec3<f32>)->f32{if(wiL.z<0.0){return 0.0;}return wiL.z/LGL_B;}fn LGL_l(f : f32,g : f32)->f32{return(f*f)/(f*f+g*g);}fn LGL_m(mu: f32,anisotropy: f32)->f32{var g=anisotropy;var gSqr=g*g;return(1.0/(4.0*LGL_B))*(1.0-gSqr)/pow(1.0-2.0*g*mu+gSqr,1.5);}fn LGL_n(rayDir: vec3<f32>,anisotropy: f32,s1: vec2<f32>)->vec3<f32>{var g=anisotropy;var costheta: f32;if(abs(g)<1.0e-3){costheta=1.0-2.0*s1.x;}else{costheta=1.0/(2.0*g)*(1.0+g*g-((1.0-g*g)*(1.0-g+2.0*g*s1.x)));}var sintheta=sqrt(max(0.0,1.0-costheta*costheta));var phi=TWO_LGL_B*s1.y;var basis=LGL_p(rayDir);return costheta*rayDir+sintheta*(cos(phi)*basis.T+sin(phi)*basis.B);}fn EmitterSample(r: Ray,depth: i32,lightSampleRec: LightSampleRec,bsdfSampleRec: BSDFSampleRec)->vec3f{var Le=vec3f(0.);if(depth==0){Le=lightSampleRec.emission;}else{Le=LGL_l(bsdfSampleRec.pdf,lightSampleRec.pdf)*lightSampleRec.emission;}return Le;}`;var St=(e,t)=>e`fn LGL_T(pointOnSphere : vec3<f32>)->vec2<f32>{var phi=atan2(pointOnSphere.z,pointOnSphere.x)/TWO_LGL_B;var theta=acos(pointOnSphere.y);return vec2<f32>(phi+0.5,theta*INV_LGL_B);}fn LGL_U(uvIn : vec2<f32>)->vec3<f32>{var uv=uvIn;uv.x-=0.5;let theta=uv.x*2.0*LGL_B;let phi=uv.y*LGL_B;let sinPhi=sin(phi);return vec3<f32>(sinPhi*cos(theta),cos(phi),sinPhi*sin(theta));}fn LGL_V(d : vec3<f32>)->vec3<f32>{var uv=LGL_T(d);var irr=textureSampleLevel(envMap,texSampler,uv,0.).rgb;return irr;}fn LGL_W(dir : vec3<f32>)->f32{let uv=LGL_T(dir);let sinTheta=sin(uv.y*LGL_B);if(sinTheta==0.0){return 0.0;}return INV_LGL_B2/(2.0*sinTheta);}fn LGL_X(dir : vec3<f32>)->f32{let uv=LGL_T(dir);let color=textureSampleLevel(envMap,texSampler,uv,0.).rgb;let lum=LGL_M(color);let totalSum=sceneUniform.totalSumValue;let size=vec2<f32>(textureDimensions(envMap,0));return(size.x*size.y)*(lum/totalSum)*LGL_W(dir);}fn LGL_Y(random : vec2<f32>,uv : ptr<function,vec2<f32>>,pdf : ptr<function,f32>)->vec3<f32>{let size=vec2<f32>(textureDimensions(envMap,0));let sizeMarginalWeights=size.y;var v=textureLoad(envMarginalWeights,vec2<u32>(u32(random.x*sizeMarginalWeights),0),0).x;var u=textureLoad(envConditionalWeights,vec2<u32>(u32(random.y*size.x),u32(v*size.y)),0).x;*uv=vec2<f32>(u,v);let dir=LGL_U(*uv);let color=textureSampleLevel(envMap,texSampler,*uv,0.).rgb;let lum=LGL_M(color);let totalSum=sceneUniform.totalSumValue;*(pdf)=(size.x*size.y)*(lum/totalSum)*LGL_W(dir);return dir;}`;var Mt=(e,t)=>e`struct PrincipledBSDF{color: vec3<f32>,workflow: f32,roughness: f32,metalness: f32,transmission: f32,ior: f32,specularColor: vec3<f32>,glossiness: f32,sheen: f32,sheenTint: f32,clearcoat: f32,clearcoatRoughness: f32,extinction: vec3<f32>,atDistance: f32,subsurfaceMFP: f32,subsurfaceColor: vec3<f32>,subsurface: f32,specularTint: f32,alpha: f32,oriRoughness: f32,emissiveColor: vec3<f32>,}var<private>principledBSDFMaterial: PrincipledBSDF;struct Material{color: vec3<f32>,workflow: f32,roughness: f32,metalness: f32,transmission: f32,ior: f32,sheen: f32,sheenTint: f32,clearcoat: f32,clearcoatRoughness: f32,emissiveColor: vec3<f32>,alpha: f32,specularTint: f32,atDistance: f32,normalScale: vec2<f32>,subsurfaceColor: vec3<f32>,subsurface: f32,extinction: vec3<f32>,subsurfaceMFP: f32,specularColor: vec3<f32>,glossiness: f32,map: i32,normalMap: i32,roughnessMap: i32,metalnessMap: i32,emissiveMap: i32,specularMap: i32,glossinessMap: i32,materialType: i32,}
#if ${t.supportUVTrans||t.supportTexWrap}
const UV_TRANS_MAPS_LEN: i32=7;struct TexUVTrans{texUVTransMat : array<mat3x3<f32>,UV_TRANS_MAPS_LEN>,texWrapping: array<vec4<f32>,UV_TRANS_MAPS_LEN>,}
#endif
`;var Tt=(e,t)=>e`
#if ${t.supportTexWrap}
fn applyTextureWrapping(uv: vec2f,wrapping: vec2f)->vec2f{var result: vec2f=uv;if(uv.x<=0.||uv.x>=1.){let warpS=i32(wrapping.x);if(warpS==1){result.x=select(0.0,1.0,uv.x<=0.0);}else if(warpS==2){result.x=1.0-abs(fract(uv.x*0.5)*2.0-1.0);}else{result.x=fract(uv.x);}}if(uv.y<=0.0||uv.y>=1.){let warpT=i32(wrapping.y);if(warpT==1){result.y=select(0.0,1.0,uv.y<=0.0);}else if(warpT==2){result.y=1.0-abs(fract(uv.y*0.5)*2.0-1.0);}else{result.y=fract(uv.y);}}return result;}
#endif
#if ${t.supportSGWorkflow}
fn LGL_AJ(v: vec3f)->f32{return max(v.x,max(v.y,v.z));}fn LGL_AK(specularColor : vec3f)->f32{return LGL_AJ(specularColor);}fn LGL_AL(baseColor : vec3f,metallic : f32)->vec3f{return baseColor*(1.0-metallic);}fn LGL_AM(matID: u32,uvIn: vec2<f32>)->vec3<f32>{var specularColor=materials[matID].specularColor;let texIndex=materials[matID].specularMap;if(texIndex>-1){var uv=uvIn;
#if ${t.supportUVTrans}
var uvTransMat=texUVTrans[matID].texUVTransMat[4];uv=(uvTransMat*vec3f(uvIn,1.)).xy;
#endif
#if ${t.supportTexWrap}
var warpping=texUVTrans[matID].texWrapping[4];uv=applyTextureWrapping(uv,warpping.xy);
#endif
specularColor*=LGL_R(textureSampleLevel(textureArray,texSampler,uv,texIndex,0).rgb);}return specularColor;}fn LGL_AN(matID: u32,uvIn: vec2<f32>)->f32{var glossiness=materials[matID].glossiness;let texIndex=materials[matID].glossinessMap;if(texIndex>-1){var uv=uvIn;
#if ${t.supportUVTrans}
var uvTransMat=texUVTrans[matID].texUVTransMat[5];uv=(uvTransMat*vec3f(uvIn,1.)).xy;
#endif
#if ${t.supportTexWrap}
var warpping=texUVTrans[matID].texWrapping[5];uv=applyTextureWrapping(uv,warpping.xy);
#endif
glossiness*=textureSampleLevel(textureArray,texSampler,uv,texIndex,0).a;}return glossiness;}
#endif
fn LGL_AO(matID: u32,uvIn: vec2<f32>)->vec4<f32>{var color=materials[matID].color;var alpha=materials[matID].alpha;var uv=uvIn;
#if ${t.supportUVTrans}
var uvTransMat=texUVTrans[matID].texUVTransMat[0];uv=(uvTransMat*vec3f(uvIn,1.)).xy;
#endif
#if ${t.supportTexWrap}
var warpping=texUVTrans[matID].texWrapping[0];uv=applyTextureWrapping(uv,warpping.xy);
#endif
let texIndex=materials[matID].map;if(texIndex>-1){let texData=textureSampleLevel(textureArray,texSampler,uv,texIndex,0);color*=LGL_R(texData.rgb);alpha*=texData.a;}
#if ${t.supportSGWorkflow}
let workflow=materials[matID].workflow;if(workflow>0.){let specularFactor=LGL_AM(matID,uv);color=LGL_AL(color,LGL_AK(specularFactor));}
#endif
return vec4f(color,alpha);}fn LGL_AP(matID : u32,uvIn : vec2<f32>)->f32{let workflow=materials[matID].workflow;var roughness=0.;
#if ${t.supportSGWorkflow}
if(workflow>0.){roughness=1.0-LGL_AN(matID,uvIn);}else
#endif
{roughness=materials[matID].roughness;let texIndex=materials[matID].roughnessMap;if(texIndex>-1){var uv=uvIn;
#if ${t.supportUVTrans}
var uvTransMat=texUVTrans[matID].texUVTransMat[2];uv=(uvTransMat*vec3f(uvIn,1.)).xy;
#endif
#if ${t.supportTexWrap}
var warpping=texUVTrans[matID].texWrapping[2];uv=applyTextureWrapping(uv,warpping.xy);
#endif
roughness*=textureSampleLevel(textureArray,texSampler,uv,texIndex,0).g;}}return roughness;}fn LGL_AQ(matID : u32,uvIn : vec2<f32>)->f32{let workflow=materials[matID].workflow;var metalness=0.;
#if ${t.supportSGWorkflow}
if(workflow>0.){let specularFactor=LGL_AM(matID,uvIn);metalness=LGL_AK(specularFactor);}else
#endif
{metalness=materials[matID].metalness;let texIndex=materials[matID].metalnessMap;if(texIndex>-1){var uv=uvIn;
#if ${t.supportUVTrans}
var uvTransMat=texUVTrans[matID].texUVTransMat[3];uv=(uvTransMat*vec3f(uvIn,1.)).xy;
#endif
#if ${t.supportTexWrap}
var warpping=texUVTrans[matID].texWrapping[3];uv=applyTextureWrapping(uv,warpping.xy);
#endif
metalness*=textureSampleLevel(textureArray,texSampler,uv,texIndex,0).b;}}return metalness;}fn LGL_AR(matID : u32,uvIn : vec2<f32>)->vec3<f32>{var emissiveColor=materials[matID].emissiveColor;let texIndex=materials[matID].emissiveMap;if(texIndex>-1){var uv=uvIn;
#if ${t.supportUVTrans}
var uvTransMat=texUVTrans[matID].texUVTransMat[6];uv=(uvTransMat*vec3f(uvIn,1.)).xy;
#endif
#if ${t.supportTexWrap}
var warpping=texUVTrans[matID].texWrapping[6];uv=applyTextureWrapping(uv,warpping.xy);
#endif
emissiveColor*=LGL_R(textureSampleLevel(textureArray,texSampler,uv,texIndex,0).rgb);}return emissiveColor;}fn LGL_AS(matID : u32,uvIn : vec2<f32>,normalIn : vec3<f32>,faceNormal : vec3<f32>,dp1 : vec3<f32>,dp2 : vec3<f32>,duv1 : vec2<f32>,duv2 : vec2<f32>)->vec3<f32>{var normal=normalIn;normal=normal*sign(dot(normal,faceNormal));let dp2perp=cross(dp2,normal);let dp1perp=cross(normal,dp1);var dpdu=dp2perp*duv1.x+dp1perp*duv2.x;var dpdv=dp2perp*duv1.y+dp1perp*duv2.y;let invmax=inverseSqrt(max(dot(dpdu,dpdu),dot(dpdv,dpdv)));dpdu*=invmax;dpdv*=invmax;let texIndex=materials[matID].normalMap;if(texIndex>-1){var uv=uvIn;
#if ${t.supportUVTrans}
var uvTransMat=texUVTrans[matID].texUVTransMat[1];uv=(uvTransMat*vec3f(uvIn,1.)).xy;
#endif
#if ${t.supportTexWrap}
var warpping=texUVTrans[matID].texWrapping[1];uv=applyTextureWrapping(uv,warpping.xy);
#endif
var n=2.*textureSampleLevel(textureArray,texSampler,uv,texIndex,0).rgb-1.;n.x*=materials[matID].normalScale.x;n.y*=materials[matID].normalScale.y;
#if ${"Hybrid"==t.LGL_Ar}
n.x*=-1.;n.y*=-1.;
#endif
var tbn=mat3x3(dpdu,dpdv,normal);return normalize(tbn*n);}return normal;}fn getMatCastShadow(matID : u32)->f32{let workflow=materials[matID].workflow;var castShadow=0.;if(workflow>0.){castShadow=materials[matID].roughness;}else{castShadow=materials[matID].glossiness;}return castShadow;}fn LGL_AT(matID : u32,uv : vec2<f32>)->PrincipledBSDF{var material : PrincipledBSDF;material.workflow=materials[matID].workflow;var colorAlpha=LGL_AO(matID,uv);material.color=colorAlpha.rgb;material.alpha=colorAlpha.a;material.oriRoughness=LGL_AP(matID,uv);material.roughness=clamp(material.oriRoughness*material.oriRoughness,LGL_F,1.0);material.metalness=LGL_AQ(matID,uv);material.emissiveColor=LGL_AR(matID,uv);material.transmission=materials[matID].transmission;material.ior=materials[matID].ior;
#if ${t.supportSGWorkflow}
material.specularColor=LGL_AM(matID,uv);material.glossiness=materials[matID].glossiness;
#endif
material.sheen=materials[matID].sheen;material.sheenTint=materials[matID].sheenTint;material.clearcoat=materials[matID].clearcoat;material.clearcoatRoughness=materials[matID].clearcoatRoughness;material.extinction=materials[matID].extinction;material.specularTint=materials[matID].specularTint;material.atDistance=materials[matID].atDistance;material.subsurfaceColor=materials[matID].subsurfaceColor;material.subsurface=materials[matID].subsurface;material.subsurfaceMFP=materials[matID].subsurfaceMFP;return material;}`;var Gt=(e,t)=>e`fn LGL_t(eta : f32)->f32{let sqrtR0 : f32=((eta-1.0)/(eta+1.0));return(sqrtR0*sqrtR0);}fn LGL_u(u : f32)->f32{let m : f32=clamp((1.0-u),0.0,1.0);let m2=m*m;return m2*m2*m;}fn LGL_v(F0 : f32,cosTheta : f32)->f32{return mix(F0,1.0,LGL_u(cosTheta));}fn LGL_vVec3(F0 : vec3<f32>,cosTheta : f32)->vec3<f32>{return mix(F0,vec3<f32>(1.0),LGL_u(cosTheta));}fn LGL_x(cosThetaI1 : f32,eta1 : f32)->f32{var cosThetaI=cosThetaI1;var eta=eta1;cosThetaI=clamp(cosThetaI,-(1.0),1.0);let entering : bool=cosThetaI>0.0;if(!entering){eta=1.0/eta;cosThetaI=abs(cosThetaI);}let sinThetaTSq=eta*eta*(1.0-cosThetaI*cosThetaI);if(sinThetaTSq>1.0){return 1.0;}let cosThetaT=sqrt(max(1.0-sinThetaTSq,0.0));let rs=(eta*cosThetaT-cosThetaI)/(eta*cosThetaT+cosThetaI);let rp=(eta*cosThetaI-cosThetaT)/(eta*cosThetaI+cosThetaT);return 0.5*(rs*rs+rp*rp);}fn LGL_y(metalness : f32,eta : f32,cosThetaI : f32)->f32{let FrSchlick=LGL_u(cosThetaI);let FrDielectric=LGL_x(cosThetaI,eta);return mix(FrDielectric,FrSchlick,metalness);}fn LGL_z(NDotV : f32,alphaG : f32)->f32{let a=alphaG*alphaG;let b=NDotV*NDotV;return 1.0/(NDotV+sqrt(a+b-a*b));}fn LGL_AA(NDotH : f32,alpha : f32)->f32{let alpha2=alpha*alpha;let t=1.0+(alpha2-1.0)*NDotH*NDotH;return(alpha2-1.0)/(LGL_B*log(alpha2)*t);}fn LGL_AB(NDotH : f32,a : f32)->f32{let a2=a*a;let t=1.0+(a2-1.0)*NDotH*NDotH;return a2/(LGL_B*t*t);}fn ISLGL_AA(rgh : f32,r1 : f32,r2 : f32)->vec3<f32>{let a=max(0.001,rgh);let a2=a*a;let phi=r1*TWO_LGL_B;let cosTheta=sqrt((1.0-pow(a2,1.0-r1))/(1.0-a2));let sinTheta=clamp(sqrt(1.0-(cosTheta*cosTheta)),0.0,1.0);let sinPhi=sin(phi);let cosPhi=cos(phi);return vec3<f32>(sinTheta*cosPhi,sinTheta*sinPhi,cosTheta);}fn ISLGL_AB(rgh : f32,r1 : f32,r2 : f32)->vec3<f32>{let a=max(0.001,rgh);let phi=r1*TWO_LGL_B;let cosTheta=sqrt((1.0-r2)/(1.0+(a*a-1.0)*r2));let sinTheta=clamp(sqrt(1.0-(cosTheta*cosTheta)),0.0,1.0);let sinPhi=sin(phi);let cosPhi=cos(phi);return vec3<f32>(sinTheta*cosPhi,sinTheta*sinPhi,cosTheta);}`;var _t=(e,t)=>e`
#if ${t.enableSSS}
const LGL_AE: u32=5;const LGL_AF: u32=2;fn LGL_AG(material: PrincipledBSDF,Cspec0: vec3<f32>)->f32{let diffuseWt=(1.0-material.subsurface)*max(LGL_M(material.color),material.sheen)*(1.0-material.metalness)*(1.0-material.transmission);let specularWt=LGL_M(Cspec0);let transWt=(1.0-material.subsurface)*(1.0-material.metalness)*material.transmission*LGL_M(material.color);let clearcoatWt=material.clearcoat*(1.0-material.metalness);let sssWt=material.subsurface*LGL_M(material.subsurfaceColor)*5.;let weightSum=diffuseWt+specularWt+transWt+clearcoatWt+sssWt;return clamp(sssWt/weightSum,0.,1.);}fn LGL_AH(si: SurfaceInteraction,material: PrincipledBSDF,basis: Basis,s1: vec2<f32>,s2: vec2<f32>,throughput : ptr<function,vec3<f32>>,siExit: ptr<function,SurfaceInteraction>,lightSampleRec : ptr<function,LightSampleRec>)->bool{let lengthScale=.5;let subsurfaceAnisotropy=0.;var walkPos=si.position-LGL_J*si.normal;var walkDirL=LGL_i(s1.x,s1.y);var walkDirW=-LGL_s(walkDirL,basis);*throughput=vec3<f32>(1.0);var sssRay : Ray;for(var n=0u;n<LGL_AE;n++){var walkDist=-log(rand())*material.subsurfaceMFP*lengthScale;sssRay.o=walkPos;sssRay.d=walkDirW;var siScatter : SurfaceInteraction;LGL_Ak(&siScatter,sssRay,lightSampleRec,1,walkDist);if(siScatter.hit){*siExit=siScatter;return true;}if(n>LGL_AF){let continuationProb=clamp(10.0*LGL_N(*throughput),0.0,1.0);let terminationProb=1.0-continuationProb;if(rand()<terminationProb){break;}*throughput/=continuationProb;}walkDirW=LGL_n(walkDirW,subsurfaceAnisotropy,s2);walkPos+=walkDist*walkDirW;*throughput=*throughput*material.subsurfaceColor;}return false;}fn LGL_AI(si: SurfaceInteraction,material: PrincipledBSDF,basis: Basis,s1: vec2<f32>,s2: vec2<f32>)->vec3<f32>{var surfacePos=si.position+LGL_J*basis.N;var Li=vec3<f32>(0.0);var bsdfSampleRec : BSDFSampleRec;var woutputL : vec3<f32>;var woutputW : vec3<f32>;var uv : vec2<f32>;var lightPdf : f32;bsdfSampleRec.f=material.color/LGL_B;woutputW=sceneUniform.invEnvRotMatrix*LGL_Y(s1,&uv,&lightPdf);woutputL=LGL_r(woutputW,basis);var ray=Ray(surfacePos,woutputW);if(!LGL_Al(ray,LGL_A)){var irr=textureSampleLevel(envMap,texSampler,uv,0.).rgb*sceneUniform.envMapIntensity;bsdfSampleRec.pdf=LGL_iPdf(woutputL);var misWeight=LGL_l(lightPdf,bsdfSampleRec.pdf);Li+=misWeight*bsdfSampleRec.f*irr*abs(woutputL.z)/lightPdf;}
#if ${t.supportLightSource}
var lightSampleRec: LightSampleRec;var i=i32(s2.x*f32(sceneUniform.lightNum));var lightData=lights.data[i];var light=Light(lightData.position,lightData.radius,lightData.emission,lightData.area,lightData.p1,lightData.lightType,lightData.p2,lightData.visible);sampleOneLight(light,surfacePos,&lightSampleRec,s2);if(dot(lightSampleRec.direction,lightSampleRec.normal)<0.0){var ray=Ray(surfacePos,lightSampleRec.direction);if(!LGL_Al(ray,lightSampleRec.dist-EPS)){woutputW=lightSampleRec.direction;woutputL=LGL_r(woutputW,basis);bsdfSampleRec.pdf=LGL_iPdf(woutputL);var misWeight=1.0;if(light.area>0.0&&bsdfSampleRec.pdf>0.0){misWeight=LGL_l(lightSampleRec.pdf,bsdfSampleRec.pdf);}if(misWeight>0.0){Li+=misWeight*bsdfSampleRec.f*lightSampleRec.emission*abs(woutputL.z)/lightSampleRec.pdf;}}}
#endif
return Li;}
#endif
`;var Pt=(e,t)=>e`fn LGL_AU(material : PrincipledBSDF,Csheen : vec3<f32>,V : vec3<f32>,L : vec3<f32>,H : vec3<f32>,pdf : ptr<function,f32>)->vec3<f32>{if((L.z<=0.0)){return vec3<f32>(0.0);}*pdf=L.z*INV_LGL_B;let LDotH=dot(L,H);let FL=LGL_u(L.z);let FV=LGL_u(V.z);let Fh=LGL_u(LDotH);let Fd90=0.5+2.0*LDotH*LDotH*material.roughness;let Fd=mix(1.0,Fd90,FL)*mix(1.0,Fd90,FV);
#if ${"PT"==t.LGL_Ar}
let Fsheen=Fh*material.sheen*Csheen;return(INV_LGL_B*Fd*material.color+Fsheen)*(1.0-material.metalness)*(1.0-material.transmission);
#else
return(INV_LGL_B*Fd*material.color)*(1.0-material.metalness)*(1.0-material.transmission);
#endif
}fn LGL_AV(material : PrincipledBSDF,eta : f32,Cspec0 : vec3<f32>,V : vec3<f32>,L : vec3<f32>,H : vec3<f32>,pdf : ptr<function,f32>)->vec3<f32>{if((L.z<=0.0)){return vec3<f32>(0.0);}let LDotH=dot(L,H);let D=LGL_AB(H.z,material.roughness);*pdf=D*H.z/(4.0*LDotH);let FMix=LGL_y(material.metalness,eta,LDotH);let F=mix(Cspec0,vec3<f32>(1.0),FMix);let G=LGL_z(abs(L.z),material.roughness)*LGL_z(abs(V.z),material.roughness);return F*D*G;}fn LGL_AW(material : PrincipledBSDF,eta : f32,Cspec : vec3<f32>,V : vec3<f32>,L : vec3<f32>,H : vec3<f32>,pdf : ptr<function,f32>)->vec3<f32>{if((L.z>=0.0)){return vec3<f32>(0.0);}let F=LGL_x(abs(dot(V,H)),eta);let D=LGL_AB(H.z,material.roughness);let denomSqrt=dot(L,H)+dot(V,H)*eta;*pdf=D*H.z*abs(dot(L,H))/(denomSqrt*denomSqrt);let G=LGL_z(abs(L.z),material.roughness)*LGL_z(abs(V.z),material.roughness);let specColor=pow(material.color,vec3<f32>(0.5));return specColor*(1.0-material.metalness)*material.transmission*(1.0-F)*D*G*abs(dot(V,H))*abs(dot(L,H))*4.0*eta*eta/(denomSqrt*denomSqrt);}
#if ${"PT"==t.LGL_Ar}
fn LGL_AX(material : PrincipledBSDF,V : vec3<f32>,L : vec3<f32>,H : vec3<f32>,pdf : ptr<function,f32>)->vec3<f32>{if((L.z<=0.0)){return vec3<f32>(0.0);}let LDotH=dot(L,H);let F=LGL_v(.04,LDotH);let D=LGL_AA(H.z,mix(0.1,0.001,1.-material.clearcoatRoughness));*pdf=D*H.z/(4.0*LDotH);let G=LGL_z(L.z,0.25)*LGL_z(V.z,0.25);return vec3<f32>(0.25*material.clearcoat*F*D*G);}
#endif
fn LGL_AY(baseColor : vec3<f32>)->vec3<f32>{let LGL_M=LGL_M(baseColor);return select(vec3<f32>(1.),baseColor/LGL_M,LGL_M>0.0);}fn LGL_AZ(material : PrincipledBSDF,eta : f32,Cspec0 : ptr<function,vec3<f32>>,Csheen : ptr<function,vec3<f32>>){
#if ${t.supportSGWorkflow}
if(material.workflow>0.){*Cspec0=material.specularColor;}else
#endif
{
#if ${"PT"==t.LGL_Ar}
let tint=LGL_AY(material.color);*Cspec0=mix(LGL_t(eta)*mix(vec3<f32>(1.0),tint,material.specularTint),material.color,material.metalness);*Csheen=mix(vec3<f32>(1.0),tint,material.sheenTint);
#else
*Cspec0=mix(vec3f(LGL_t(eta)),material.color,material.metalness);
#endif
}}fn LGL_Aa(material : PrincipledBSDF,Cspec0 : vec3<f32>,fresnelWeight : f32,diffuseWt : ptr<function,f32>,specularWt : ptr<function,f32>,transWt : ptr<function,f32>,clearcoatWt : ptr<function,f32>){*specularWt=LGL_M(mix(Cspec0,vec3<f32>(1.0),fresnelWeight));*transWt=(1.0-fresnelWeight)*(1.0-material.metalness)*material.transmission*LGL_M(material.color);
#if ${"PT"==t.LGL_Ar}
*diffuseWt=max(LGL_M(material.color),material.sheen)*(1.0-material.metalness)*(1.0-material.transmission);*clearcoatWt=material.clearcoat*(1.0-material.metalness);
#else
*diffuseWt=LGL_M(material.color)*(1.0-material.metalness)*(1.0-material.transmission);*clearcoatWt=0.;
#endif
let weightSum=*diffuseWt+*specularWt+*transWt+*clearcoatWt;*diffuseWt/=weightSum;*specularWt/=weightSum;*transWt/=weightSum;*clearcoatWt/=weightSum;}fn LGL_Ab(si : SurfaceInteraction,material : PrincipledBSDF,basis : Basis,LGL_f : vec2<f32>,V : vec3<f32>,N : vec3<f32>,L : ptr<function,vec3<f32>>,pdf : ptr<function,f32>)->vec3<f32>{var f=vec3<f32>(0.0);*pdf=0.0;var r1=LGL_f.x;var r2=LGL_f.y;var Cspec0 : vec3<f32>;var Csheen : vec3<f32>;LGL_AZ(material,si.eta,&Cspec0,&Csheen);var diffuseWt : f32;var specularWt : f32;var transWt : f32;var clearcoatWt : f32;var fresnelWeight=LGL_y(material.metalness,si.eta,V.z);LGL_Aa(material,Cspec0,fresnelWeight,&diffuseWt,&specularWt,&transWt,&clearcoatWt);var weight : array<f32,4u>;weight[0]=diffuseWt;weight[1]=weight[0]+specularWt;weight[2]=weight[1]+transWt;weight[3]=weight[2]+clearcoatWt;if(r1<weight[0]){r1/=weight[0];*L=LGL_i(r1,r2);var H=normalize(*L+V);f=LGL_AU(material,Csheen,V,*L,H,pdf);*pdf*=diffuseWt;}else if(r1<weight[1]){r1=(r1-weight[0])/(weight[1]-weight[0]);var H=ISLGL_AB(material.roughness,r1,r2);if(dot(V,H)<0.0){H=-H;}*L=normalize(reflect(-V,H));f=LGL_AV(material,si.eta,Cspec0,V,*L,H,pdf);*pdf*=specularWt;}else if(r1<weight[2]){r1=(r1-weight[1])/(weight[2]-weight[1]);var H=ISLGL_AB(material.roughness,r1,r2);if(dot(V,H)<0.0){H=-H;}var R=reflect(-V,H);*L=normalize(refract(-V,H,si.eta));f=LGL_AW(material,si.eta,Cspec0,V,*L,H,pdf);*pdf*=transWt;}
#if ${"PT"==t.LGL_Ar}
else{r1=(r1-weight[2])/(1.0-weight[2]);var H=ISLGL_AA(mix(0.1,0.001,1.-material.clearcoatRoughness),r1,r2);if(dot(V,H)<0.0){H=-H;}*L=normalize(reflect(-V,H));f=LGL_AX(material,V,*L,H,pdf);*pdf*=clearcoatWt;}
#endif
*L=LGL_s(*L,basis);return f;}fn LGL_Ac(si : SurfaceInteraction,material : PrincipledBSDF,V : vec3<f32>,L : vec3<f32>,bsdfPdf : ptr<function,f32>)->vec3<f32>{var f=vec3<f32>(0.0);*bsdfPdf=0.0;var H : vec3<f32>;if(L.z>0.0){H=normalize(L+V);}else{H=normalize(L+V*si.eta);}if(dot(V,H)<0.0){H=-H;}var Cspec0 : vec3<f32>;var Csheen : vec3<f32>;LGL_AZ(material,si.eta,&Cspec0,&Csheen);var diffuseWt : f32;var specularWt : f32;var transWt : f32;var clearcoatWt : f32;var fresnelWeight=LGL_y(material.metalness,si.eta,abs(dot(L,H)));LGL_Aa(material,Cspec0,fresnelWeight,&diffuseWt,&specularWt,&transWt,&clearcoatWt);var pdf : f32;if(diffuseWt>0.0&&L.z>0.0){f+=LGL_AU(material,Csheen,V,L,H,&pdf);*bsdfPdf+=pdf*diffuseWt;}if(specularWt>0.0&&L.z>0.0&&V.z>0.0){f+=LGL_AV(material,si.eta,Cspec0,V,L,H,&pdf);*bsdfPdf+=pdf*specularWt;}if(transWt>0.0&&L.z<0.0){f+=LGL_AW(material,si.eta,Cspec0,V,L,H,&pdf);*bsdfPdf+=pdf*transWt;}
#if ${"PT"==t.LGL_Ar}
if(clearcoatWt>0.0&&L.z>0.0&&V.z>0.0){f+=LGL_AX(material,V,L,H,&pdf);*bsdfPdf+=pdf*clearcoatWt;}
#endif
return f;}`;var Bt=(e,t)=>e`struct Triangle{p0: vec3<f32>,p1: vec3<f32>,p2: vec3<f32>};struct TriangleIntersect{t: f32,barycentric: vec3<f32>};fn rectIntersect(pos: vec3f,u: vec3f,v: vec3f,plane: vec4f,r: Ray)->f32{var n=plane.xyz;var dt=dot(r.d,n);var t=(plane.w-dot(n,r.o))/dt;if(t>EPS){var p=r.o+r.d*t;var vi=p-pos;var a1=dot(u,vi);if(abs(a1)<=0.5){var a2=dot(v,vi);if(abs(a2)<=0.5){return t;}}}return LGL_A;}fn LGL_Ai(r : Ray,tri : Triangle,tMax : f32)->TriangleIntersect{let v0=tri.p0;let v1=tri.p1;let v2=tri.p2;var ti : TriangleIntersect;let v1v0=v1-v0;let v2v0=v2-v0;let rov0=r.o-v0;let n=cross(v1v0,v2v0);let q=cross(rov0,r.d);let d=1./dot(r.d,n);var uvt : vec4<f32>;uvt.x=d*dot(-q,v2v0);uvt.y=d*dot(q,v1v0);uvt.z=d*dot(-n,rov0);uvt.w=1.0-uvt.x-uvt.y;if(uvt.z>=tMax){return ti;}if(all(uvt>vec4<f32>(0.0))&&uvt.z<LGL_A){ti.t=uvt.z;ti.barycentric=uvt.wxy;}return ti;}fn LGL_Ae(indice : u32)->vec3<f32>{return vec3<f32>(position[indice][0],position[indice][1],position[indice][2]);}fn LGL_Ah(triIndices : vec3<u32>)->Triangle{let posU=LGL_Ae(triIndices.x);let posV=LGL_Ae(triIndices.y);let posW=LGL_Ae(triIndices.z);let tri=Triangle(posU,posV,posW);return tri;}fn LGL_Af(indice : u32)->vec3<f32>{return vec3<f32>(normal[indice][0],normal[indice][1],normal[indice][2]);}fn LGL_Ag(indice : u32)->vec2<f32>{return vec2<f32>(uv[indice][0],uv[indice][1]);}fn LGL_Aj(siPtr : ptr<function,SurfaceInteraction>,tri : Triangle,barycentric : vec3<f32>,index : vec3<u32>){(*siPtr).position=barycentric.x*tri.p0+barycentric.y*tri.p1+barycentric.z*tri.p2;let n0=LGL_Af(index.x);let n1=LGL_Af(index.y);let n2=LGL_Af(index.z);let normal=normalize(barycentric.x*n0+barycentric.y*n1+barycentric.z*n2);let e0=tri.p1-tri.p0;let e1=tri.p2-tri.p0;let faceNormal=normalize(cross(e0,e1));(*siPtr).faceNormal=faceNormal;let uv0=LGL_Ag(index.x);let uv1=LGL_Ag(index.y);let uv2=LGL_Ag(index.z);let uv=barycentric.x*uv0+barycentric.y*uv1+barycentric.z*uv2;let materialIndex=(*siPtr).matID;principledBSDFMaterial=LGL_AT(materialIndex,uv);let dp1=tri.p0-tri.p2;let dp2=tri.p1-tri.p2;let duv1=uv0-uv2;let duv2=uv1-uv2;(*siPtr).normal=LGL_AS(materialIndex,uv,normal,faceNormal,dp1,dp2,duv1,duv2);}fn surfaceMaterialAlphaFromBVH(materialIndex : u32,barycentric : vec3<f32>,index : vec3<u32>)->f32{let uv0=LGL_Ag(index.x);let uv1=LGL_Ag(index.y);let uv2=LGL_Ag(index.z);let uv=barycentric.x*uv0+barycentric.y*uv1+barycentric.z*uv2;var colorAlpha=LGL_AO(materialIndex,uv);return colorAlpha.a;}`;var Rt=(e,t)=>e`fn LGL_Al(ray : Ray,maxDist : f32)->bool{var tMax=maxDist;var nodesToVisit : array<i32,LGL_L>;var nodesLevel : array<i32,LGL_L>;nodesToVisit[0]=0;nodesLevel[0]=0;var invDirWorld=1./ray.d;var invDirLocal=vec3f(1.);let maxDepth: i32=20;var tlasTransMat: mat4x4<f32>;var tlasTransMatInverse: mat4x4<f32>;var rayTrans:Ray;rayTrans.o=ray.o;rayTrans.d=ray.d;var throughBLASMark=false;var tlasMatID: u32=0;var stack: i32=0;while(stack>=0&&stack<maxDepth){var i=nodesToVisit[stack];var level=nodesLevel[stack];stack--;if(throughBLASMark&&i==-1){throughBLASMark=false;rayTrans.o=ray.o;rayTrans.d=ray.d;continue;}if(level==0){var tlasNode=tlasNodes[i];var typeFlag=tlasNode.typeFlag;if(typeFlag==1.){let visible=u32(tlasNode.meshInfoOraabbMax.x);if(visible==0){continue;}let instanceID=i32(tlasNode.idInfoOrAABBMin.z);tlasTransMat=tlasTransNodes[instanceID].LGL_sMat;tlasTransMatInverse=tlasTransNodes[instanceID].LGL_rMat;rayTrans.o=(tlasTransMatInverse*vec4f(ray.o,1.0)).xyz;rayTrans.d=(tlasTransMatInverse*vec4f(ray.d,0.0)).xyz;invDirLocal=1./rayTrans.d;stack++;throughBLASMark=true;nodesToVisit[stack]=-1;nodesLevel[stack]=-1;stack++;let blasNodeIndex=i32(tlasNode.idInfoOrAABBMin.x);nodesToVisit[stack]=blasNodeIndex;nodesLevel[stack]=1;tlasMatID=u32(tlasNode.idInfoOrAABBMin.y);}else{let aabbMin=tlasNode.idInfoOrAABBMin;let aabbMax=tlasNode.meshInfoOraabbMax;if(LGL_q(rayTrans,aabbMin,aabbMax,invDirWorld,tMax)){stack++;nodesToVisit[stack]=i+1;nodesLevel[stack]=0;stack++;nodesToVisit[stack]=i32(tlasNode.nextPtr);nodesLevel[stack]=0;}}}else{var blasNode=blasNodes[i];var typeFlag=blasNode.typeFlag;if(typeFlag==1.){
#if ${t.supportCastShadow}
var castShadow=getMatCastShadow(tlasMatID);if(castShadow==0.){return false;}
#endif
let triIndices=vec3<u32>(blasNode.indicesOrMin);let tri=LGL_Ah(triIndices);let hit=LGL_Ai(rayTrans,tri,tMax);if(hit.t>0.){
#if ${t.supportAlphaShadow}
let alpha=surfaceMaterialAlphaFromBVH(tlasMatID,hit.barycentric,triIndices);if(rand()>alpha){return false;}
#endif
return true;}}else{let aabbMin=blasNode.indicesOrMin;let aabbMax=blasNode.aabbMax;if(LGL_q(rayTrans,aabbMin,aabbMax,invDirLocal,tMax)){stack++;nodesToVisit[stack]=i+1;nodesLevel[stack]=1;stack++;nodesToVisit[stack]=i32(blasNode.nextPtr);nodesLevel[stack]=1;}}}}return false;}fn LGL_Ak(siPtr : ptr<function,SurfaceInteraction>,ray : Ray,lightSampleRec : ptr<function,LightSampleRec>,depth: i32,maxDist : f32){(*siPtr).hit=false;var tMax=maxDist;var curDist=0.;
#if ${t.supportLightSource}
for(var i: u32=0;i<sceneUniform.lightNum;i++){var lightData=lights.data[i];if(u32(lightData.visible)==0&&depth==0){continue;}var position=lightData.position;var radius=lightData.radius;var emission=lightData.emission;var area=lightData.area;var p1=lightData.p1;var p2=lightData.p2;var lightType=u32(lightData.lightType);if(lightType==0){var normal=normalize(cross(p1,p2));if(dot(normal,ray.d)>0.){continue;}var plane=vec4f(normal,dot(normal,position));p1*=1.0/dot(p1,p1);p2*=1.0/dot(p2,p2);curDist=rectIntersect(position,p1,p2,plane,ray);if(curDist<0.){curDist=LGL_A;}if(curDist<tMax){tMax=curDist;var cosTheta=dot(-ray.d,normal);var pdf=(curDist*curDist)/(area*cosTheta);(*lightSampleRec).emission=emission;(*lightSampleRec).pdf=pdf;(*siPtr).hit=true;(*siPtr).isEmitter=true;}}}
#endif
var nodesToVisit : array<i32,LGL_L>;var nodesLevel : array<i32,LGL_L>;nodesToVisit[0]=0;nodesLevel[0]=0;var invDirWorld=1./ray.d;var invDirLocal=vec3f(1.);var tlasMatID: u32=0;var tlasMeshID: u32=0;var tlasTransMat: mat4x4<f32>;var tlasTransMatInverse: mat4x4<f32>;var rayTrans:Ray;rayTrans.o=ray.o;rayTrans.d=ray.d;var throughBLASMark=false;var stack : i32=0;while(stack>=0&&stack<LGL_L){var i=nodesToVisit[stack];var level=nodesLevel[stack];stack--;if(throughBLASMark&&i==-1){throughBLASMark=false;rayTrans.o=ray.o;rayTrans.d=ray.d;continue;}if(level==0){var tlasNode=tlasNodes[i];var typeFlag=tlasNode.typeFlag;if(typeFlag==1.){let visible=u32(tlasNode.meshInfoOraabbMax.x);if(visible==0){continue;}let instanceID=i32(tlasNode.idInfoOrAABBMin.z);tlasTransMat=tlasTransNodes[instanceID].LGL_sMat;tlasTransMatInverse=tlasTransNodes[instanceID].LGL_rMat;rayTrans.o=(tlasTransMatInverse*vec4f(ray.o,1.0)).xyz;rayTrans.d=(tlasTransMatInverse*vec4f(ray.d,0.0)).xyz;invDirLocal=1./rayTrans.d;stack++;throughBLASMark=true;nodesToVisit[stack]=-1;nodesLevel[stack]=-1;stack++;let blasNodeIndex=i32(tlasNode.idInfoOrAABBMin.x);nodesToVisit[stack]=blasNodeIndex;nodesLevel[stack]=1;tlasMatID=u32(tlasNode.idInfoOrAABBMin.y);tlasMeshID=u32(tlasNode.idInfoOrAABBMin.z);}else{let aabbMin=tlasNode.idInfoOrAABBMin;let aabbMax=tlasNode.meshInfoOraabbMax;if(LGL_q(rayTrans,aabbMin,aabbMax,invDirWorld,tMax)){stack++;nodesToVisit[stack]=i+1;nodesLevel[stack]=0;stack++;nodesToVisit[stack]=i32(tlasNode.nextPtr);nodesLevel[stack]=0;}}}else{var blasNode=blasNodes[i];var typeFlag=blasNode.typeFlag;if(typeFlag==1.){let triIndices=vec3<u32>(blasNode.indicesOrMin);let tri=LGL_Ah(triIndices);let hit=LGL_Ai(rayTrans,tri,tMax);if(hit.t>0.){(*siPtr).hit=true;(*siPtr).t=hit.t;(*siPtr).isEmitter=false;tMax=hit.t;(*siPtr).matID=tlasMatID;(*siPtr).meshID=tlasMeshID;LGL_Aj(siPtr,tri,hit.barycentric,triIndices);(*siPtr).position=(tlasTransMat*vec4((*siPtr).position,1.0)).xyz;let inverseNormalMat=transpose(mat3x3(tlasTransMatInverse[0].xyz,tlasTransMatInverse[1].xyz,tlasTransMatInverse[2].xyz));(*siPtr).normal=normalize(inverseNormalMat*(*siPtr).normal);(*siPtr).faceNormal=normalize(inverseNormalMat*(*siPtr).faceNormal);(*siPtr).normal=(*siPtr).normal*sign(dot((*siPtr).normal,(*siPtr).faceNormal));(*siPtr).ffnormal=select(-(*siPtr).normal,(*siPtr).normal,dot((*siPtr).faceNormal,ray.d)<0.0);(*siPtr).eta=select(principledBSDFMaterial.ior,(1.0/principledBSDFMaterial.ior),dot((*siPtr).normal,(*siPtr).ffnormal)>0.0);}}else{let aabbMin=blasNode.indicesOrMin;let aabbMax=blasNode.aabbMax;if(LGL_q(rayTrans,aabbMin,aabbMax,invDirLocal,tMax)){stack++;nodesToVisit[stack]=i+1;nodesLevel[stack]=1;stack++;nodesToVisit[stack]=i32(blasNode.nextPtr);nodesLevel[stack]=1;}}}}return;}`;var wt=(e,t)=>e`fn LGL_Ad(triIndex : u32)->vec3<u32>{return vec3<u32>(indices[triIndex][0],indices[triIndex][1],indices[triIndex][2]);}fn LGL_Al(ray : Ray,maxDist : f32)->bool{var tMax=maxDist;var nodesToVisit : array<i32,LGL_L>;nodesToVisit[0]=0;let invDir=1./ray.d;let maxDepth: i32=20;var stack : i32=0;while(stack>=0&&stack<maxDepth){var i=nodesToVisit[stack];stack--;var childAIndex=bvhNodes[i].childA;var childBIndex=bvhNodes[i].childB;if(LGL_q(ray,bvhNodes[childAIndex].aabbMin,bvhNodes[childAIndex].aabbMax,invDir,tMax)){var triIndicesID=bvhNodes[childAIndex].triIndicesID;if(triIndicesID!=0xFFFFFFFF){var materialID=bvhNodes[childAIndex].materialID;
#if ${t.supportCastShadow}
var castShadow=getMatCastShadow(materialID);if(castShadow==0.){return false;}
#endif
let triIndices=LGL_Ad(triIndicesID);let tri=LGL_Ah(triIndices);let hit=LGL_Ai(ray,tri,tMax);if(hit.t>0.){
#if ${t.supportAlphaShadow}
let alpha=surfaceMaterialAlphaFromBVH(materialID,hit.barycentric,triIndices);if(rand()>alpha){return false;}
#endif
return true;}}else{stack++;nodesToVisit[stack]=i32(childAIndex);}}if(LGL_q(ray,bvhNodes[childBIndex].aabbMin,bvhNodes[childBIndex].aabbMax,invDir,tMax)){var triIndicesID=bvhNodes[childBIndex].triIndicesID;if(triIndicesID!=0xFFFFFFFF){var materialID=bvhNodes[childBIndex].materialID;
#if ${t.supportCastShadow}
var castShadow=getMatCastShadow(materialID);if(castShadow==0.){return false;}
#endif
let triIndices=LGL_Ad(triIndicesID);let tri=LGL_Ah(triIndices);let hit=LGL_Ai(ray,tri,tMax);if(hit.t>0.){
#if ${t.supportAlphaShadow}
let alpha=surfaceMaterialAlphaFromBVH(materialID,hit.barycentric,triIndices);if(rand()>alpha){return false;}
#endif
return true;}}else{stack++;nodesToVisit[stack]=i32(childBIndex);}}}return false;}fn LGL_Ak(siPtr : ptr<function,SurfaceInteraction>,ray : Ray,lightSampleRec : ptr<function,LightSampleRec>,depth: i32,maxDist : f32){(*siPtr).hit=false;var tMax=maxDist;var curDist=0.;
#if ${t.supportLightSource}
for(var i: u32=0;i<sceneUniform.lightNum;i++){var lightData=lights.data[i];if(u32(lightData.visible)==0&&depth==0){continue;}var position=lightData.position;var radius=lightData.radius;var emission=lightData.emission;var area=lightData.area;var p1=lightData.p1;var p2=lightData.p2;var lightType=u32(lightData.lightType);if(lightType==0){var normal=normalize(cross(p1,p2));if(dot(normal,ray.d)>0.){continue;}var plane=vec4f(normal,dot(normal,position));p1*=1.0/dot(p1,p1);p2*=1.0/dot(p2,p2);curDist=rectIntersect(position,p1,p2,plane,ray);if(curDist<0.){curDist=LGL_A;}if(curDist<tMax){tMax=curDist;var cosTheta=dot(-ray.d,normal);var pdf=(curDist*curDist)/(area*cosTheta);(*lightSampleRec).emission=emission;(*lightSampleRec).pdf=pdf;(*siPtr).hit=true;(*siPtr).isEmitter=true;}}}
#endif
var nodesToVisit : array<i32,LGL_L>;nodesToVisit[0]=0;let invDir=1./ray.d;var stack : i32=0;while(stack>=0&&stack<LGL_L){var i=nodesToVisit[stack];stack--;var childAIndex=bvhNodes[i].childA;var childBIndex=bvhNodes[i].childB;if(LGL_q(ray,bvhNodes[childAIndex].aabbMin,bvhNodes[childAIndex].aabbMax,invDir,tMax)){var triIndicesID=bvhNodes[childAIndex].triIndicesID;if(triIndicesID!=0xFFFFFFFF){let triIndices=LGL_Ad(triIndicesID);let tri=LGL_Ah(triIndices);let hit=LGL_Ai(ray,tri,tMax);if(hit.t>0.){(*siPtr).hit=true;(*siPtr).t=hit.t;(*siPtr).isEmitter=false;tMax=hit.t;(*siPtr).matID=bvhNodes[childAIndex].materialID;(*siPtr).meshID=bvhNodes[childBIndex].childA;LGL_Aj(siPtr,tri,hit.barycentric,triIndices);(*siPtr).normal=(*siPtr).normal*sign(dot((*siPtr).normal,(*siPtr).faceNormal));(*siPtr).ffnormal=select(-(*siPtr).normal,(*siPtr).normal,dot((*siPtr).faceNormal,ray.d)<0.0);(*siPtr).eta=select(principledBSDFMaterial.ior,(1.0/principledBSDFMaterial.ior),dot((*siPtr).normal,(*siPtr).ffnormal)>0.0);}}else{stack++;nodesToVisit[stack]=i32(childAIndex);}}if(LGL_q(ray,bvhNodes[childBIndex].aabbMin,bvhNodes[childBIndex].aabbMax,invDir,tMax)){var triIndicesID=bvhNodes[childBIndex].triIndicesID;if(triIndicesID!=0xFFFFFFFF){let triIndices=LGL_Ad(triIndicesID);let tri=LGL_Ah(triIndices);let hit=LGL_Ai(ray,tri,tMax);if(hit.t>0.){(*siPtr).hit=true;(*siPtr).t=hit.t;(*siPtr).isEmitter=false;tMax=hit.t;(*siPtr).matID=bvhNodes[childBIndex].materialID;(*siPtr).meshID=bvhNodes[childBIndex].childA;LGL_Aj(siPtr,tri,hit.barycentric,triIndices);(*siPtr).normal=(*siPtr).normal*sign(dot((*siPtr).normal,(*siPtr).faceNormal));(*siPtr).ffnormal=select(-(*siPtr).normal,(*siPtr).normal,dot((*siPtr).faceNormal,ray.d)<0.0);(*siPtr).eta=select(principledBSDFMaterial.ior,(1.0/principledBSDFMaterial.ior),dot((*siPtr).normal,(*siPtr).ffnormal)>0.0);}}else{stack++;nodesToVisit[stack]=i32(childBIndex);}}}return;}`;var It=(e,t)=>e`const MAX_LIGHT_COUNT: u32=16;struct Lights{data: array<Light,MAX_LIGHT_COUNT>,};struct Light{position: vec3<f32>,radius: f32,emission: vec3<f32>,area: f32,p1: vec3<f32>,lightType: f32,p2: vec3<f32>,visible: f32,};`;var zt=(e,t)=>e`fn sampleAreaLight(light: Light,surfacePos: vec3f,lightSampleRec : ptr<function,LightSampleRec>,random: vec2f){var r1=random.x-0.5;var r2=random.x-0.5;var lightSurfacePos=light.position+light.p1*r1+light.p2*r2;(*lightSampleRec).direction=lightSurfacePos-surfacePos;(*lightSampleRec).dist=length((*lightSampleRec).direction);var distSq=(*lightSampleRec).dist*(*lightSampleRec).dist;(*lightSampleRec).direction/=(*lightSampleRec).dist;(*lightSampleRec).normal=normalize(cross(light.p1,light.p2));(*lightSampleRec).emission=light.emission*f32(sceneUniform.lightNum);(*lightSampleRec).pdf=distSq/(light.area*abs(dot((*lightSampleRec).normal,(*lightSampleRec).direction)));}fn sampleDirectionLight(light: Light,surfacePos: vec3f,lightSampleRec : ptr<function,LightSampleRec>){(*lightSampleRec).direction=normalize(light.position-light.p1);(*lightSampleRec).normal=normalize(surfacePos-light.position);if(dot((*lightSampleRec).direction,(*lightSampleRec).normal)>0.0){(*lightSampleRec).normal=-(*lightSampleRec).normal;}(*lightSampleRec).emission=light.emission*f32(sceneUniform.lightNum);(*lightSampleRec).dist=LGL_A;(*lightSampleRec).pdf=1.0;}fn samplePointLight(light: Light,surfacePos: vec3f,lightSampleRec : ptr<function,LightSampleRec>){(*lightSampleRec).direction=light.position-surfacePos;(*lightSampleRec).dist=length((*lightSampleRec).direction);var distSq=(*lightSampleRec).dist*(*lightSampleRec).dist;(*lightSampleRec).direction=normalize((*lightSampleRec).direction);(*lightSampleRec).normal=normalize(surfacePos-light.position);(*lightSampleRec).emission=light.emission*f32(sceneUniform.lightNum)/distSq;(*lightSampleRec).pdf=1.0;}fn getSpotAttenuation(coneCosine: f32,penumbraCosine: f32,angleCosine: f32)->f32{return smoothstep(coneCosine,penumbraCosine,angleCosine);}fn sampleSpotLight(light: Light,surfacePos: vec3f,lightSampleRec : ptr<function,LightSampleRec>){(*lightSampleRec).direction=light.position-surfacePos;(*lightSampleRec).dist=length((*lightSampleRec).direction);(*lightSampleRec).direction=normalize((*lightSampleRec).direction);(*lightSampleRec).normal=normalize(light.p1);var cosTheta=dot(normalize(surfacePos-light.position),(*lightSampleRec).normal);var distSq=pow((*lightSampleRec).dist,light.p2.z);var spotAttenuation=getSpotAttenuation(light.p2.x,light.p2.y,cosTheta);(*lightSampleRec).emission=light.emission*spotAttenuation*f32(sceneUniform.lightNum)/distSq;(*lightSampleRec).pdf=1.0;}fn sampleOneLight(light: Light,surfacePos: vec3f,lightSampleRec : ptr<function,LightSampleRec>,random: vec2f){var lightType=i32(light.lightType);if(lightType==0){sampleAreaLight(light,surfacePos,lightSampleRec,random);}else if(lightType==1){sampleDirectionLight(light,surfacePos,lightSampleRec);}else if(lightType==2){samplePointLight(light,surfacePos,lightSampleRec);}else if(lightType==3){sampleSpotLight(light,surfacePos,lightSampleRec);}}`;var Wt=(e,t)=>e`struct FrameUniform{viewToWorldMat : mat4x4<f32>,clipToViewMat : mat4x4<f32>,sampleCount: u32,strataSize: f32,jitter: vec2<f32>,cameraAperture: f32,cameraFocus: f32,}struct SceneUniform{envRotMatrix : mat3x3<f32>,invEnvRotMatrix : mat3x3<f32>,backgroundColor : vec3<f32>,envMapIntensity: f32,renderSize: vec2<u32>,bounces: i32,enableBackgroundColor: u32,backgroundAlpha: f32,totalSumValue: f32,lightNum: u32}struct TileUniform{tileOffset: vec2<u32>,tileSize: vec2<u32>,tileEnable: u32}`;var Xt=(e,t)=>e`fn LGL_Aq(si : SurfaceInteraction,basis : Basis,winputL : vec3<f32>,s1 : vec2<f32>,s2 : vec2<f32>)->vec3<f32>{var surfacePos=si.position+LGL_J*si.ffnormal;var Li=vec3<f32>(0.0);var bsdfSampleRec : BSDFSampleRec;var bsdfPDF : f32;var woutputL : vec3<f32>;var woutputW : vec3<f32>;var uv : vec2<f32>;var lightPdf : f32;woutputW=sceneUniform.invEnvRotMatrix*LGL_Y(s1,&uv,&lightPdf);woutputL=LGL_r(woutputW,basis);var ray=Ray(surfacePos,woutputW);if(!LGL_Al(ray,LGL_A-EPS)){var irr=textureSampleLevel(envMap,texSampler,uv,0.).rgb*sceneUniform.envMapIntensity;bsdfSampleRec.f=LGL_Ac(si,principledBSDFMaterial,winputL,woutputL,&bsdfPDF)*abs(woutputL.z);bsdfSampleRec.pdf=bsdfPDF;if(bsdfSampleRec.pdf>0.0){var misWeight=LGL_l(lightPdf,bsdfSampleRec.pdf);if(misWeight>0.0){Li+=misWeight*bsdfSampleRec.f*irr/lightPdf;}}}
#if ${t.supportLightSource}
var lightSampleRec: LightSampleRec;var i=i32(s2.x*f32(sceneUniform.lightNum));var lightData=lights.data[i];var light=Light(lightData.position,lightData.radius,lightData.emission,lightData.area,lightData.p1,lightData.lightType,lightData.p2,lightData.visible);sampleOneLight(light,surfacePos,&lightSampleRec,s2);if(dot(lightSampleRec.direction,lightSampleRec.normal)<0.0){var ray=Ray(surfacePos,lightSampleRec.direction);if(!LGL_Al(ray,lightSampleRec.dist-EPS)){woutputW=lightSampleRec.direction;woutputL=LGL_r(woutputW,basis);bsdfSampleRec.f=LGL_Ac(si,principledBSDFMaterial,winputL,woutputL,&bsdfPDF)*abs(woutputL.z);bsdfSampleRec.pdf=bsdfPDF;var misWeight=1.0;if(light.area>0.0&&bsdfSampleRec.pdf>0.0){misWeight=LGL_l(lightSampleRec.pdf,bsdfSampleRec.pdf);}if(misWeight>0.0){Li+=misWeight*bsdfSampleRec.f*lightSampleRec.emission/lightSampleRec.pdf;}}}
#endif
return Li;}`;var Ct=(e,t)=>e`fn LGL_As(pathPt : ptr<function,Path>,siIn : SurfaceInteraction,depth : i32,bsdfSampleRecPt: ptr<function,BSDFSampleRec>,lightSampleRec: LightSampleRec){var si=siIn;var bsdfSampleL : vec3<f32>;var bsdfSamplePDF : f32;if(!si.hit){var envSampleDir=sceneUniform.envRotMatrix*(*pathPt).ray.d;if(depth==0){(*pathPt).li+=select(LGL_V(envSampleDir)*sceneUniform.envMapIntensity,sceneUniform.backgroundColor,sceneUniform.enableBackgroundColor==1);(*pathPt).alpha=sceneUniform.backgroundAlpha;(*pathPt).abort=true;return;}var irr=LGL_V(envSampleDir)*sceneUniform.envMapIntensity;var misWeightEnv=1.0;let lightPdf=LGL_X(envSampleDir);misWeightEnv=LGL_l((*bsdfSampleRecPt).pdf,lightPdf);if(misWeightEnv>0.){(*pathPt).li+=misWeightEnv*irr*(*pathPt).beta;}(*pathPt).abort=true;return;}if(si.isEmitter){(*pathPt).li+=EmitterSample((*pathPt).ray,depth,lightSampleRec,*bsdfSampleRecPt)*(*pathPt).beta;(*pathPt).abort=true;return;}var basis=LGL_p(si.ffnormal);var wiW=-(*pathPt).ray.d;var wiL=LGL_r(wiW,basis);var LGL_fs=LGL_g();(*pathPt).li+=(*pathPt).beta*principledBSDFMaterial.emissiveColor;
#if ${t.enableSSS}
var Cspec0 : vec3<f32>;var Csheen : vec3<f32>;LGL_AZ(principledBSDFMaterial,si.eta,&Cspec0,&Csheen);var sssWt=LGL_AG(principledBSDFMaterial,Cspec0);var sssPath=(rand()<sssWt);if(sssPath){var basis=LGL_p(si.normal);var siExit: SurfaceInteraction;var throughput: vec3<f32>;var sssLightSampleRec : LightSampleRec;var hit=LGL_AH(si,principledBSDFMaterial,basis,LGL_fs.s1,LGL_fs.s2,&throughput,&siExit,&sssLightSampleRec);if(!hit){(*pathPt).abort=true;return;}si=siExit;(*pathPt).beta*=throughput;var normalExit=siExit.normal;var basisExit=LGL_p(normalExit);var bsdfSamplePDF: f32;var dirExitL=LGL_iWithPDF(LGL_fs.s3.x,LGL_fs.s3.y,&bsdfSamplePDF);(*bsdfSampleRecPt).pdf=bsdfSamplePDF;(*bsdfSampleRecPt).L=LGL_s(dirExitL,basisExit);(*bsdfSampleRecPt).f=abs(dot((*bsdfSampleRecPt).L,normalExit))*principledBSDFMaterial.color/LGL_B;(*pathPt).li+=LGL_AI(siExit,principledBSDFMaterial,basisExit,LGL_fs.s1,LGL_fs.s4)*(*pathPt).beta;(*pathPt).beta*=sssWt;}else{
#endif
#if ${t.supportAbsorption}
if(dot(si.normal,si.ffnormal)>0.0){(*pathPt).absorption=vec3(0.0);}(*pathPt).beta*=exp(-(*pathPt).absorption*si.t);
#endif
(*pathPt).li+=LGL_Aq(si,basis,wiL,LGL_fs.s1,LGL_fs.s2)*(*pathPt).beta;if(depth==(sceneUniform.bounces-1)){(*pathPt).abort=true;return;}(*bsdfSampleRecPt).f=LGL_Ab(si,principledBSDFMaterial,basis,LGL_fs.s3,wiL,si.ffnormal,&bsdfSampleL,&bsdfSamplePDF);(*bsdfSampleRecPt).L=bsdfSampleL;(*bsdfSampleRecPt).pdf=bsdfSamplePDF;
#if ${t.supportAbsorption}
let inDielectric : bool=dot(si.ffnormal,(*bsdfSampleRecPt).L)<0.0;if(inDielectric){(*pathPt).absorption=-log(principledBSDFMaterial.extinction)/principledBSDFMaterial.atDistance;}
#endif
(*pathPt).beta*=abs(dot(si.ffnormal,bsdfSampleL));
#if ${t.enableSSS}
(*pathPt).beta*=(1.-sssWt);}
#endif
if((*bsdfSampleRecPt).pdf>0.0){(*pathPt).beta*=(*bsdfSampleRecPt).f/(*bsdfSampleRecPt).pdf;}else{(*pathPt).abort=true;return;}if(depth>=2){let q=1.0-LGL_M((*pathPt).beta);if(LGL_fs.s4.x<q){(*pathPt).abort=true;return;}(*pathPt).beta/=1.0-q;}(*pathPt).ray=Ray(si.position+LGL_J*(*bsdfSampleRecPt).L,(*bsdfSampleRecPt).L);}fn LGL_Ar(ray : Ray)->vec4<f32>{var path : Path;var si : SurfaceInteraction;var bsdfSampleRec : BSDFSampleRec;var lightSampleRec : LightSampleRec;path.ray=ray;path.li=vec3<f32>(0.0);path.alpha=1.0;path.abort=false;path.misWeight=1.0;path.absorption=vec3<f32>(0.0);path.beta=vec3<f32>(1.0);var LGL_Am: u32=0;for(var i : i32=0;i<sceneUniform.bounces;i++){if(path.abort){return vec4<f32>(path.li,path.alpha);}LGL_Ak(&si,path.ray,&lightSampleRec,i,LGL_A);
#if ${t.supportAlpha&&"Mesh"==t.geoType}
if(si.hit&&!si.isEmitter&&principledBSDFMaterial.alpha<1.0&&LGL_Am<MAX_ALPHA_DEPTH){if(rand()>principledBSDFMaterial.alpha){path.ray.o=si.position+EPS*path.ray.d;LGL_Am++;i--;continue;}}
#endif
LGL_As(&path,si,i,&bsdfSampleRec,lightSampleRec);}return vec4<f32>(path.li,path.alpha);}@compute @workgroup_size(8,8,1)fn main(@builtin(global_invocation_id)GlobalInvocationID : vec3<u32>){let screenSize=sceneUniform.renderSize;var screenPos=GlobalInvocationID.xy;if(any(GlobalInvocationID.xy>screenSize)){return;}if(tileUniform.tileEnable==1){if(any(GlobalInvocationID.xy>=tileUniform.tileSize)){return;}screenPos+=tileUniform.tileOffset;}var vCoord=vec2f(screenPos)/vec2f(screenSize);vCoord=vCoord+frameUniform.jitter;let sampleCount=frameUniform.sampleCount;LGL_c(sampleCount,vCoord,screenSize);LGL_Z(sampleCount,vCoord,screenSize);var vCoordAntiAlias=(vCoord-0.5)*2.0;var origin=LGL_o(vCoordAntiAlias);var direction : vec3f;if(frameUniform.clipToViewMat[2].w==0.){direction=-frameUniform.viewToWorldMat[2].xyz;}else{direction=normalize(mat3x3(frameUniform.viewToWorldMat[0].xyz,frameUniform.viewToWorldMat[1].xyz,frameUniform.viewToWorldMat[2].xyz)*(frameUniform.clipToViewMat*vec4(vCoordAntiAlias,0.0,1.0)).xyz);}if(frameUniform.cameraAperture>0.0){var focusPoint=origin+frameUniform.cameraFocus*normalize(direction);var lensPoint=frameUniform.cameraAperture*LGL_h(vec2f(rand()));origin=(frameUniform.viewToWorldMat*vec4f(lensPoint,0.0,1.0)).xyz;direction=normalize(focusPoint-origin);}var cam=Ray(origin,direction);var Li=LGL_Ar(cam);if(!(Li.x<LGL_A&&Li.x>-EPS)){Li=vec4<f32>(0.,0.,0.,1.);}if(sampleCount>0){var accColor=textureLoad(accumulateTex,screenPos,0);Li=(Li+accColor*f32(sampleCount))/f32(sampleCount+1);}textureStore(lightTex,screenPos,Li);}`;var Ft=()=>"@binding(0)@group(0)var<uniform>uniforms : Uniforms;@binding(1)@group(0)var<uniform>meshUniforms : MeshUniforms;struct Uniforms{cameraViewMatrix: mat4x4<f32>,cameraProjViewMatrix : mat4x4<f32>,renderSize: vec2<u32>}struct MeshUniforms{LGL_sMat: mat4x4<f32>,normalMat: mat3x3<f32>,meshID : u32,matID: u32,}struct VertexOutput{@builtin(position)position : vec4<f32>,@location(0)vPosition : vec3<f32>,@location(1)vNormal : vec3<f32>,@location(2)vUv : vec2<f32>,};@vertex fn main(@location(0)position : vec3<f32>,@location(1)normal : vec3<f32>,@location(2)uv : vec2<f32>,)->VertexOutput{var output : VertexOutput;var mvPosition=meshUniforms.LGL_sMat*vec4f(position,1.);output.position=uniforms.cameraProjViewMatrix*mvPosition;output.vPosition=mvPosition.xyz;output.vNormal=normalize(meshUniforms.normalMat*normal);output.vUv=uv;return output;}";var At=(e,t)=>e`@binding(0)@group(0)var<uniform>uniforms : Uniforms;@binding(1)@group(0)var<uniform>meshUniforms : MeshUniforms;@binding(2)@group(0)var<storage,read>materials : array<Material>;@binding(3)@group(0)var textureArray : texture_2d_array<f32>;@binding(4)@group(0)var texSampler : sampler;
#if ${t.supportUVTrans||t.supportTexWrap}
@binding(5)@group(0)var<storage,read>texUVTrans : array<TexUVTrans>;
#endif
fn hash8bit(a : u32)->u32{return(a ^(a>>8))<<24;}struct Uniforms{cameraViewMatrix: mat4x4<f32>,cameraProjViewMatrix : mat4x4<f32>,renderSize: vec2<u32>}struct MeshUniforms{LGL_sMat: mat4x4<f32>,normalMat: mat3x3<f32>,meshID : u32,matID: u32,}struct VertexOutput{@location(0)vPosition : vec3<f32>,@location(1)vNormal : vec3<f32>,@location(2)vUv : vec2<f32>,};struct FragmentOutput{@location(0)colorOut : vec4<f32>,@location(1)normalOut : vec4<f32>,};fn encodeNormal(norIn: vec3<f32>)->u32{var nor=norIn;nor/=max(max(abs(nor.x),abs(nor.y)),abs(nor.z));let v=0.5+0.5*nor;let d=vec3<u32>(round(v*vec3<f32>(2047.0,1023.0,2047.0)));return d.x|(d.y<<11u)|(d.z<<21u);}fn getFaceNormal(position: vec3<f32>)->vec3<f32>{return normalize(cross(dpdy(position),dpdx(position)));}@fragment fn main(vo : VertexOutput)->FragmentOutput{var output : FragmentOutput;var uv=vo.vUv;let position=vo.vPosition;let matID=meshUniforms.matID;let meshID=meshUniforms.meshID;let color=LGL_AO(matID,uv);output.colorOut=color;let dp1 : vec3<f32>=dpdx(position);let dp2 : vec3<f32>=dpdy(position);let duv1 : vec2<f32>=dpdx(uv);let duv2 : vec2<f32>=dpdy(uv);let faceNormal: vec3<f32>=getFaceNormal(position);var normal=vo.vNormal;output.normalOut=vec4f(LGL_AS(matID,uv,normal,faceNormal,dp1,dp2,duv1,duv2),1.);return output;}`;const Dt=new Map,Nt=class{constructor(e,t,r){this.device=e,this.context=t,this.rg=r,this._bindGroupCache={},this.cameraProjViewMatrix=new n}async createPipeline(e,t,r){const{device:s,rg:i}=this;this.sceneInfo=t,this.renderSetting=e,this.camera=r;const a={size:ht.getStride(),usage:ht.RES_USAGE};this.frameUniformBuffer=i.resourcePool.getOrCreateResource("GBufferPassframeUniformBuffer",a).raw,this.initMeshUniformBuffer();let n=i.getRenderPipeline(Nt.ID);n||(n=await s.createRenderPipelineAsync({layout:"auto",vertex:{module:s.createShaderModule({code:Ft()}),entryPoint:"main",buffers:[{arrayStride:3*Float32Array.BYTES_PER_ELEMENT,attributes:[{shaderLocation:0,offset:0,format:"float32x3"}]},{arrayStride:3*Float32Array.BYTES_PER_ELEMENT,attributes:[{shaderLocation:1,offset:0,format:"float32x3"}]},{arrayStride:2*Float32Array.BYTES_PER_ELEMENT,attributes:[{shaderLocation:2,offset:0,format:"float32x2"}]}]},fragment:{module:s.createShaderModule({code:ut`
						${bt(ut,e)}
						${Mt(ut,e)}
						${Tt(ut,e)}
						${At(ut,e)}
						`}),entryPoint:"main",targets:[{format:"rgba8unorm"},{format:"rgba8unorm"}]},primitive:{topology:"triangle-list"},depthStencil:{depthWriteEnabled:!0,depthCompare:"less",format:"depth24plus"}}),i.setRenderPipeline(Nt.ID,"",n)),this.pipeline=n}setSize(){const{rg:e,device:t,context:r,renderSetting:s}=this,i={size:{width:r.width,height:r.height},format:"rgba8unorm",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ};this.outputColorGBuffer=t.createTexture(i),this.outputNormalGBuffer=t.createTexture(i),e.resourcePool.updateResource("GBufferOutputColorTexture",this.outputColorGBuffer,"Texture"),e.resourcePool.updateResource("GBufferOutputNormalTexture",this.outputNormalGBuffer,"Texture")}forceUpdateBG(){this._bindGroupCache={}}destroy(){Array.from(Dt.values()).forEach((e=>e.destroy()))}updateUniform(e){if(this.camera=e,!this.frameUniformBuffer)return;const{device:t,renderSetting:r}=this;this.cameraProjViewMatrix.multiply(e.viewToClipMat,e.worldToViewMat);const s=new ht({cameraViewMatrix:e.worldToViewMat,cameraProjViewMatrix:this.cameraProjViewMatrix,renderSize:r.renderSize}).toArrayBuffer();t.queue.writeBuffer(this.frameUniformBuffer,0,s)}initMeshUniformBuffer(){const{device:e}=this;let{meshes:t}=this.sceneInfo;t=t.filter((e=>!e.tlasMask));const r={size:pt.getStride(),usage:pt.RES_USAGE};t.forEach(((t,s)=>{if(Dt.get(t.id))return;const i=e.createBuffer(r);this.updateMeshUniformBuffer(i,t,s),Dt.set(t.id,i)}))}updateMeshUniformBuffer(e,t,r){const{device:s}=this,{materialIndexMap:i}=this.sceneInfo,a=(new l).getNormalMatrix(t.localToWorldMat).toWebGPUFormat(),n=new pt({localToWorldMat:t.localToWorldMat,normalMat:a,meshID:r,matID:i.get(t.material)}).toArrayBuffer();s.queue.writeBuffer(e,0,n)}getBindGroup(e,t){const{device:r,pipeline:s}=this;if(this._bindGroupCache[e])return this._bindGroupCache[e];const{settingBuffer:i,meshUniformBuffer:a,material:n,textureArray:o,sampler:l,uvTrans:u}=t,c=[{binding:0,resource:{buffer:i}},{binding:1,resource:{buffer:a}},{binding:2,resource:{buffer:n}},{binding:3,resource:o.createView()},{binding:4,resource:l}];(this.renderSetting.supportUVTrans||this.renderSetting.supportTexWrap)&&c.push({binding:5,resource:{buffer:u}});const d=r.createBindGroup({layout:s.getBindGroupLayout(0),entries:c});return this._bindGroupCache[e]=d,d}setup(e,t,r){const{context:s,renderSetting:i}=this,a={};a.position=t.read(e.importResource(xr)),a.uv=t.read(e.importResource(br)),a.normal=t.read(e.importResource(vr)),a.indices=t.read(e.importResource(yr)),a.settingBuffer=t.read(e.importResource("GBufferPassframeUniformBuffer")),a.material=t.read(e.importResource(Gr)),a.textureArray=t.read(e.importResource(_r)),a.samplers=["llr"],(i.supportUVTrans||i.supportTexWrap)&&(a.uvTrans=t.read(e.importResource(Pr))),a.output=t.write(e,e.importResource("GBufferOutputColorTexture")),a.outputNormal=t.write(e,e.importResource("GBufferOutputNormalTexture"));const n={size:{width:s.width,height:s.height},format:"depth24plus",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING};let o=e.createTexture("GBufferDepthTexture",n,!0);a.outputDepth=t.write(e,o),r.data=a,t.hasSideEffect=!0}execute(e,t,r,s){const i=t.data,a=e.getRenderPipeline(t.name,""),n=e.getPassRawResFromPool(i.output),o=e.getPassRawResFromPool(i.outputNormal),l=e.getPassRawResFromPool(i.outputDepth),u=s.beginRenderPass({colorAttachments:[{view:n.createView(),clearValue:{r:0,g:0,b:0,a:1},loadOp:"clear",storeOp:"store"},{view:o.createView(),clearValue:{r:0,g:0,b:0,a:1},loadOp:"clear",storeOp:"store"}],depthStencilAttachment:{view:l.createView(),depthClearValue:1,depthLoadOp:"clear",depthStoreOp:"store"}}),c=e.getPassRawResFromPool(i.position),d=e.getPassRawResFromPool(i.normal),h=e.getPassRawResFromPool(i.uv),p=e.getPassRawResFromPool(i.indices),f=e.getPassRawResFromPool(i.settingBuffer),m=e.getPassRawResFromPool(i.material),g=e.getPassRawResFromPool(i.textureArray),x=e.samplers[i.samplers[0]],b=e.getPassRawResFromPool(i.uvTrans);let{meshes:v,geometryInfo:L}=this.sceneInfo;const{geometryIndexMap:y,geoInfoSplitIndex:S}=L,M=Float32Array.BYTES_PER_ELEMENT;this.camera.updateFrustum(),v=v.filter((e=>!e.tlasMask)),v.forEach(((e,t)=>{if(!e.visible)return;const r=Dt.get(e.id);if(!r)return void console.error("Need build meshUniformBuffer first");if(!this.camera.frustumIntersectsMesh(e))return;this.updateMeshUniformBuffer(r,e,t);const s=e.geometry,i=y.get(s),{vertexSplitIndex:n,indicesSplitIndex:o}=S[i],l=n*M;u.setVertexBuffer(0,c,l,s.position.array.length*M),u.setVertexBuffer(1,d,l,s.normal.array.length*M),u.setVertexBuffer(2,h,l/3*2,s.uv.array.length*M),u.setIndexBuffer(p,"uint32",o*M,s.indices.array.length*M),u.setPipeline(a);const v=this.getBindGroup(e.id,{settingBuffer:f,meshUniformBuffer:r,material:m,textureArray:g,sampler:x,uvTrans:b});u.setBindGroup(0,v),u.drawIndexed(s.indices.count,1,0,0)})),u.end()}};let Vt=Nt;Vt.ID="GBufferPass";class Ut{constructor(e){this.device=e}async debugBufferContent(e,t,r=Uint32Array){const{device:s}=this,i=s.createCommandEncoder();this.debugBuffer=s.createBuffer({size:t,usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST}),i.copyBufferToBuffer(e,0,this.debugBuffer,0,t),s.queue.submit([i.finish()]),await s.queue.onSubmittedWorkDone(),await this.debugBuffer.mapAsync(GPUMapMode.READ);const a=new r(this.debugBuffer.getMappedRange()),n=Array.from(a);return console.log(n),this.debugBuffer.unmap(),n}}var Et=()=>"@group(0)@binding(0)var inputTex : texture_2d<f32>;@group(0)@binding(1)var<uniform>setting : Setting;@group(0)@binding(2)var accumulateTex : texture_storage_2d<rgba32float,write>;@group(0)@binding(3)var outputTex : texture_storage_2d<rgba16float,write>;struct Setting{renderSize: vec2<u32>,}@compute @workgroup_size(8,8,1)fn main(@builtin(global_invocation_id)GlobalInvocationID : vec3<u32>){let screenSize=setting.renderSize;if(any(GlobalInvocationID.xy>screenSize)){return;}let screenPos=vec2<i32>(i32(GlobalInvocationID.x),i32(GlobalInvocationID.y));var color=textureLoad(inputTex,screenPos,0);textureStore(accumulateTex,screenPos,color);textureStore(outputTex,screenPos,color);}";const kt=class{constructor(e,t,r){this.device=e,this.context=t,this.rg=r}async createPipeline(e){this.renderSetting=e;const{rg:t}=this;this.settingBuffer=new V(t,"PTAccumulatePassSettingBuffer","u32",2),this.renderSizeVal=[...e.renderSize],this.settingBuffer.setData(0,e.renderSize[0]),this.settingBuffer.setData(1,e.renderSize[1]),this.settingBuffer.submit(),await t.getOrCreateComputePipeline(kt.ID,"",Et())}syncRenderSetting(e){this.renderSetting=e}syncRenderSize(){const{settingBuffer:e,renderSizeVal:t,renderSetting:r}=this,s=r.renderSize;t[0]==s[0]&&t[1]==s[1]||(this.renderSizeVal=[...s],e.setData(0,s[0]),e.setData(1,s[1]),e.submit())}setup(e,t,r){const{context:s}=this,i={},a=e.getPass(Zt.ID);i.input=t.read(a.data.output),i.settingBuffer=t.read(e.importResource("PTAccumulatePassSettingBuffer")),i.accumulate=t.write(e,a.data.accumulate);let n=e.createTexture("AccumulateOutputTexture",{size:{width:s.width,height:s.height},format:"rgba16float",usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING},!0);i.output=t.write(e,n),r.data=i}execute(e,t,r,s){const{renderSetting:i}=this,a=e.getComputePipeline(t.name,""),n=e.getBindGroup(t.name,a,r,t.data),{renderSize:o}=i,l=s.beginComputePass();l.setPipeline(a),l.setBindGroup(0,n),l.dispatchWorkgroups(Math.ceil(o[0]/8),Math.ceil(o[1]/8)),l.end()}};let Kt=kt;Kt.ID="PTAccumulatePass";const Ht=class{constructor(e,t,r){this.device=e,this.context=t,this.rg=r,this.tileSetting={},this.tileSetting.enable=Z}getPipelineCacheKey(e){const t={geoType:e.geoType,sceneMode:e.sceneMode,integrator:e.integrator,enableSSS:e.enableSSS,enableVolume:e.enableVolume,enableAtomsphere:e.enableAtomsphere};return JSON.stringify(Object.values(t))}async createPipeline(e){this.renderSetting=e;const{rg:t}=this,r=function(e){let t=[];if(t.push("var noiseTex : texture_2d<f32>;","var<uniform> frameUniform : FrameUniform;","var<uniform> sceneUniform : SceneUniform;","var<uniform> tileUniform : TileUniform;","var<uniform> stratifiedSamples : StratifiedSamplesUniforms;"),e.supportLightSource&&t.push("var<uniform> lights : Lights;"),t.push("var accumulateTex : texture_2d<f32>;"),"Mesh"==e.geoType){const r=["var<storage, read> position : array<array<f32, 3>>;","var<storage, read> normal : array<array<f32, 3>>;","var<storage, read> uv : array<array<f32, 2>>;"];"Static"==e.sceneMode?r.push("var<storage, read> indices : array<array<u32, 3>>;","var<storage, read> bvhNodes : array<BVHNode>;"):r.push("var<storage, read> tlasNodes : array<TLASNode>;","var<storage, read> blasNodes : array<BLASNode>;","var<storage, read> tlasTransNodes : array<TLASTransNode>;"),r.push("var<storage, read> materials : array<Material>;","var textureArray : texture_2d_array<f32>;"),(e.supportUVTrans||e.supportTexWrap)&&r.push("var<storage, read> texUVTrans : array<TexUVTrans>;"),t.push(...r)}t.push("var envMap : texture_2d<f32>;","var envMarginalWeights : texture_2d<f32>;","var envConditionalWeights : texture_2d<f32>;"),t.push("var lightTex : texture_storage_2d<rgba32float, write>;"),t.push("var texSampler : sampler;","var noiseSampler : sampler;");let r=function(e){let t="";for(let r=0;r<e.length;r++)t+=`@group(0) @binding(${r}) ${e[r]}\n`;return t}(t);return ut`
		${r}

		${bt(ut,e)}
		${vt(ut,e)}
		${Lt(ut,e)}
		${yt(ut,e)}

		${Wt(ut,e)}

		${St(ut,e)}

		#if ${e.supportLightSource}
		${It(ut,e)}
		${zt(ut,e)}
		#endif

		${Mt(ut,e)}
		${Tt(ut,e)}
		${Gt(ut,e)}
		${_t(ut,e)}
		${Pt(ut,e)}

		${Bt(ut,e)}
		
		#if ${"Static"===e.sceneMode}
		${wt(ut,e)}
		#else
		${Rt(ut,e)}
		#endif

		${Xt(ut,e)}
		${Ct(ut,e)}
		`}(e),s=this.getPipelineCacheKey(e);await t.getOrCreateComputePipeline(Ht.ID,s,r)}syncTileRenderSetting(e,t,r,s,i){this.tileSetting={enable:e,tileXOffset:t,tileYOffset:r,tileWidth:s,tileHeight:i}}syncRenderSetting(e){this.renderSetting=e}setup(e,t,r){const{context:s,renderSetting:i}=this,a={},n=e.createTexture("NoiseTexture");a.noise=t.read(n),a.frameUniform=t.read(e.importResource(ft.RES_NAME)),a.sceneUniform=t.read(e.importResource(mt.RES_NAME)),a.tileUniform=t.read(e.importResource(gt.RES_NAME)),a.stratifiedSamples=t.read(e.importResource("StratifiedSamplesBuffer")),i.supportLightSource&&(a.light=t.read(e.importResource(Br)));const o=e.createTexture("PTAccumulateTexture",{size:{width:s.width,height:s.height},format:"rgba32float",usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING},!0);a.accumulate=t.read(o),a.position=t.read(e.importResource(xr)),a.normal=t.read(e.importResource(vr)),a.uv=t.read(e.importResource(br)),"Static"==i.sceneMode?(a.indices=t.read(e.importResource(yr)),a.bvh=t.read(e.importResource(Lr))):(a.tlas=t.read(e.importResource(Sr)),a.blas=t.read(e.importResource(Mr)),a.tlasTrans=t.read(e.importResource(Tr))),a.material=t.read(e.importResource(Gr)),a.textureArray=t.read(e.importResource(_r)),(i.supportUVTrans||i.supportTexWrap)&&(a.uvTrans=t.read(e.importResource(Pr))),a.envMap=t.read(e.importResource(Be.ENVMAP_RES_NAME)),a.envMarginalWeights=t.read(e.importResource(Be.ENVMAP_MARGINAL_WEIGHTS_RES_NAME)),a.envConditionalWeights=t.read(e.importResource(Be.ENVMAP_CONDITIONAL_WEIGHTS_RES_NAME));const l=e.createTexture("RTLightTexture",{size:{width:s.width,height:s.height},format:"rgba32float",usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING},!0);a.output=t.write(e,l),a.samplers=["llc","nnr"],a.pipelineCacheKey=this.getPipelineCacheKey(i),r.data=a}execute(e,t,r,s){const{renderSetting:i,tileSetting:a}=this,n=e.getComputePipeline(t.name,t.data.pipelineCacheKey),o=e.getBindGroup(t.name,n,r,t.data),l=s.beginComputePass();l.setPipeline(n),l.setBindGroup(0,o);const{renderSize:u}=i,{enable:c,tileHeight:d,tileWidth:h}=a;c?l.dispatchWorkgroups(Math.ceil(h/8),Math.ceil(d/8)):l.dispatchWorkgroups(Math.ceil(u[0]/8),Math.ceil(u[1]/8)),l.end()}};let Zt=Ht;Zt.ID="PTPass";class Ot{constructor(e){this.device=e,this.radixSorter=new qe(e),this.assignMortonPass=new Qe(e),this.constructNodesPass=new $e(e),this.internalNodePass=new tt(e),this.buildAABBPass=new st(e),this.debugPass=new Ut(e)}calcAABB(e){const t=e.array,r=new w,s=new B;for(let i=0;i<e.count;i++)s.set(t[3*i],t[3*i+1],t[3*i+2]),r.min.min(s),r.max.max(s);return r}async build(e){const{device:t}=this,{position:r,uv:s,normal:i,indices:a,materialMeshIndex:n}=e.geometry,o=a.count/3,l=this.calcAABB(e.geometry.position);this.sceneAABBBuffer||(this.sceneAABBBuffer=new Ze(t)),this.sceneAABBBuffer.set(l,o),this.positionBuffer=t.createBuffer({mappedAtCreation:!0,size:r.array.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.VERTEX});new Float32Array(this.positionBuffer.getMappedRange()).set(r.array,0),this.positionBuffer.unmap(),this.uvBuffer=t.createBuffer({mappedAtCreation:!0,size:s.array.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.VERTEX});new Float32Array(this.uvBuffer.getMappedRange()).set(s.array,0),this.uvBuffer.unmap(),this.normalBuffer=t.createBuffer({mappedAtCreation:!0,size:i.array.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.VERTEX});new Float32Array(this.normalBuffer.getMappedRange()).set(i.array,0),this.normalBuffer.unmap(),this.indicesBuffer=t.createBuffer({mappedAtCreation:!0,size:a.array.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.INDEX});new Uint32Array(this.indicesBuffer.getMappedRange()).set(a.array,0),this.indicesBuffer.unmap(),this.materialMeshIndexBuffer=t.createBuffer({mappedAtCreation:!0,size:n.array.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.VERTEX});new Uint32Array(this.materialMeshIndexBuffer.getMappedRange()).set(n.array,0),this.materialMeshIndexBuffer.unmap();const u=4*this.radixSorter.getAlignedSize(o);this.mortonBuffer=t.createBuffer({size:u,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC}),this.idBuffer=t.createBuffer({size:u,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC});const c=48*(2*o-1);if(c>=Math.min(t.limits.maxBufferSize,t.limits.maxStorageBufferBindingSize))return void console.error("The total size of loaded models exceeds the browser limit!");this.bvhNodesBuffer=t.createBuffer({size:c,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC}),await this.assignMortonPass.compute(o,this.positionBuffer,this.indicesBuffer,this.sceneAABBBuffer.buffer,this.mortonBuffer,this.idBuffer),await this.radixSorter.sort(this.mortonBuffer,this.idBuffer,o),await this.constructNodesPass.compute(o,this.idBuffer,this.positionBuffer,this.indicesBuffer,this.materialMeshIndexBuffer,this.bvhNodesBuffer),await this.internalNodePass.compute(o,this.mortonBuffer,this.idBuffer,this.bvhNodesBuffer);const d=Math.ceil(Math.log2(o));for(let h=1;h<=d;h++)await this.buildAABBPass.compute(h,o,this.bvhNodesBuffer);return this.mortonBuffer.destroy(),this.idBuffer.destroy(),{positionBuffer:this.positionBuffer,uvBuffer:this.uvBuffer,normalBuffer:this.normalBuffer,indicesBuffer:this.indicesBuffer,bvhNodesBuffer:this.bvhNodesBuffer,materialMeshIndexBuffer:this.materialMeshIndexBuffer}}destory(){this.sceneAABBBuffer.destroy(),this.mortonBuffer.destroy(),this.idBuffer.destroy()}}function Yt(e,t,r=0,s=e.length,i=Math.floor((r+s)/2)){for(let a=r;a<=i;a++){let r=a,i=e[a];for(let n=a+1;n<s;n++)t(i,e[n])||(r=n,i=e[n],qt(e,a,r))}}function qt(e,t,r){const s=e[r];e[r]=e[t],e[t]=s}let Jt,Qt=0,jt=0,$t=0,er=!1;const tr=new B;function rr(e,t){return{primitives:e,bounds:t}}function sr(e,t,r){let s=r[t]-e.min[t];return e.max[t]>e.min[t]&&(s/=e.max[t]-e.min[t]),s}function ir(e){return e.getSize(tr),2*(tr.x*tr.z+tr.x*tr.y+tr.z*tr.y)}function ar(e,t,r,s=!1){const i=new w;for(let u=t;u<r;u++)i.union(e[u].bounds);if(er){$t+=1,Jt(($t+jt)/Qt)}const a=r-t;if(1===a)return rr(e.slice(t,r),i);{const u=new w;for(let s=t;s<r;s++)u.expandByPoint(e[s].center);const c=(u.getSize(tr),tr.x>tr.z?tr.x>tr.y?"x":"y":tr.z>tr.y?"z":"y");let d=Math.floor((t+r)/2);if(a<=4)Yt(e,((e,t)=>e.center[c]<t.center[c]),t,r,d);else if(u.max[c]===u.min[c]){if(!s)return rr(e.slice(t,r),i);Yt(e,((e,t)=>e.center[c]<t.center[c]),t,r,d)}else{const s=12,a=[];for(let e=0;e<s;e++)a.push({bounds:new w,count:0});for(let i=t;i<r;i++){let t=Math.floor(s*sr(u,c,e[i].center));t===a.length&&(t=a.length-1),a[t].count++,a[t].bounds.union(e[i].bounds)}const n=[];for(let e=0;e<a.length-1;e++){const t=new w,r=new w;let s=0,o=0;for(let i=0;i<=e;i++)t.union(a[i].bounds),s+=a[i].count;for(let i=e+1;i<a.length;i++)r.union(a[i].bounds),o+=a[i].count;n.push(.1+(s*ir(t)+o*ir(r))/ir(i))}let o=n[0],l=0;for(let e=1;e<n.length;e++)n[e]<o&&(o=n[e],l=e);d=function(e,t,r=0,s=e.length){for(;r!==s;){for(;t(e[r]);)if(++r===s)return r;do{if(r===--s)return r}while(!t(e[s]));qt(e,r,s),r++}return r}(e,(e=>{let t=Math.floor(a.length*sr(u,c,e.center));return t===a.length&&(t=a.length-1),t<=l}),t,r)}return n=c,o=ar(e,t,d,s),l=ar(e,d,r,s),{child0:o,child1:l,bounds:(new w).union(o.bounds).union(l.bounds),splitAxis:n}}var n,o,l}function nr(e){const t=new Float32Array(32*e.length);for(let r=0;r<e.length;r++){const s=e[r],i=s.localToWorldMat,a=s.worldToLocalMat;for(let e=0;e<16;e++)t[32*r+e]=i[e],t[32*r+16+e]=a[e]}return t}function or(e,t,r){const s=function(e,t,r){const s=[];for(let i=0;i<e.length;i++){const a=e[i],{material:n,geometry:o}=a,l=new w;l.copy(o.aabb).applyMatrix4(a.localToWorldMat);const u={bounds:l,center:l.getCenter(new B),meshID:i,geometryID:t.get(o),materialID:r.get(n),visible:a.visible};s.push(u)}return s}(e,t,r);er=!1;return ar(s,0,s.length,!0)}function lr(e,t,r){const{primitiveInfoArr:s}=function(e,t=0){let r=t;const s=[];for(let i=0;i<e.length;i++){const t=[],a=e[i],n=a.indices,o=a.position,l=new B,u=new B,c=new B;for(let e=0;e<n.array.length;e+=3){const s=n.array[e],i=n.array[e+1],a=n.array[e+2],d=new w,h=3,p=s*h;l.x=o.array[p],l.y=o.array[p+1],l.z=o.array[p+2];const f=i*h;u.x=o.array[f],u.y=o.array[f+1],u.z=o.array[f+2];const m=a*h;c.x=o.array[m],c.y=o.array[m+1],c.z=o.array[m+2],d.expandByPoint(l),d.expandByPoint(u),d.expandByPoint(c);const g={bounds:d,center:d.getCenter(new B),indices:[s+r,i+r,a+r]};t.push(g)}r+=a.position.array.length/3,s.push(t)}return{primitiveInfoArr:s}}(e,r),i=[];if(t){Qt=0,jt=0,er=!0,Jt=t;for(let e=0;e<s.length;e++)Qt+=2*s[e].length-1}for(let a=0;a<s.length;a++){const e=s[a];$t=0;const t=ar(e,0,e.length);jt+=2*e.length-1,i.push(t)}return{blasBVHs:i}}function ur(e,t=0,r=[]){const s=[];let i=1;const a={x:3,y:4,z:5},n=(e,o=1)=>{if(i=Math.max(o,i),e.primitives){const t=e;for(let e=0;e<t.primitives.length;e++){const i=t.primitives[e];if(void 0!==i.indices){const e=i;s.push(e.indices[0],e.indices[1],e.indices[2],1,0,0,0,0)}else{const e=i;s.push(r[e.geometryID],e.materialID,e.meshID,1,Number(e.visible),0,0,0)}}}else{const r=e,i=r.bounds;s.push(i.min.x,i.min.y,i.min.z,a[r.splitAxis],i.max.x,i.max.y,i.max.z,0);const l=s.length-1;n(r.child0,o+1),s[l]=s.length/8+t,n(r.child1,o+1)}};return n(e),{count:s.length/8,maxDepth:i,flatData:s}}function cr(e,t){return ur(e,0,t)}function dr(e,t=0){const r=[];let s=[],i=1;for(let a=0;a<e.length;a++){const n=ur(e[a],t);i=Math.max(n.maxDepth,i),s.push(t),t+=n.count,r.push(n)}return{blasBufferSplitIndex:s,totalBLASDataLength:8*t,totalBLASDataCount:t,flatBVHInfos:r,maxDepth:i}}const hr="IWZ1bmN0aW9uKCl7InVzZSBzdHJpY3QiO2NvbnN0IHQ9MWUtNjtmdW5jdGlvbiBuKHQpe3JldHVybiB0WzBdPTEsdFsxXT0wLHRbMl09MCx0WzNdPTAsdFs0XT0wLHRbNV09MSx0WzZdPTAsdFs3XT0wLHRbOF09MCx0WzldPTAsdFsxMF09MSx0WzExXT0wLHRbMTJdPTAsdFsxM109MCx0WzE0XT0wLHRbMTVdPTEsdH1mdW5jdGlvbiBpKHQsbixpKXtsZXQgcz1uWzBdLGU9blsxXSxyPW5bMl0saD1uWzNdLG89bls0XSxhPW5bNV0sdT1uWzZdLGw9bls3XSxjPW5bOF0sbT1uWzldLGY9blsxMF0seD1uWzExXSx5PW5bMTJdLHA9blsxM10sZz1uWzE0XSxNPW5bMTVdLGQ9aVswXSx6PWlbMV0sdz1pWzJdLGI9aVszXTtyZXR1cm4gdFswXT1kKnMreipvK3cqYytiKnksdFsxXT1kKmUreiphK3cqbStiKnAsdFsyXT1kKnIreip1K3cqZitiKmcsdFszXT1kKmgreipsK3cqeCtiKk0sZD1pWzRdLHo9aVs1XSx3PWlbNl0sYj1pWzddLHRbNF09ZCpzK3oqbyt3KmMrYip5LHRbNV09ZCplK3oqYSt3Km0rYipwLHRbNl09ZCpyK3oqdSt3KmYrYipnLHRbN109ZCpoK3oqbCt3KngrYipNLGQ9aVs4XSx6PWlbOV0sdz1pWzEwXSxiPWlbMTFdLHRbOF09ZCpzK3oqbyt3KmMrYip5LHRbOV09ZCplK3oqYSt3Km0rYipwLHRbMTBdPWQqcit6KnUrdypmK2IqZyx0WzExXT1kKmgreipsK3cqeCtiKk0sZD1pWzEyXSx6PWlbMTNdLHc9aVsxNF0sYj1pWzE1XSx0WzEyXT1kKnMreipvK3cqYytiKnksdFsxM109ZCplK3oqYSt3Km0rYipwLHRbMTRdPWQqcit6KnUrdypmK2IqZyx0WzE1XT1kKmgreipsK3cqeCtiKk0sdH1mdW5jdGlvbiBzKHQsbil7bGV0IGk9blswXStuWzVdK25bMTBdLHM9MDtyZXR1cm4gaT4wPyhzPTIqTWF0aC5zcXJ0KGkrMSksdFszXT0uMjUqcyx0WzBdPShuWzZdLW5bOV0pL3MsdFsxXT0obls4XS1uWzJdKS9zLHRbMl09KG5bMV0tbls0XSkvcyk6blswXT5uWzVdJiZuWzBdPm5bMTBdPyhzPTIqTWF0aC5zcXJ0KDErblswXS1uWzVdLW5bMTBdKSx0WzNdPShuWzZdLW5bOV0pL3MsdFswXT0uMjUqcyx0WzFdPShuWzFdK25bNF0pL3MsdFsyXT0obls4XStuWzJdKS9zKTpuWzVdPm5bMTBdPyhzPTIqTWF0aC5zcXJ0KDErbls1XS1uWzBdLW5bMTBdKSx0WzNdPShuWzhdLW5bMl0pL3MsdFswXT0oblsxXStuWzRdKS9zLHRbMV09LjI1KnMsdFsyXT0obls2XStuWzldKS9zKToocz0yKk1hdGguc3FydCgxK25bMTBdLW5bMF0tbls1XSksdFszXT0oblsxXS1uWzRdKS9zLHRbMF09KG5bOF0rblsyXSkvcyx0WzFdPShuWzZdK25bOV0pL3MsdFsyXT0uMjUqcyksdH1mdW5jdGlvbiBlKHQsbil7bGV0IGk9blswXSxzPW5bMV0sZT1uWzJdLHI9blszXSxoPWkraSxvPXMrcyxhPWUrZSx1PWkqaCxsPXMqaCxjPXMqbyxtPWUqaCxmPWUqbyx4PWUqYSx5PXIqaCxwPXIqbyxnPXIqYTtyZXR1cm4gdFswXT0xLWMteCx0WzFdPWwrZyx0WzJdPW0tcCx0WzNdPTAsdFs0XT1sLWcsdFs1XT0xLXUteCx0WzZdPWYreSx0WzddPTAsdFs4XT1tK3AsdFs5XT1mLXksdFsxMF09MS11LWMsdFsxMV09MCx0WzEyXT0wLHRbMTNdPTAsdFsxNF09MCx0WzE1XT0xLHR9ZnVuY3Rpb24gcih0LG4saSl7cmV0dXJuIHRbMF09blswXStpWzBdLHRbMV09blsxXStpWzFdLHRbMl09blsyXStpWzJdLHR9ZnVuY3Rpb24gaCh0LG4saSl7cmV0dXJuIHRbMF09blswXS1pWzBdLHRbMV09blsxXS1pWzFdLHRbMl09blsyXS1pWzJdLHR9ZnVuY3Rpb24gbyh0LG4saSl7cmV0dXJuIHRbMF09blswXSppLHRbMV09blsxXSppLHRbMl09blsyXSppLHR9ZnVuY3Rpb24gYSh0LG4pe2xldCBpPW5bMF0scz1uWzFdLGU9blsyXSxyPWkqaStzKnMrZSplO3JldHVybiByPjAmJihyPTEvTWF0aC5zcXJ0KHIpLHRbMF09blswXSpyLHRbMV09blsxXSpyLHRbMl09blsyXSpyKSx0fWZ1bmN0aW9uIHUodCxuKXtyZXR1cm4gdFswXSpuWzBdK3RbMV0qblsxXSt0WzJdKm5bMl19bmV3IGNsYXNzIGV4dGVuZHMgQXJyYXl7Y29uc3RydWN0b3IodD0xLG49MCxpPTAscz0wLGU9MCxyPTEsaD0wLG89MCxhPTAsdT0wLGw9MSxjPTAsbT0wLGY9MCx4PTAseT0xKXtyZXR1cm4gc3VwZXIodCxuLGkscyxlLHIsaCxvLGEsdSxsLGMsbSxmLHgseSksdGhpc31nZXQgaXNNYXRyaXg0KCl7cmV0dXJuITB9c2V0IHgodCl7dGhpc1sxMl09dH1nZXQgeCgpe3JldHVybiB0aGlzWzEyXX1zZXQgeSh0KXt0aGlzWzEzXT10fWdldCB5KCl7cmV0dXJuIHRoaXNbMTNdfXNldCB6KHQpe3RoaXNbMTRdPXR9Z2V0IHooKXtyZXR1cm4gdGhpc1sxNF19c2V0IHcodCl7dGhpc1sxNV09dH1nZXQgdygpe3JldHVybiB0aGlzWzE1XX1zZXQodCxuLGkscyxlLHIsaCxvLGEsdSxsLGMsbSxmLHgseSl7cmV0dXJuIHQubGVuZ3RoP3RoaXMuY29weSh0KTooZnVuY3Rpb24odCxuLGkscyxlLHIsaCxvLGEsdSxsLGMsbSxmLHgseSxwKXt0WzBdPW4sdFsxXT1pLHRbMl09cyx0WzNdPWUsdFs0XT1yLHRbNV09aCx0WzZdPW8sdFs3XT1hLHRbOF09dSx0WzldPWwsdFsxMF09Yyx0WzExXT1tLHRbMTJdPWYsdFsxM109eCx0WzE0XT15LHRbMTVdPXB9KHRoaXMsdCxuLGkscyxlLHIsaCxvLGEsdSxsLGMsbSxmLHgseSksdGhpcyl9dHJhbnNsYXRlKHQsbj10aGlzKXtyZXR1cm4gZnVuY3Rpb24odCxuLGkpe2xldCBzLGUscixoLG8sYSx1LGwsYyxtLGYseCx5PWlbMF0scD1pWzFdLGc9aVsyXTtuPT09dD8odFsxMl09blswXSp5K25bNF0qcCtuWzhdKmcrblsxMl0sdFsxM109blsxXSp5K25bNV0qcCtuWzldKmcrblsxM10sdFsxNF09blsyXSp5K25bNl0qcCtuWzEwXSpnK25bMTRdLHRbMTVdPW5bM10qeStuWzddKnArblsxMV0qZytuWzE1XSk6KHM9blswXSxlPW5bMV0scj1uWzJdLGg9blszXSxvPW5bNF0sYT1uWzVdLHU9bls2XSxsPW5bN10sYz1uWzhdLG09bls5XSxmPW5bMTBdLHg9blsxMV0sdFswXT1zLHRbMV09ZSx0WzJdPXIsdFszXT1oLHRbNF09byx0WzVdPWEsdFs2XT11LHRbN109bCx0WzhdPWMsdFs5XT1tLHRbMTBdPWYsdFsxMV09eCx0WzEyXT1zKnkrbypwK2MqZytuWzEyXSx0WzEzXT1lKnkrYSpwK20qZytuWzEzXSx0WzE0XT1yKnkrdSpwK2YqZytuWzE0XSx0WzE1XT1oKnkrbCpwK3gqZytuWzE1XSl9KHRoaXMsbix0KSx0aGlzfXJvdGF0ZVgodCxuPXRoaXMpe3JldHVybiBmdW5jdGlvbih0LG4saSl7bGV0IHM9TWF0aC5zaW4oaSksZT1NYXRoLmNvcyhpKSxyPW5bNF0saD1uWzVdLG89bls2XSxhPW5bN10sdT1uWzhdLGw9bls5XSxjPW5bMTBdLG09blsxMV07biE9PXQmJih0WzBdPW5bMF0sdFsxXT1uWzFdLHRbMl09blsyXSx0WzNdPW5bM10sdFsxMl09blsxMl0sdFsxM109blsxM10sdFsxNF09blsxNF0sdFsxNV09blsxNV0pLHRbNF09ciplK3Uqcyx0WzVdPWgqZStsKnMsdFs2XT1vKmUrYypzLHRbN109YSplK20qcyx0WzhdPXUqZS1yKnMsdFs5XT1sKmUtaCpzLHRbMTBdPWMqZS1vKnMsdFsxMV09bSplLWEqc30odGhpcyxuLHQpLHRoaXN9cm90YXRlWSh0LG49dGhpcyl7cmV0dXJuIGZ1bmN0aW9uKHQsbixpKXtsZXQgcz1NYXRoLnNpbihpKSxlPU1hdGguY29zKGkpLHI9blswXSxoPW5bMV0sbz1uWzJdLGE9blszXSx1PW5bOF0sbD1uWzldLGM9blsxMF0sbT1uWzExXTtuIT09dCYmKHRbNF09bls0XSx0WzVdPW5bNV0sdFs2XT1uWzZdLHRbN109bls3XSx0WzEyXT1uWzEyXSx0WzEzXT1uWzEzXSx0WzE0XT1uWzE0XSx0WzE1XT1uWzE1XSksdFswXT1yKmUtdSpzLHRbMV09aCplLWwqcyx0WzJdPW8qZS1jKnMsdFszXT1hKmUtbSpzLHRbOF09cipzK3UqZSx0WzldPWgqcytsKmUsdFsxMF09bypzK2MqZSx0WzExXT1hKnMrbSplfSh0aGlzLG4sdCksdGhpc31yb3RhdGVaKHQsbj10aGlzKXtyZXR1cm4gZnVuY3Rpb24odCxuLGkpe2xldCBzPU1hdGguc2luKGkpLGU9TWF0aC5jb3MoaSkscj1uWzBdLGg9blsxXSxvPW5bMl0sYT1uWzNdLHU9bls0XSxsPW5bNV0sYz1uWzZdLG09bls3XTtuIT09dCYmKHRbOF09bls4XSx0WzldPW5bOV0sdFsxMF09blsxMF0sdFsxMV09blsxMV0sdFsxMl09blsxMl0sdFsxM109blsxM10sdFsxNF09blsxNF0sdFsxNV09blsxNV0pLHRbMF09ciplK3Uqcyx0WzFdPWgqZStsKnMsdFsyXT1vKmUrYypzLHRbM109YSplK20qcyx0WzRdPXUqZS1yKnMsdFs1XT1sKmUtaCpzLHRbNl09YyplLW8qcyx0WzddPW0qZS1hKnN9KHRoaXMsbix0KSx0aGlzfXNjYWxlKHQsbj10aGlzKXtyZXR1cm4gZnVuY3Rpb24odCxuLGkpe2xldCBzPWlbMF0sZT1pWzFdLHI9aVsyXTt0WzBdPW5bMF0qcyx0WzFdPW5bMV0qcyx0WzJdPW5bMl0qcyx0WzNdPW5bM10qcyx0WzRdPW5bNF0qZSx0WzVdPW5bNV0qZSx0WzZdPW5bNl0qZSx0WzddPW5bN10qZSx0WzhdPW5bOF0qcix0WzldPW5bOV0qcix0WzEwXT1uWzEwXSpyLHRbMTFdPW5bMTFdKnIsdFsxMl09blsxMl0sdFsxM109blsxM10sdFsxNF09blsxNF0sdFsxNV09blsxNV19KHRoaXMsbiwibnVtYmVyIj09dHlwZW9mIHQ/W3QsdCx0XTp0KSx0aGlzfW11bHRpcGx5KHQsbil7cmV0dXJuIG4/aSh0aGlzLHQsbik6aSh0aGlzLHRoaXMsdCksdGhpc31pZGVudGl0eSgpe3JldHVybiBuKHRoaXMpLHRoaXN9Y29weSh0KXt2YXIgbixpO3JldHVybiBpPXQsKG49dGhpcylbMF09aVswXSxuWzFdPWlbMV0sblsyXT1pWzJdLG5bM109aVszXSxuWzRdPWlbNF0sbls1XT1pWzVdLG5bNl09aVs2XSxuWzddPWlbN10sbls4XT1pWzhdLG5bOV09aVs5XSxuWzEwXT1pWzEwXSxuWzExXT1pWzExXSxuWzEyXT1pWzEyXSxuWzEzXT1pWzEzXSxuWzE0XT1pWzE0XSxuWzE1XT1pWzE1XSx0aGlzfWZyb21QZXJzcGVjdGl2ZSh7Zm92OnQsYXNwZWN0Om4sbmVhcjppLGZhcjpzfT17fSl7cmV0dXJuIGZ1bmN0aW9uKHQsbixpLHMsZSl7bGV0IHI9MS9NYXRoLnRhbihuLzIpLGg9MS8ocy1lKTt0WzBdPXIvaSx0WzFdPTAsdFsyXT0wLHRbM109MCx0WzRdPTAsdFs1XT1yLHRbNl09MCx0WzddPTAsdFs4XT0wLHRbOV09MCx0WzEwXT0oZStzKSpoLHRbMTFdPS0xLHRbMTJdPTAsdFsxM109MCx0WzE0XT0yKmUqcypoLHRbMTVdPTB9KHRoaXMsdCxuLGkscyksdGhpc31mcm9tT3J0aG9nb25hbCh7bGVmdDp0LHJpZ2h0Om4sYm90dG9tOmksdG9wOnMsbmVhcjplLGZhcjpyfSl7cmV0dXJuIGZ1bmN0aW9uKHQsbixpLHMsZSxyLGgpe2xldCBvPTEvKG4taSksYT0xLyhzLWUpLHU9MS8oci1oKTt0WzBdPS0yKm8sdFsxXT0wLHRbMl09MCx0WzNdPTAsdFs0XT0wLHRbNV09LTIqYSx0WzZdPTAsdFs3XT0wLHRbOF09MCx0WzldPTAsdFsxMF09Mip1LHRbMTFdPTAsdFsxMl09KG4raSkqbyx0WzEzXT0oZStzKSphLHRbMTRdPShoK3IpKnUsdFsxNV09MX0odGhpcyx0LG4saSxzLGUsciksdGhpc31mcm9tUXVhdGVybmlvbih0KXtyZXR1cm4gZSh0aGlzLHQpLHRoaXN9c2V0UG9zaXRpb24odCl7cmV0dXJuIHRoaXMueD10WzBdLHRoaXMueT10WzFdLHRoaXMuej10WzJdLHRoaXN9dHJhbnNwb3NlKHQ9dGhpcyl7cmV0dXJuIGZ1bmN0aW9uKHQsbil7aWYodD09PW4pe2xldCBpPW5bMV0scz1uWzJdLGU9blszXSxyPW5bNl0saD1uWzddLG89blsxMV07dFsxXT1uWzRdLHRbMl09bls4XSx0WzNdPW5bMTJdLHRbNF09aSx0WzZdPW5bOV0sdFs3XT1uWzEzXSx0WzhdPXMsdFs5XT1yLHRbMTFdPW5bMTRdLHRbMTJdPWUsdFsxM109aCx0WzE0XT1vfWVsc2UgdFswXT1uWzBdLHRbMV09bls0XSx0WzJdPW5bOF0sdFszXT1uWzEyXSx0WzRdPW5bMV0sdFs1XT1uWzVdLHRbNl09bls5XSx0WzddPW5bMTNdLHRbOF09blsyXSx0WzldPW5bNl0sdFsxMF09blsxMF0sdFsxMV09blsxNF0sdFsxMl09blszXSx0WzEzXT1uWzddLHRbMTRdPW5bMTFdLHRbMTVdPW5bMTVdfSh0aGlzLHQpLHRoaXN9aW52ZXJzZSh0PXRoaXMpe3JldHVybiBmdW5jdGlvbih0LG4pe2xldCBpPW5bMF0scz1uWzFdLGU9blsyXSxyPW5bM10saD1uWzRdLG89bls1XSxhPW5bNl0sdT1uWzddLGw9bls4XSxjPW5bOV0sbT1uWzEwXSxmPW5bMTFdLHg9blsxMl0seT1uWzEzXSxwPW5bMTRdLGc9blsxNV0sTT1pKm8tcypoLGQ9aSphLWUqaCx6PWkqdS1yKmgsdz1zKmEtZSpvLGI9cyp1LXIqbyx2PWUqdS1yKmEscT1sKnktYyp4LEE9bCpwLW0qeCxCPWwqZy1mKngsST1jKnAtbSp5LFA9YypnLWYqeSxTPW0qZy1mKnAsRD1NKlMtZCpQK3oqSSt3KkItYipBK3YqcTtEJiYoRD0xL0QsdFswXT0obypTLWEqUCt1KkkpKkQsdFsxXT0oZSpQLXMqUy1yKkkpKkQsdFsyXT0oeSp2LXAqYitnKncpKkQsdFszXT0obSpiLWMqdi1mKncpKkQsdFs0XT0oYSpCLWgqUy11KkEpKkQsdFs1XT0oaSpTLWUqQityKkEpKkQsdFs2XT0ocCp6LXgqdi1nKmQpKkQsdFs3XT0obCp2LW0qeitmKmQpKkQsdFs4XT0oaCpQLW8qQit1KnEpKkQsdFs5XT0ocypCLWkqUC1yKnEpKkQsdFsxMF09KHgqYi15KnorZypNKSpELHRbMTFdPShjKnotbCpiLWYqTSkqRCx0WzEyXT0obypBLWgqSS1hKnEpKkQsdFsxM109KGkqSS1zKkErZSpxKSpELHRbMTRdPSh5KmQteCp3LXAqTSkqRCx0WzE1XT0obCp3LWMqZCttKk0pKkQpfSh0aGlzLHQpLHRoaXN9Y29tcG9zZSh0LG4saSl7cmV0dXJuIGZ1bmN0aW9uKHQsbixpLHMpe2xldCBlPW5bMF0scj1uWzFdLGg9blsyXSxvPW5bM10sYT1lK2UsdT1yK3IsbD1oK2gsYz1lKmEsbT1lKnUsZj1lKmwseD1yKnUseT1yKmwscD1oKmwsZz1vKmEsTT1vKnUsZD1vKmwsej1zWzBdLHc9c1sxXSxiPXNbMl07dFswXT0oMS0oeCtwKSkqeix0WzFdPShtK2QpKnosdFsyXT0oZi1NKSp6LHRbM109MCx0WzRdPShtLWQpKncsdFs1XT0oMS0oYytwKSkqdyx0WzZdPSh5K2cpKncsdFs3XT0wLHRbOF09KGYrTSkqYix0WzldPSh5LWcpKmIsdFsxMF09KDEtKGMreCkpKmIsdFsxMV09MCx0WzEyXT1pWzBdLHRbMTNdPWlbMV0sdFsxNF09aVsyXSx0WzE1XT0xfSh0aGlzLHQsbixpKSx0aGlzfWdldFJvdGF0aW9uKHQpe3JldHVybiBzKHQsdGhpcyksdGhpc31leHRyYWN0Um90YXRpb24odCl7bGV0IG49W107cmV0dXJuIHMobix0KSxlKHRoaXMsbiksdGhpc31mcm9tUm90YXRpb24obixpKXtyZXR1cm4gZnVuY3Rpb24obixpLHMpe2xldCBlLHIsaCxvPXNbMF0sYT1zWzFdLHU9c1syXSxsPU1hdGguc3FydChvKm8rYSphK3UqdSk7TWF0aC5hYnMobCk8dHx8KGw9MS9sLG8qPWwsYSo9bCx1Kj1sLGU9TWF0aC5zaW4oaSkscj1NYXRoLmNvcyhpKSxoPTEtcixuWzBdPW8qbypoK3IsblsxXT1hKm8qaCt1KmUsblsyXT11Km8qaC1hKmUsblszXT0wLG5bNF09byphKmgtdSplLG5bNV09YSphKmgrcixuWzZdPXUqYSpoK28qZSxuWzddPTAsbls4XT1vKnUqaCthKmUsbls5XT1hKnUqaC1vKmUsblsxMF09dSp1KmgrcixuWzExXT0wLG5bMTJdPTAsblsxM109MCxuWzE0XT0wLG5bMTVdPTEpfSh0aGlzLG4saSksdGhpc31nZXRUcmFuc2xhdGlvbih0KXt2YXIgbixpO3JldHVybiBpPXRoaXMsKG49dClbMF09aVsxMl0sblsxXT1pWzEzXSxuWzJdPWlbMTRdLHRoaXN9Z2V0U2NhbGluZyh0KXtyZXR1cm4gZnVuY3Rpb24odCxuKXtsZXQgaT1uWzBdLHM9blsxXSxlPW5bMl0scj1uWzRdLGg9bls1XSxvPW5bNl0sYT1uWzhdLHU9bls5XSxsPW5bMTBdO3RbMF09TWF0aC5zcXJ0KGkqaStzKnMrZSplKSx0WzFdPU1hdGguc3FydChyKnIraCpoK28qbyksdFsyXT1NYXRoLnNxcnQoYSphK3UqdStsKmwpfSh0LHRoaXMpLHRoaXN9Z2V0TWF4U2NhbGVPbkF4aXMoKXtyZXR1cm4gZnVuY3Rpb24odCl7bGV0IG49dFswXSxpPXRbMV0scz10WzJdLGU9dFs0XSxyPXRbNV0saD10WzZdLG89dFs4XSxhPXRbOV0sdT10WzEwXTtjb25zdCBsPW4qbitpKmkrcypzLGM9ZSplK3IqcitoKmgsbT1vKm8rYSphK3UqdTtyZXR1cm4gTWF0aC5zcXJ0KE1hdGgubWF4KGwsYyxtKSl9KHRoaXMpfWxvb2tBdCh0LG4saSl7cmV0dXJuIGZ1bmN0aW9uKHQsbixpLHMpe2xldCBlPW5bMF0scj1uWzFdLGg9blsyXSxvPXNbMF0sYT1zWzFdLHU9c1syXSxsPWUtaVswXSxjPXItaVsxXSxtPWgtaVsyXSxmPWwqbCtjKmMrbSptO2Y+MCYmKGY9MS9NYXRoLnNxcnQoZiksbCo9ZixjKj1mLG0qPWYpO2xldCB4PWEqbS11KmMseT11KmwtbyptLHA9bypjLWEqbDtmPXgqeCt5KnkrcCpwLGY+MCYmKGY9MS9NYXRoLnNxcnQoZikseCo9Zix5Kj1mLHAqPWYpLHRbMF09eCx0WzFdPXksdFsyXT1wLHRbM109MCx0WzRdPWMqcC1tKnksdFs1XT1tKngtbCpwLHRbNl09bCp5LWMqeCx0WzddPTAsdFs4XT1sLHRbOV09Yyx0WzEwXT1tLHRbMTFdPTAsdFsxMl09ZSx0WzEzXT1yLHRbMTRdPWgsdFsxNV09MX0odGhpcyx0LG4saSksdGhpc31sb29rQXRUYXJnZXQoaSxzLGUpe3JldHVybiBmdW5jdGlvbihpLHMsZSxyKXtsZXQgaCxvLGEsdSxsLGMsbSxmLHgseSxwPXNbMF0sZz1zWzFdLE09c1syXSxkPXJbMF0sej1yWzFdLHc9clsyXSxiPWVbMF0sdj1lWzFdLHE9ZVsyXTtNYXRoLmFicyhwLWIpPHQmJk1hdGguYWJzKGctdik8dCYmTWF0aC5hYnMoTS1xKTx0P24oaSk6KG09cC1iLGY9Zy12LHg9TS1xLHk9MS9NYXRoLnNxcnQobSptK2YqZit4KngpLG0qPXksZio9eSx4Kj15LGg9eip4LXcqZixvPXcqbS1kKngsYT1kKmYteiptLHk9TWF0aC5zcXJ0KGgqaCtvKm8rYSphKSx5Pyh5PTEveSxoKj15LG8qPXksYSo9eSk6KGg9MCxvPTAsYT0wKSx1PWYqYS14Km8sbD14KmgtbSphLGM9bSpvLWYqaCx5PU1hdGguc3FydCh1KnUrbCpsK2MqYykseT8oeT0xL3ksdSo9eSxsKj15LGMqPXkpOih1PTAsbD0wLGM9MCksaVswXT1oLGlbMV09dSxpWzJdPW0saVszXT0wLGlbNF09byxpWzVdPWwsaVs2XT1mLGlbN109MCxpWzhdPWEsaVs5XT1jLGlbMTBdPXgsaVsxMV09MCxpWzEyXT0tKGgqcCtvKmcrYSpNKSxpWzEzXT0tKHUqcCtsKmcrYypNKSxpWzE0XT0tKG0qcCtmKmcreCpNKSxpWzE1XT0xKX0odGhpcyxpLHMsZSksdGhpc31kZXRlcm1pbmFudCgpe3JldHVybiBmdW5jdGlvbih0KXtsZXQgbj10WzBdLGk9dFsxXSxzPXRbMl0sZT10WzNdLHI9dFs0XSxoPXRbNV0sbz10WzZdLGE9dFs3XSx1PXRbOF0sbD10WzldLGM9dFsxMF0sbT10WzExXSxmPXRbMTJdLHg9dFsxM10seT10WzE0XSxwPXRbMTVdO3JldHVybihuKmgtaSpyKSooYypwLW0qeSktKG4qby1zKnIpKihsKnAtbSp4KSsobiphLWUqcikqKGwqeS1jKngpKyhpKm8tcypoKSoodSpwLW0qZiktKGkqYS1lKmgpKih1KnktYypmKSsocyphLWUqbykqKHUqeC1sKmYpfSh0aGlzKX1mcm9tQXJyYXkodCxuPTApe2Zvcih2YXIgaT0wO2k8MTY7aSsrKXRoaXNbaV09dFtpK25dO3JldHVybiB0aGlzfXRvQXJyYXkodD1bXSxuPTApe2xldCBpPXRoaXM7cmV0dXJuIHRbbl09aVswXSx0W24rMV09aVsxXSx0W24rMl09aVsyXSx0W24rM109aVszXSx0W24rNF09aVs0XSx0W24rNV09aVs1XSx0W24rNl09aVs2XSx0W24rN109aVs3XSx0W24rOF09aVs4XSx0W24rOV09aVs5XSx0W24rMTBdPWlbMTBdLHRbbisxMV09aVsxMV0sdFtuKzEyXT1pWzEyXSx0W24rMTNdPWlbMTNdLHRbbisxNF09aVsxNF0sdFtuKzE1XT1pWzE1XSx0fXN0YXRpYyBjb3B5VG8odD1bXSxuPVtdKXt0WzBdPW5bMF0sdFsxXT1uWzFdLHRbMl09blsyXSx0WzNdPW5bM10sdFs0XT1uWzRdLHRbNV09bls1XSx0WzZdPW5bNl0sdFs3XT1uWzddLHRbOF09bls4XSx0WzldPW5bOV0sdFsxMF09blsxMF0sdFsxMV09blsxMV0sdFsxMl09blsxMl0sdFsxM109blsxM10sdFsxNF09blsxNF0sdFsxNV09blsxNV19fTtjbGFzcyBsIGV4dGVuZHMgQXJyYXl7Y29uc3RydWN0b3IodD0wLG49dCxpPXQpe3JldHVybiBzdXBlcih0LG4saSksdGhpcy5jb25zdGFudD0xLHRoaXN9Z2V0IGlzVmVjdG9yMygpe3JldHVybiEwfWdldCB4KCl7cmV0dXJuIHRoaXNbMF19c2V0IHgodCl7dGhpc1swXT10fWdldCB5KCl7cmV0dXJuIHRoaXNbMV19c2V0IHkodCl7dGhpc1sxXT10fWdldCB6KCl7cmV0dXJuIHRoaXNbMl19c2V0IHoodCl7dGhpc1syXT10fXNldCh0LG49dCxpPXQpe3JldHVybiB0Lmxlbmd0aD90aGlzLmNvcHkodCk6KGZ1bmN0aW9uKHQsbixpLHMpe3RbMF09bix0WzFdPWksdFsyXT1zfSh0aGlzLHQsbixpKSx0aGlzKX1jb3B5KHQpe3ZhciBuLGk7cmV0dXJuIGk9dCwobj10aGlzKVswXT1pWzBdLG5bMV09aVsxXSxuWzJdPWlbMl0sdGhpc31hZGQodCxuKXtyZXR1cm4gbj9yKHRoaXMsdCxuKTpyKHRoaXMsdGhpcyx0KSx0aGlzfXN1Yih0LG4pe3JldHVybiBuP2godGhpcyx0LG4pOmgodGhpcyx0aGlzLHQpLHRoaXN9bXVsdGlwbHkodCl7dmFyIG4saSxzO3JldHVybiB0Lmxlbmd0aD8oaT10aGlzLHM9dCwobj10aGlzKVswXT1pWzBdKnNbMF0sblsxXT1pWzFdKnNbMV0sblsyXT1pWzJdKnNbMl0pOm8odGhpcyx0aGlzLHQpLHRoaXN9ZGl2aWRlKHQpe3ZhciBuLGkscztyZXR1cm4gdC5sZW5ndGg/KGk9dGhpcyxzPXQsKG49dGhpcylbMF09aVswXS9zWzBdLG5bMV09aVsxXS9zWzFdLG5bMl09aVsyXS9zWzJdKTpvKHRoaXMsdGhpcywxL3QpLHRoaXN9c2NhbGUodCl7cmV0dXJuIG8odGhpcyx0aGlzLHQpLHRoaXN9ZGlzdGFuY2UodCl7cmV0dXJuIHQ/ZnVuY3Rpb24odCxuKXtsZXQgaT1uWzBdLXRbMF0scz1uWzFdLXRbMV0sZT1uWzJdLXRbMl07cmV0dXJuIE1hdGguc3FydChpKmkrcypzK2UqZSl9KHRoaXMsdCk6ZnVuY3Rpb24odCl7bGV0IG49dFswXSxpPXRbMV0scz10WzJdO3JldHVybiBNYXRoLnNxcnQobipuK2kqaStzKnMpfSh0aGlzKX1zcXVhcmVkRGlzdGFuY2UodCl7cmV0dXJuIHQ/ZnVuY3Rpb24odCxuKXtsZXQgaT1uWzBdLXRbMF0scz1uWzFdLXRbMV0sZT1uWzJdLXRbMl07cmV0dXJuIGkqaStzKnMrZSplfSh0aGlzLHQpOmZ1bmN0aW9uKHQpe2xldCBuPXRbMF0saT10WzFdLHM9dFsyXTtyZXR1cm4gbipuK2kqaStzKnN9KHRoaXMpfXNxdWFyZWRMZW5ndGgoKXtyZXR1cm4gdGhpcy5zcXVhcmVkRGlzdGFuY2UoKX1uZWdhdGUodD10aGlzKXt2YXIgbixpO3JldHVybiBpPXQsKG49dGhpcylbMF09LWlbMF0sblsxXT0taVsxXSxuWzJdPS1pWzJdLHRoaXN9cmVmbGVjdCh0KXtsZXQgbj10LmNsb25lKCk7cmV0dXJuIHRoaXMuc3ViKG4ubXVsdGlwbHkoMip0aGlzLmRvdCh0KSkpfWludmVyc2UodD10aGlzKXt2YXIgbixpO3JldHVybiBpPXQsKG49dGhpcylbMF09MS9pWzBdLG5bMV09MS9pWzFdLG5bMl09MS9pWzJdLHRoaXN9bm9ybWFsaXplKCl7cmV0dXJuIGEodGhpcyx0aGlzKSx0aGlzfWRvdCh0KXtyZXR1cm4gdSh0aGlzLHQpfWNyb3NzKHQsbil7cmV0dXJuIGZ1bmN0aW9uKHQsbixpKXtsZXQgcz1uWzBdLGU9blsxXSxyPW5bMl0saD1pWzBdLG89aVsxXSxhPWlbMl07dFswXT1lKmEtcipvLHRbMV09cipoLXMqYSx0WzJdPXMqby1lKmh9KHRoaXMsdCxuKSx0aGlzfWxlcnAodCxuLGkpe3JldHVybiBmdW5jdGlvbih0LG4saSxzKXtsZXQgZT1uWzBdLHI9blsxXSxoPW5bMl07dFswXT1lK3MqKGlbMF0tZSksdFsxXT1yK3MqKGlbMV0tciksdFsyXT1oK3MqKGlbMl0taCl9KHRoaXMsdCxuLGkpLHRoaXN9aGVybWl0ZSh0LG4saSxzLGUpe3JldHVybiBmdW5jdGlvbih0LG4saSxzLGUscil7bGV0IGg9cipyLG89aCooMipyLTMpKzEsYT1oKihyLTIpK3IsdT1oKihyLTEpLGw9aCooMy0yKnIpO3RbMF09blswXSpvK2lbMF0qYStzWzBdKnUrZVswXSpsLHRbMV09blsxXSpvK2lbMV0qYStzWzFdKnUrZVsxXSpsLHRbMl09blsyXSpvK2lbMl0qYStzWzJdKnUrZVsyXSpsfSh0aGlzLHQsbixpLHMsZSksdGhpc31iZXppZXIodCxuLGkscyxlKXtyZXR1cm4gZnVuY3Rpb24odCxuLGkscyxlLHIpe2xldCBoPTEtcixvPWgqaCxhPXIqcix1PW8qaCxsPTMqcipvLGM9MyphKmgsbT1hKnI7dFswXT1uWzBdKnUraVswXSpsK3NbMF0qYytlWzBdKm0sdFsxXT1uWzFdKnUraVsxXSpsK3NbMV0qYytlWzFdKm0sdFsyXT1uWzJdKnUraVsyXSpsK3NbMl0qYytlWzJdKm19KHRoaXMsdCxuLGkscyxlKSx0aGlzfWFwcGx5TWF0cml4NCh0KXtyZXR1cm4gZnVuY3Rpb24odCxuLGkpe2xldCBzPW5bMF0sZT1uWzFdLHI9blsyXSxoPWlbM10qcytpWzddKmUraVsxMV0qcitpWzE1XTtoPWh8fDEsdFswXT0oaVswXSpzK2lbNF0qZStpWzhdKnIraVsxMl0pL2gsdFsxXT0oaVsxXSpzK2lbNV0qZStpWzldKnIraVsxM10pL2gsdFsyXT0oaVsyXSpzK2lbNl0qZStpWzEwXSpyK2lbMTRdKS9ofSh0aGlzLHRoaXMsdCksdGhpc31hcHBseU1hdHJpeDModCl7cmV0dXJuIGZ1bmN0aW9uKHQsbixpKXtsZXQgcz1uWzBdLGU9blsxXSxyPW5bMl07dFswXT1zKmlbMF0rZSppWzNdK3IqaVs2XSx0WzFdPXMqaVsxXStlKmlbNF0rcippWzddLHRbMl09cyppWzJdK2UqaVs1XStyKmlbOF19KHRoaXMsdGhpcyx0KSx0aGlzfWFwcGx5UXVhdGVybmlvbih0KXtyZXR1cm4gZnVuY3Rpb24odCxuLGkpe2xldCBzPW5bMF0sZT1uWzFdLHI9blsyXSxoPWlbMF0sbz1pWzFdLGE9aVsyXSx1PWlbM10sbD11KnMrbypyLWEqZSxjPXUqZSthKnMtaCpyLG09dSpyK2gqZS1vKnMsZj0taCpzLW8qZS1hKnI7dFswXT1sKnUrZiotaCtjKi1hLW0qLW8sdFsxXT1jKnUrZiotbyttKi1oLWwqLWEsdFsyXT1tKnUrZiotYStsKi1vLWMqLWh9KHRoaXMsdGhpcyx0KSx0aGlzfXNldEZyb21NYXRyaXhQb3NpdGlvbih0KXtyZXR1cm4gdGhpcy54PXRbMTJdLHRoaXMueT10WzEzXSx0aGlzLno9dFsxNF0sdGhpc31hbmdsZSh0KXtyZXR1cm4gZnVuY3Rpb24odCxuKXtsZXQgaT1bLi4udF0scz1bLi4ubl07YShpLGkpLGEocyxzKTtsZXQgZT11KGkscyk7cmV0dXJuIGU+MT8wOmU8LTE/TWF0aC5QSTpNYXRoLmFjb3MoZSl9KHRoaXMsdCl9ZXF1YWxzKHQpe3JldHVybiBpPXQsKG49dGhpcylbMF09PT1pWzBdJiZuWzFdPT09aVsxXSYmblsyXT09PWlbMl07dmFyIG4saX1jbG9uZSgpe3JldHVybiBuZXcgbCh0aGlzWzBdLHRoaXNbMV0sdGhpc1syXSl9ZnJvbUFycmF5KHQsbj0wKXtyZXR1cm4gdGhpc1swXT10W25dLHRoaXNbMV09dFtuKzFdLHRoaXNbMl09dFtuKzJdLHRoaXN9bWluKHQpe3JldHVybiB0aGlzWzBdPU1hdGgubWluKHRoaXNbMF0sdC54KSx0aGlzWzFdPU1hdGgubWluKHRoaXNbMV0sdC55KSx0aGlzWzJdPU1hdGgubWluKHRoaXNbMl0sdC56KSx0aGlzfW1heCh0KXtyZXR1cm4gdGhpc1swXT1NYXRoLm1heCh0aGlzWzBdLHQueCksdGhpc1sxXT1NYXRoLm1heCh0aGlzWzFdLHQueSksdGhpc1syXT1NYXRoLm1heCh0aGlzWzJdLHQueiksdGhpc310b0FycmF5KCl7cmV0dXJuIEFycmF5LmZyb20odGhpcyl9c3RhdGljIGNvcHlUbyh0LG4pe3RbMF09blswXSx0WzFdPW5bMV0sdFsyXT1uWzJdfX1jb25zdCBjPVtuZXcgbCxuZXcgbCxuZXcgbCxuZXcgbCxuZXcgbCxuZXcgbCxuZXcgbCxuZXcgbF07Y2xhc3MgbXtjb25zdHJ1Y3Rvcih0PW5ldyBsKDEvMCksbj1uZXcgbCgtMS8wKSl7dGhpcy5taW49dCx0aGlzLm1heD1ufW1ha2VFbXB0eSgpe3JldHVybiB0aGlzLm1pbi54PXRoaXMubWluLnk9dGhpcy5taW4uej0xLzAsdGhpcy5tYXgueD10aGlzLm1heC55PXRoaXMubWF4Lno9LTEvMCx0aGlzfWlzRW1wdHkoKXtyZXR1cm4gdGhpcy5tYXgueDx0aGlzLm1pbi54fHx0aGlzLm1heC55PHRoaXMubWluLnl8fHRoaXMubWF4Lno8dGhpcy5taW4uen1nZXRDZW50ZXIodCl7cmV0dXJuIHRoaXMuaXNFbXB0eSgpP3Quc2V0KDAsMCwwKTp0LmFkZCh0aGlzLm1pbix0aGlzLm1heCkubXVsdGlwbHkoLjUpfWdldFNpemUodCl7cmV0dXJuIHRoaXMuaXNFbXB0eSgpP3Quc2V0KDAsMCwwKTp0LnN1Yih0aGlzLm1heCx0aGlzLm1pbil9ZXhwYW5kQnlQb2ludCh0KXtyZXR1cm4gdGhpcy5taW4ubWluKHQpLHRoaXMubWF4Lm1heCh0KSx0aGlzfXVuaW9uKHQpe3JldHVybiB0aGlzLm1pbi5taW4odC5taW4pLHRoaXMubWF4Lm1heCh0Lm1heCksdGhpc31jb3B5KHQpe3JldHVybiB0aGlzLm1pbi5jb3B5KHQubWluKSx0aGlzLm1heC5jb3B5KHQubWF4KSx0aGlzfWludGVyc2VjdHNCb3godCl7cmV0dXJuISh0Lm1heC54PHRoaXMubWluLnh8fHQubWluLng+dGhpcy5tYXgueHx8dC5tYXgueTx0aGlzLm1pbi55fHx0Lm1pbi55PnRoaXMubWF4Lnl8fHQubWF4Lno8dGhpcy5taW4uenx8dC5taW4uej50aGlzLm1heC56KX1zZXRGcm9tUG9pbnRzKHQpe3RoaXMubWFrZUVtcHR5KCk7Zm9yKGxldCBuPTAsaT10Lmxlbmd0aDtuPGk7bisrKXRoaXMuZXhwYW5kQnlQb2ludCh0W25dKTtyZXR1cm4gdGhpc31hcHBseU1hdHJpeDQodCl7cmV0dXJuIHRoaXMuaXNFbXB0eSgpfHwoY1swXS5zZXQodGhpcy5taW4ueCx0aGlzLm1pbi55LHRoaXMubWluLnopLmFwcGx5TWF0cml4NCh0KSxjWzFdLnNldCh0aGlzLm1pbi54LHRoaXMubWluLnksdGhpcy5tYXgueikuYXBwbHlNYXRyaXg0KHQpLGNbMl0uc2V0KHRoaXMubWluLngsdGhpcy5tYXgueSx0aGlzLm1pbi56KS5hcHBseU1hdHJpeDQodCksY1szXS5zZXQodGhpcy5taW4ueCx0aGlzLm1heC55LHRoaXMubWF4LnopLmFwcGx5TWF0cml4NCh0KSxjWzRdLnNldCh0aGlzLm1heC54LHRoaXMubWluLnksdGhpcy5taW4ueikuYXBwbHlNYXRyaXg0KHQpLGNbNV0uc2V0KHRoaXMubWF4LngsdGhpcy5taW4ueSx0aGlzLm1heC56KS5hcHBseU1hdHJpeDQodCksY1s2XS5zZXQodGhpcy5tYXgueCx0aGlzLm1heC55LHRoaXMubWluLnopLmFwcGx5TWF0cml4NCh0KSxjWzddLnNldCh0aGlzLm1heC54LHRoaXMubWF4LnksdGhpcy5tYXgueikuYXBwbHlNYXRyaXg0KHQpLHRoaXMuc2V0RnJvbVBvaW50cyhjKSksdGhpc319ZnVuY3Rpb24gZih0LG4saT0wLHM9dC5sZW5ndGgsZT1NYXRoLmZsb29yKChpK3MpLzIpKXtmb3IobGV0IHI9aTtyPD1lO3IrKyl7bGV0IGk9cixlPXRbcl07Zm9yKGxldCBoPXIrMTtoPHM7aCsrKW4oZSx0W2hdKXx8KGk9aCxlPXRbaF0seCh0LHIsaSkpfX1mdW5jdGlvbiB4KHQsbixpKXtjb25zdCBzPXRbaV07dFtpXT10W25dLHRbbl09c31sZXQgeSxwPTAsZz0wLE09MCxkPSExO2NvbnN0IHo9bmV3IGw7ZnVuY3Rpb24gdyh0LG4pe3JldHVybntwcmltaXRpdmVzOnQsYm91bmRzOm59fWZ1bmN0aW9uIGIodCxuLGkpe2xldCBzPWlbbl0tdC5taW5bbl07cmV0dXJuIHQubWF4W25dPnQubWluW25dJiYocy89dC5tYXhbbl0tdC5taW5bbl0pLHN9ZnVuY3Rpb24gdih0KXtyZXR1cm4gdC5nZXRTaXplKHopLDIqKHoueCp6Lnorei54KnoueSt6Lnoqei55KX1mdW5jdGlvbiBxKHQsbixpLHM9ITEpe2NvbnN0IGU9bmV3IG07Zm9yKGxldCB1PW47dTxpO3UrKyllLnVuaW9uKHRbdV0uYm91bmRzKTtpZihkKXtNKz0xLHkoKE0rZykvcCl9Y29uc3Qgcj1pLW47aWYoMT09PXIpcmV0dXJuIHcodC5zbGljZShuLGkpLGUpO3tjb25zdCB1PW5ldyBtO2ZvcihsZXQgcz1uO3M8aTtzKyspdS5leHBhbmRCeVBvaW50KHRbc10uY2VudGVyKTtjb25zdCBsPSh1LmdldFNpemUoeiksei54Pnouej96Lng+ei55PyJ4IjoieSI6ei56PnoueT8ieiI6InkiKTtsZXQgYz1NYXRoLmZsb29yKChuK2kpLzIpO2lmKHI8PTQpZih0LCgodCxuKT0+dC5jZW50ZXJbbF08bi5jZW50ZXJbbF0pLG4saSxjKTtlbHNlIGlmKHUubWF4W2xdPT09dS5taW5bbF0pe2lmKCFzKXJldHVybiB3KHQuc2xpY2UobixpKSxlKTtmKHQsKCh0LG4pPT50LmNlbnRlcltsXTxuLmNlbnRlcltsXSksbixpLGMpfWVsc2V7Y29uc3Qgcz0xMixyPVtdO2ZvcihsZXQgdD0wO3Q8czt0Kyspci5wdXNoKHtib3VuZHM6bmV3IG0sY291bnQ6MH0pO2ZvcihsZXQgZT1uO2U8aTtlKyspe2xldCBuPU1hdGguZmxvb3IocypiKHUsbCx0W2VdLmNlbnRlcikpO249PT1yLmxlbmd0aCYmKG49ci5sZW5ndGgtMSkscltuXS5jb3VudCsrLHJbbl0uYm91bmRzLnVuaW9uKHRbZV0uYm91bmRzKX1jb25zdCBoPVtdO2ZvcihsZXQgdD0wO3Q8ci5sZW5ndGgtMTt0Kyspe2NvbnN0IG49bmV3IG0saT1uZXcgbTtsZXQgcz0wLG89MDtmb3IobGV0IGU9MDtlPD10O2UrKyluLnVuaW9uKHJbZV0uYm91bmRzKSxzKz1yW2VdLmNvdW50O2ZvcihsZXQgZT10KzE7ZTxyLmxlbmd0aDtlKyspaS51bmlvbihyW2VdLmJvdW5kcyksbys9cltlXS5jb3VudDtoLnB1c2goLjErKHMqdihuKStvKnYoaSkpL3YoZSkpfWxldCBvPWhbMF0sYT0wO2ZvcihsZXQgdD0xO3Q8aC5sZW5ndGg7dCsrKWhbdF08byYmKG89aFt0XSxhPXQpO2M9ZnVuY3Rpb24odCxuLGk9MCxzPXQubGVuZ3RoKXtmb3IoO2khPT1zOyl7Zm9yKDtuKHRbaV0pOylpZigrK2k9PT1zKXJldHVybiBpO2Rve2lmKGk9PT0tLXMpcmV0dXJuIGl9d2hpbGUoIW4odFtzXSkpO3godCxpLHMpLGkrK31yZXR1cm4gaX0odCwodD0+e2xldCBuPU1hdGguZmxvb3Ioci5sZW5ndGgqYih1LGwsdC5jZW50ZXIpKTtyZXR1cm4gbj09PXIubGVuZ3RoJiYobj1yLmxlbmd0aC0xKSxuPD1hfSksbixpKX1yZXR1cm4gaD1sLG89cSh0LG4sYyxzKSxhPXEodCxjLGkscykse2NoaWxkMDpvLGNoaWxkMTphLGJvdW5kczoobmV3IG0pLnVuaW9uKG8uYm91bmRzKS51bmlvbihhLmJvdW5kcyksc3BsaXRBeGlzOmh9fXZhciBoLG8sYX1mdW5jdGlvbiBBKHQsbixpKXtjb25zdHtwcmltaXRpdmVJbmZvQXJyOnN9PWZ1bmN0aW9uKHQsbj0wKXtsZXQgaT1uO2NvbnN0IHM9W107Zm9yKGxldCBlPTA7ZTx0Lmxlbmd0aDtlKyspe2NvbnN0IG49W10scj10W2VdLGg9ci5pbmRpY2VzLG89ci5wb3NpdGlvbixhPW5ldyBsLHU9bmV3IGwsYz1uZXcgbDtmb3IobGV0IHQ9MDt0PGguYXJyYXkubGVuZ3RoO3QrPTMpe2NvbnN0IHM9aC5hcnJheVt0XSxlPWguYXJyYXlbdCsxXSxyPWguYXJyYXlbdCsyXSxmPW5ldyBtLHg9Myx5PXMqeDthLng9by5hcnJheVt5XSxhLnk9by5hcnJheVt5KzFdLGEuej1vLmFycmF5W3krMl07Y29uc3QgcD1lKng7dS54PW8uYXJyYXlbcF0sdS55PW8uYXJyYXlbcCsxXSx1Lno9by5hcnJheVtwKzJdO2NvbnN0IGc9cip4O2MueD1vLmFycmF5W2ddLGMueT1vLmFycmF5W2crMV0sYy56PW8uYXJyYXlbZysyXSxmLmV4cGFuZEJ5UG9pbnQoYSksZi5leHBhbmRCeVBvaW50KHUpLGYuZXhwYW5kQnlQb2ludChjKTtjb25zdCBNPXtib3VuZHM6ZixjZW50ZXI6Zi5nZXRDZW50ZXIobmV3IGwpLGluZGljZXM6W3MraSxlK2kscitpXX07bi5wdXNoKE0pfWkrPXIucG9zaXRpb24uYXJyYXkubGVuZ3RoLzMscy5wdXNoKG4pfXJldHVybntwcmltaXRpdmVJbmZvQXJyOnN9fSh0LGkpLGU9W107aWYobil7cD0wLGc9MCxkPSEwLHk9bjtmb3IobGV0IHQ9MDt0PHMubGVuZ3RoO3QrKylwKz0yKnNbdF0ubGVuZ3RoLTF9Zm9yKGxldCByPTA7cjxzLmxlbmd0aDtyKyspe2NvbnN0IHQ9c1tyXTtNPTA7Y29uc3Qgbj1xKHQsMCx0Lmxlbmd0aCk7Zys9Mip0Lmxlbmd0aC0xLGUucHVzaChuKX1yZXR1cm57Ymxhc0JWSHM6ZX19ZnVuY3Rpb24gQih0LG49MCxpPVtdKXtjb25zdCBzPVtdO2xldCBlPTE7Y29uc3Qgcj17eDozLHk6NCx6OjV9LGg9KHQsbz0xKT0+e2lmKGU9TWF0aC5tYXgobyxlKSx0LnByaW1pdGl2ZXMpe2NvbnN0IG49dDtmb3IobGV0IHQ9MDt0PG4ucHJpbWl0aXZlcy5sZW5ndGg7dCsrKXtjb25zdCBlPW4ucHJpbWl0aXZlc1t0XTtpZih2b2lkIDAhPT1lLmluZGljZXMpe2NvbnN0IHQ9ZTtzLnB1c2godC5pbmRpY2VzWzBdLHQuaW5kaWNlc1sxXSx0LmluZGljZXNbMl0sMSwwLDAsMCwwKX1lbHNle2NvbnN0IHQ9ZTtzLnB1c2goaVt0Lmdlb21ldHJ5SURdLHQubWF0ZXJpYWxJRCx0Lm1lc2hJRCwxLE51bWJlcih0LnZpc2libGUpLDAsMCwwKX19fWVsc2V7Y29uc3QgaT10LGU9aS5ib3VuZHM7cy5wdXNoKGUubWluLngsZS5taW4ueSxlLm1pbi56LHJbaS5zcGxpdEF4aXNdLGUubWF4LngsZS5tYXgueSxlLm1heC56LDApO2NvbnN0IGE9cy5sZW5ndGgtMTtoKGkuY2hpbGQwLG8rMSksc1thXT1zLmxlbmd0aC84K24saChpLmNoaWxkMSxvKzEpfX07cmV0dXJuIGgodCkse2NvdW50OnMubGVuZ3RoLzgsbWF4RGVwdGg6ZSxmbGF0RGF0YTpzfX1zZWxmLm9ubWVzc2FnZT1mdW5jdGlvbih7ZGF0YTp0fSl7Y29uc3R7Z2VvbWV0cmllczpuLHByZVZlcnRleENvdW50OmksbGFzdFNwbGl0SW5kZXg6c309dDtsZXQgZT1wZXJmb3JtYW5jZS5ub3coKTtjb25zdCByPXQ9Pntjb25zdCBuPXBlcmZvcm1hbmNlLm5vdygpOyhuLWU+PTEwfHwxPT09dCkmJihlPW4sc2VsZi5wb3N0TWVzc2FnZSh7ZXJyb3I6bnVsbCxmbGF0QkxBU0JWSEluZm86bnVsbCxwcm9ncmVzczp0fSkpfTt0cnl7Y29uc3R7Ymxhc0JWSHM6dH09QShuLHIsaSksZT1mdW5jdGlvbih0LG49MCl7Y29uc3QgaT1bXTtsZXQgcz1bXSxlPTE7Zm9yKGxldCByPTA7cjx0Lmxlbmd0aDtyKyspe2NvbnN0IGg9Qih0W3JdLG4pO2U9TWF0aC5tYXgoaC5tYXhEZXB0aCxlKSxzLnB1c2gobiksbis9aC5jb3VudCxpLnB1c2goaCl9cmV0dXJue2JsYXNCdWZmZXJTcGxpdEluZGV4OnMsdG90YWxCTEFTRGF0YUxlbmd0aDo4Km4sdG90YWxCTEFTRGF0YUNvdW50Om4sZmxhdEJWSEluZm9zOmksbWF4RGVwdGg6ZX19KHQscyk7c2VsZi5wb3N0TWVzc2FnZSh7ZXJyb3I6bnVsbCxmbGF0QkxBU0JWSEluZm86ZSxwcm9ncmVzczpudWxsfSl9Y2F0Y2goaCl7c2VsZi5wb3N0TWVzc2FnZSh7ZXJyb3I6aCxmbGF0QkxBU0JWSEluZm86bnVsbCxwcm9ncmVzczpudWxsfSl9fX0oKTsK",pr="undefined"!=typeof window&&window.Blob&&new Blob([atob(hr)],{type:"text/javascript;charset=utf-8"});function fr(){const e=pr&&(window.URL||window.webkitURL).createObjectURL(pr);try{return e?new Worker(e,{}):new Worker("data:application/javascript;base64,"+hr,{type:"module"})}finally{e&&(window.URL||window.webkitURL).revokeObjectURL(e)}}class mr{constructor(){this.worker=new fr,this.building=!1}build(e,t,r,s){if(this.building)throw new Error("BVHWorker is building");this.building=!0;const{worker:i}=this;return new Promise(((a,n)=>{i.onmessage=e=>{this.building=!1;const{flatBLASBVHInfo:r,error:s,progress:o}=e.data;s?n(new Error(s)):r?(i.onmessage=null,a(r)):null!=o&&t(o)},i.postMessage({geometries:e,preVertexCount:r,lastSplitIndex:s})}))}}class gr{constructor(e,t){this.device=e,this.useWebWorker=t,this.debugPass=new Ut(e),this.workerBuilder=new mr}async addMeshesToBLAS(e,t,r,s){const{device:i,useWebWorker:a}=this,n=[];Array.from(t.keys()).forEach(((e,t)=>{n[t]={};const r=n[t];r.position=e.position,r.indices=e.indices}));const o=this.lastFlatBLASBVHInfo.totalBLASDataCount;let l;if(a)l=await this.workerBuilder.build(n,s,r,o);else{const{blasBVHs:e}=lr(n,s,r);l=dr(e,o)}this.lastFlatBLASBVHInfo.blasBufferSplitIndex.push(...l.blasBufferSplitIndex),this.lastFlatBLASBVHInfo.flatBVHInfos.push(...l.flatBVHInfos),this.lastFlatBLASBVHInfo.totalBLASDataCount=l.totalBLASDataCount,this.lastFlatBLASBVHInfo.totalBLASDataLength=8*this.lastFlatBLASBVHInfo.totalBLASDataCount;const u=this.lastFlatBLASBVHInfo.totalBLASDataLength*Float32Array.BYTES_PER_ELEMENT;if(u>=Math.min(i.limits.maxBufferSize,i.limits.maxStorageBufferBindingSize))return void console.error("The total size of loaded models exceeds the browser limit!");const c=this.blasBuffer=i.createBuffer({mappedAtCreation:!0,size:u,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC}),d=new Float32Array(c.getMappedRange()),h=this.lastFlatBLASBVHInfo.flatBVHInfos;let p=0;for(let b=0;b<h.length;b++){const e=h[b].flatData;d.set(e,p),p+=e.length}c.unmap();const{positionBuffer:f,uvBuffer:m,normalBuffer:g,indicesBuffer:x}=this.buildGeoBuffer(e);return{positionBuffer:f,uvBuffer:m,normalBuffer:g,indicesBuffer:x}}rebuildTLAS(e,t=!1){const{device:r}=this,{geometryIndexMap:s}=e.geometryInfo;let{meshes:i,materialIndexMap:a}=e;i=i.filter((e=>!e.tlasMask));const n=cr(or(i,s,a),this.lastFlatBLASBVHInfo.blasBufferSplitIndex),o=nr(i);if(t){const e=n.flatData.length*Float32Array.BYTES_PER_ELEMENT;this.tlasBuffer=r.createBuffer({size:e,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST});const t=o.byteLength;this.transformBuffer=r.createBuffer({size:t,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST})}r.queue.writeBuffer(this.tlasBuffer,0,new Float32Array(n.flatData)),r.queue.writeBuffer(this.transformBuffer,0,o)}destory(){}buildGeoBuffer(e){const{device:t}=this,{geometryIndexMap:r,vertexTotalCount:s,indicesTotalCount:i}=e.geometryInfo,a=Array.from(r.keys()),n=3*s*Float32Array.BYTES_PER_ELEMENT,o=t.createBuffer({mappedAtCreation:!0,size:n,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.VERTEX}),l=new Float32Array(o.getMappedRange());let u=0;a.forEach((e=>{const t=e.position.array;l.set(t,u),u+=t.length})),o.unmap();const c=n,d=t.createBuffer({mappedAtCreation:!0,size:c,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.VERTEX}),h=new Float32Array(d.getMappedRange());let p=0;a.forEach((e=>{const t=e.normal.array;h.set(t,p),p+=t.length})),d.unmap();const f=2*s*Float32Array.BYTES_PER_ELEMENT,m=t.createBuffer({mappedAtCreation:!0,size:f,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.VERTEX}),g=new Float32Array(m.getMappedRange());let x=0;a.forEach((e=>{const t=e.uv.array;g.set(t,x),x+=t.length})),m.unmap();const b=i*Uint32Array.BYTES_PER_ELEMENT,v=t.createBuffer({mappedAtCreation:!0,size:b,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.INDEX}),L=new Uint32Array(v.getMappedRange());let y=0;return a.forEach((e=>{const t=e.indices.array;L.set(t,y),y+=t.length})),v.unmap(),{positionBuffer:o,uvBuffer:m,normalBuffer:d,indicesBuffer:v}}async build(e,t){const{device:r,useWebWorker:s}=this,{geometryIndexMap:i}=e.geometryInfo;let{meshes:a,materialIndexMap:n}=e;const o=Array.from(i.keys()),l=[];if(o.forEach(((e,t)=>{l[t]={};const r=l[t];r.position=e.position,r.indices=e.indices})),s)this.lastFlatBLASBVHInfo=await this.workerBuilder.build(l,t);else{const{blasBVHs:e}=lr(l);this.lastFlatBLASBVHInfo=dr(e)}a=a.filter((e=>!e.tlasMask));const u=cr(or(a,i,n),this.lastFlatBLASBVHInfo.blasBufferSplitIndex),c=this.lastFlatBLASBVHInfo.totalBLASDataLength*Float32Array.BYTES_PER_ELEMENT;if(c>=Math.min(r.limits.maxBufferSize,r.limits.maxStorageBufferBindingSize))return void console.error("The total size of loaded models exceeds the browser limit!");const d=this.blasBuffer=r.createBuffer({mappedAtCreation:!0,size:c,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC}),h=new Float32Array(d.getMappedRange()),p=this.lastFlatBLASBVHInfo.flatBVHInfos;let f=0;for(let T=0;T<p.length;T++){const e=p[T].flatData;h.set(e,f),f+=e.length}d.unmap();const m=u.flatData.length*Float32Array.BYTES_PER_ELEMENT,g=this.tlasBuffer=r.createBuffer({mappedAtCreation:!0,size:m,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST});new Float32Array(g.getMappedRange()).set(u.flatData,0),g.unmap();const{positionBuffer:x,uvBuffer:b,normalBuffer:v,indicesBuffer:L}=this.buildGeoBuffer(e),y=nr(a),S=y.byteLength,M=this.transformBuffer=r.createBuffer({mappedAtCreation:!0,size:S,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST});return new Float32Array(M.getMappedRange()).set(y,0),M.unmap(),{blasBuffer:d,tlasBuffer:g,positionBuffer:x,uvBuffer:b,normalBuffer:v,indicesBuffer:L,transformBuffer:M}}}const xr="PositionBuffer",br="UVBuffer",vr="NormalBuffer",Lr="BVHBuffer",yr="IndicesBuffer",Sr="TLASBuffer",Mr="BLASBuffer",Tr="TLASTransformBuffer",Gr="MaterialBuffer",_r="MaterialTextureArray",Pr="TextureUVTransformBuffer",Br="LightBuffer";class Rr{constructor(e,t){this.device=e,this.resourcePool=t,this.bvhBuilder=new Ot(e)}destroy(){const{resourcePool:e}=this;e.destoryResourceByName(Gr),e.destoryResourceByName(_r),e.destoryResourceByName(Pr),e.destoryResourceByName(xr),e.destoryResourceByName(vr),e.destoryResourceByName(br),e.destoryResourceByName(yr),e.destoryResourceByName(Lr),e.destoryResourceByName(Br)}async buildBVH(e){const{resourcePool:t}=this,r=await this.bvhBuilder.build(e);if(!r)return;const{positionBuffer:s,uvBuffer:i,indicesBuffer:a,normalBuffer:n,bvhNodesBuffer:o,materialMeshIndexBuffer:l}=r;t.setResource(xr,s,"Buffer"),t.setResource(vr,n,"Buffer"),t.setResource(br,i,"Buffer"),t.setResource(yr,a,"Buffer"),t.setResource(Lr,o,"Buffer"),t.setResource("MaterialMeshIndexBuffer",l,"Buffer")}async build(e,t){let{meshes:r,materialIndexMap:s,materials:i,lights:a}=e;1===r.length&&"LGLDefaultMesh"==r[0].name&&(r[0].visible=!0),r=r.filter((e=>1==e.visible));const n=Re(r,!0);e.geometryInfo=n;const o=Xe(r,s,n),{textureImageMap:l,materialBuffer:u,textureArrayRes:c}=await Ve(this.device,i);this.resourcePool.setResource(Gr,u,"Buffer"),this.resourcePool.setResource(_r,c,"Texture");const d=ke(this.device,s);this.resourcePool.setResource(Pr,d,"Buffer"),this.curLightBuffer=Ke(this.device,a),this.resourcePool.setResource(Br,this.curLightBuffer,"Buffer"),this.curTextureImageMap=l,this.curUVTransformBuffer=d,await this.buildBVH(o)}updateMaterialParams(e){const{materials:t}=e,{device:r,curTextureImageMap:s,resourcePool:i}=this,a=Ne(r,t,s);i.updateResource(Gr,a,"Buffer")}updateLightBuffer(e){const t=e.lights;He(this.device,this.curLightBuffer,t)}updateUVTransBuffer(e){const{materialIndexMap:t}=e;Ee(this.device,t,this.curUVTransformBuffer)}async rebuildMaterialRelated(e){let{meshes:t,materialIndexMap:r,materials:s,geometryInfo:i}=e;1===t.length&&"LGLDefaultMesh"==t[0].name&&(t[0].visible=!0),t=t.filter((e=>1==e.visible));const a=Xe(t,r,i),{textureImageMap:n,materialBuffer:o,textureArrayRes:l}=await Ve(this.device,s);this.resourcePool.setResource(Gr,o,"Buffer"),this.resourcePool.setResource(_r,l,"Texture");const u=ke(this.device,r);this.resourcePool.setResource(Pr,u,"Buffer"),this.curTextureImageMap=n,this.curUVTransformBuffer=u,await this.buildBVH(a)}async rebuildBVH(e){let{meshes:t,materialIndexMap:r,materials:s,geometryInfo:i}=e;1===t.length&&"LGLDefaultMesh"==t[0].name&&(t[0].visible=!0),t=t.filter((e=>1==e.visible));const a=Xe(t,r,i);await this.buildBVH(a)}}class wr{constructor(e,t,r=!0){this.device=e,this.resourcePool=t,this.useWebWorker=r,this.bvhBuilder=new gr(e,r)}destroy(){const{resourcePool:e}=this;e.destoryResourceByName(Gr),e.destoryResourceByName(_r),e.destoryResourceByName(Pr),e.destoryResourceByName(xr),e.destoryResourceByName(vr),e.destoryResourceByName(br),e.destoryResourceByName(Sr),e.destoryResourceByName(Mr),e.destoryResourceByName(Tr),e.destoryResourceByName(Tr),e.destoryResourceByName(Br)}async buildBVH(e,t){const{resourcePool:r}=this,s=await this.bvhBuilder.build(e,t);if(!s)return;const{positionBuffer:i,uvBuffer:a,normalBuffer:n,indicesBuffer:o,tlasBuffer:l,blasBuffer:u,transformBuffer:c}=s;r.setResource(xr,i,"Buffer"),r.setResource(vr,n,"Buffer"),r.setResource(br,a,"Buffer"),r.setResource(yr,o,"Buffer"),r.setResource(Sr,l,"Buffer"),r.setResource(Mr,u,"Buffer"),r.setResource(Tr,c,"Buffer")}async build(e,t){let{meshes:r,materials:s,materialIndexMap:i,lights:a}=e;this.destroy();const n=Re(r);e.geometryInfo=n;const{textureImageMap:o,materialBuffer:l,textureArrayRes:u}=await Ve(this.device,s);this.resourcePool.setResource(Gr,l,"Buffer"),this.resourcePool.setResource(_r,u,"Texture");const c=ke(this.device,i);this.resourcePool.setResource(Pr,c,"Buffer"),this.curLightBuffer=Ke(this.device,a),this.resourcePool.setResource(Br,this.curLightBuffer,"Buffer"),this.curTextureImageMap=o,this.curUVTransformBuffer=c,await this.buildBVH(e,t)}updateLightBuffer(e){const t=e.lights;He(this.device,this.curLightBuffer,t)}updateMaterialParams(e){const{materials:t}=e,{device:r,curTextureImageMap:s,resourcePool:i}=this,a=Ne(r,t,s);i.updateResource(Gr,a,"Buffer")}updateUVTransBuffer(e){const{materialIndexMap:t}=e;Ee(this.device,t,this.curUVTransformBuffer)}rebuildTLAS(e,t=!1){this.bvhBuilder.rebuildTLAS(e,t),t&&(this.resourcePool.updateResource(Sr,this.bvhBuilder.tlasBuffer,"Buffer"),this.resourcePool.updateResource(Tr,this.bvhBuilder.transformBuffer,"Buffer"))}async rebuildMaterialBuffer(e,t=!1){const{materials:r,materialIndexMap:s}=e;if(t){const{textureImageMap:e,materialBuffer:t,textureArrayRes:i}=await Ve(this.device,r);this.resourcePool.updateResource(Gr,t,"Buffer"),this.resourcePool.updateResource(_r,i,"Texture");const a=ke(this.device,s);this.resourcePool.updateResource(Pr,a,"Buffer"),this.curTextureImageMap=e,this.curUVTransformBuffer=a}else this.updateMaterialParams(e)}async addMeshesToBLAS(e,t,r){var s;let{meshes:i}=e;const{resourcePool:a}=this,n=null==(s=e.geometryInfo)?void 0:s.vertexTotalCount,o=Re(i);e.geometryInfo=o;const l=function(e){const t=new Map;for(const r of e){let e=r.geometry;if(null==t.get(e)){const r=t.size;t.set(e,r)}}return t}(t),u=await this.bvhBuilder.addMeshesToBLAS(e,l,n,r);if(!u)return;const{positionBuffer:c,uvBuffer:d,normalBuffer:h,indicesBuffer:p}=u;a.updateResource(Mr,this.bvhBuilder.blasBuffer,"Buffer"),a.updateResource(xr,c,"Buffer"),a.updateResource(vr,h,"Buffer"),a.updateResource(br,d,"Buffer"),a.updateResource(yr,p,"Buffer")}}class Ir{constructor(e,t){this.strata=[];const r=e**t;for(let s=0;s<r;s++)this.strata[s]=s;this.index=this.strata.length,this.sample=[],this.strataCount=e,this.dimensions=t}restart(){this.index=0}next(){const{strata:e,strataCount:t,dimensions:r}=this;this.index>=e.length&&(!function(e){for(let t=e.length-1;t>0;t--){const r=Math.floor(Math.random()*(t+1)),s=e[t];e[t]=e[r],e[r]=s}}(this.strata),this.restart());let s=e[this.index++];for(let i=0;i<r;i++)this.sample[i]=s%t+Math.random(),s=Math.floor(s/t);return this.sample}}class zr{constructor(e,t){this.strataObjs=[];for(const r of t)this.strataObjs.push(new Ir(e,r));this.combined=[],this.strataCount=e}getFirstBake(){return this.bakeCombined||(this.bakeCombined=this.next()),this.bakeCombined}next(){const{strataObjs:e,combined:t}=this;let r=0;for(const s of e){const e=s.next();for(const s of e)t[r++]=s}return t}restart(){for(const e of this.strataObjs)e.restart()}}class Wr{constructor(e){this.context=e,this.curTileNum=-1,this.totalTileNum=-1,this.columns=0,this.rows=0,this.tileWidth=0,this.tileHeight=0,this.viewWidth=0,this.viewHeight=0}reset(){this.curTileNum=-1}setSize(){const{width:e,height:t}=this.context;this.viewWidth=e,this.viewHeight=t,this.computeTileDimensions()}setTileCount(e){this.totalTileNum=e,this.computeTileDimensions(),this.reset()}computeTileDimensions(){const{viewWidth:e,viewHeight:t}=this,r=Math.sqrt(this.totalTileNum);this.tileWidth=Math.ceil(e/r),this.tileHeight=Math.ceil(t/r),this.columns=Math.ceil(e/this.tileWidth),this.rows=Math.ceil(t/this.tileHeight),this.columns&&this.rows&&(this.totalTileNum=this.columns*this.rows)}nextTile(){const{totalTileNum:e,tileWidth:t,tileHeight:r,viewHeight:s,columns:i,rows:a}=this;this.curTileNum++,this.curTileNum%e==0&&(this.curTileNum=0);const n=this.curTileNum===e-1,o=this.curTileNum%i,l=Math.floor(this.curTileNum/i)%a;return{x:o*t,y:Math.min(s,l*r),tileWidth:t,tileHeight:r,isFirstTile:0===this.curTileNum,isLastTile:n}}}class Xr{constructor(e,t,r){this.device=e,this.context=t,this.rg=r,this.sampleCount=0,this.strataCount=1,this.numUniformSamples=4,this.samplingDimensions=[],this.needsUpdateBG=!1,this.enableTileRender=Z,this.tilePreFullSample=1,this.tileOffset=[0,0],this.tileSize=[0,0],this.enableDenoise=Y,this.resourcePool=this.rg.resourcePool,this.integratorPass=new Zt(this.device,this.context,this.rg),this.accumulatePass=new Kt(this.device,this.context,this.rg),this.screenPass=new dt(this.device,this.context,this.rg),this.clearTexPass=new nt(this.device,this.context,this.rg),this.gBufferPass=new Vt(this.device,this.context,this.rg),this.tileCalculator=new Wr(t),this.pipelineConfig={needsClean:!1}}async buildPipeline(e,t,r){this.camera=t,this.lastCamera=t.clone(),this.renderSetting=ie(e,0,r),await this.initNoise(),this.initRandomSample(),this.initTileBuffer(),this.initUniformBuffer(),await this.integratorPass.createPipeline(this.renderSetting),await this.accumulatePass.createPipeline(this.renderSetting),await this.screenPass.createPipeline(this.renderSetting),await this.clearTexPass.createPipeline(),await this.gBufferPass.createPipeline(this.renderSetting,e,t)}async initNoise(){const{device:e,resourcePool:t}=this;if(t.getResourceByName("NoiseTexture"))return;const r=await async function(e){const t=await fetch(e),r=await t.blob();return await createImageBitmap(r)}("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABAEAAAAADfkvJBAAAbsklEQVR4nA3UhQIIvBoA0E830810M91MN9PNdDPd/ulmupluppvpZrqZbqabe89DHCiDv5GzaossZGYBp2PFIFqKdmMXIKW85edCB/RT11SD3JMQidRlL7n2ufRH1jVkFUNVc3NaZ7DP0T7/112kM1Qc3RDG0K/4uN7CPC7OmtFRZK3Jy3fhSSySKIZXopTsnIhN69JjLHJYYnfpZu44hnV+UkhG/lPd/D+fIVwWtdhhupVPJmtsLFIhjHA7UUqY4fPIQ2qdKxviqH2sugJ2nC+1ZdV0vEF3RGNcMd4KdvIXaJnujdPrKj4ifkeX2f04avjEbqO0ogI/rD7zhmy6GKG/2w32IetIX5vE9DbrS+CNy4sbmgXoiaug48lV4bVKZgluwPujd+Ioa+KjuntypepEEvl/YYCYTq6w4aaReGMShwLkC4nvq7jFKJmLpoepHJTag/h2aMklShou+tyip5wm67P2/CnvH7K6zuq+KGvy2rkkrR4mc4dpUNTEFHDId9TXQiST3RxHO0lHNgNFIA/Ub1kC0pOlNBf77EtyZ0ejxvikzySL8C8hNWyyc1GvcBCusv/otvBO3YSj+KvvRlKgoNaF/GEB64prsx8qFRwVJcRmMk8l5E5swfHMPuhlr9DmtrLeqs7KOrCMQSpeGW/zH5F2dc0AXZhcp9IthLZyuxpHrkNnp0JfnsY+55XkAtgSOvsWzps8uoJ5GtpAXRWZ5TK9cEM1WVRWC81ZUstPZHHkC7GDjZfl7BJ+VcXkI8RfVIMW0Jq95oxE0R+MDQnMX97DPhYjEXzHM0LvUNyODhdDCvJdNmXlfFp0RsbBNclTj8hpXofsCgVYsAnwPRTNTiTLxZkQW43BmK6wHk7Y0iSdXIfyK8/aQULdx1/hJc0JkRE/UgNDc/dGZWanTCs2WQ0W6Xh7PZGuDMXEaLtIRMZcZAM4ieOwO661Qf4xVyhLOOA2mLe0JyvIDrBhUA42ioUiMmrHJ9te6jwtbQ6xWrKf/ED3qKJ0qvzO2of57KkcyMBvNZndbLTX/iWNaWTezm9E8cleKOSEXK1B3LDfeGk4yx/b7L5+uAvp6UVC/UYAhvPLvSwTWm+qqO5saYjh79LadBJaAR90ct9S/GGZ7Q1zhKyTOUJ9MzT85IldVjLLduUOqovEaASJbXeZ37oFv0w/sOGhvMzpVrL/2MeQx8+ldfQU/QBXIqn8NtHAHjCzaTJk+CDS0e6Wk8N7GEDgoR4rG5M/Zig/LD6hEr6VHmxzmijoKu/oZ+p84oEeiwegquE7pBZPYXEoyLeQ66wRicLXmOzWoib6mq6KUoWxuriq62OQh647TUmn0RuuIjtPfuEkcMQtwJ/IaJabRRe9fRX2Q8Z1L2UNlMclpfMFdKYr+XkVEeb6vChZuOBfhNl+l/hly9L0/mzYIxPhBq4oimlnB273mkgwnr+S7Vnp8Fff8/3VC7IJCtqZ9AxZRnujo3wjmQ9n7WtayxwgvUhUNtJ0UjlEU9vPFhePxDLfkl6z43hhdQSW+xbyKooJEEwqTOkL1VHWc1vReFaVxbcnTGM2Uq1XNXRPos0bdtI8VBKXcZdCV1dNpLcL3DE7Cqfmi2w5JGhGFqATTUhzy7sG2+a0II4ZtupikC488mt9abdTvpYXVALXBU6wNzYLXUTPQwTxH/nNttjKDA7pQT47mopOQmxzW/f3GVhXWoguEUl5EHcUoKm8LdpiMoZV9JONpzZa7wa7hG4XzxvquHj2s5lsIrFbtrbew3+SKbiK6Ry+whAyXrTBC0kgDfwZHNOMNRnwOjHVVICdOGVo6LuFsn6GTKN6u4IeZqtN7B6vzlegD7ioW8i/u430kbtO2pABrgTPwb+xchSZ7jK/V6KxPEWK+K+oBXFmeuikt+HzrIU66KQsI9bRaGqQfKqSkMNumbnN4/ljkFsPxqnDElSF32L17D8UhxbUI8xnuwk/0znwXXcGGmD4QpPo5n6kTod70Zb2oI8Y6pFJKiuLoab7bXBEj+CXFTOH4A4kV/1JNjNRLrexaEX5Ht0xQ1RRskzmhCd+rmnFi9hLeqHe7svy7Lq+/+Mq6am+A/X8e+iptvqcbIjzqCOfbW6SpKQ22gPt8HgTFUMPd9kWgKd2O45Pr0EuOlK8waXFfriga7sXrLlKZZbrgeaPnmsrurd+n2H8hugjc+i1OCpJj2vYPyQ27+lT6/f4JM0c6sJIHwm/8AJS4tXuuo6g9qOCjvOZIrI9ZpaaauQAjwb9eTG0RMYPr2y5AHv8YhZLHvZl+DdQqrI5Z1L4QawT/FOLoQCOLR+EyTIrjcqb6YtiA4mg0/L27reYYg7JpvSVOM7G+p2uIb1iJ0hE+/DvvLW+qqfL034nLU5GQh02j8aHi/aDLS2b4ncYk/OcE+V+hhNqmF2rs1j4a1qziXYgaaDWQRetSbOwC60J8VhFSIf62k2osy7FXqpdrDAdZbuQxf5ZOCGLy6Reago9xBydmN9HBdUqX9VtUYdIKZOGbGAFxEDXjLxDmeVXsd5WIOmlhN0kqe2r84o1upy+z9KLRjY/ui5qGkhNiqoL5iXN6hPbeyGa+ckKwRM6l51Ao+EG/yKruXNsrWvHkuDPKKctS4bYRnq7eIQX+at4s8lD2ovy+D/xlXUWuf2jsNiNQx9xDRwjLAgJUSd5AvfTD80U0Qk91fP8DTkBfaXx1Qhv7FMXifZRMw0MlxtxVFVNzoOTrnjoK9ObCZy5HOwjbWgTib1kFo3BJa9t7oojdJK5RpGcifO66LQ2xuIHBvxcnMcLdEoUWc0QjVhs0k3f4dnoXvREODRB5KWJ2UFTX60WcXERxFQ7uo9mDz1YVbzQddDBHQ3QxD0MPfBnsdX+p9+xg+Sybmtum4hKoJW+CG0NGSQxP/TC0AulZ1tozfATr9Ld/QfURp1kg2FqaOQ2QBZ9JNyCoeQfO0eS+SOCa0lLshW6hnulWqHi/qrMTj6Z03gzB/LMzuaXmZXJSUm7nSKACjQDVzafbiNTqUayYpjDNpqhqIzf4SfRU/KF6S+vo0MhAS/v36BoolU4JbKQO3S3nmAL88puH0GoN6tF3vg2rCzscLVcUbmKzHS/dFroBdGk8bP4Hx8DRotKtJdMa4YZKhvR2OgbnULv+lzYUfjhFusD6KaLR8aHFSSPjYmT2MP6tU1L76u4uqJYrqawEqqpW+Onm4G6KIw2CU0Z29/EIc9gKVwjH3wxNV5v8fmxVunIGB94PxYBV+I3RRM4IO8x7Ab6ZXi3aoEeoUXmtzqHVrGCsrUYpOvIFXSMgX4YQp1Qmp6xf/Ae8gR1U19NUzEdSOjApK9nPuoItqt5HE7TXPIm3sff2fm+SbioN9GcPLltyTLKeeGBjGr668sYsfuymdjM8uHjYqL5BLn4SFqRdjbnZJKgyFHIA51lEjEebtEMfqN7LlORlgreiM3B26G2g82iqssbZBQq6k+rGn5J+MMvsVRus95vMpFR9K9K4errLmJFSMO/iepoBu6CfptR4QzqxpOYH6ERP4xmqS4uKzz3V2RS0SnMNwnYKvdW5Bd16FdS0kWlDeQ2VIMEJtgeVJ7GZIdDYQldWQ6UVK2mM1l000/MRyn5GpGZDkRbQ1RUCs/HLcMDV4hV1/OkEZFpRX+f5zfSHGQR7W2obdeiMnK3qQarTK7wEiq5vTqWXayqhyF4By5l6+HDPKK4AZtVRnoHjVBv8Syd1VocyY2UP9g8c15PpXBNVIET8MnVd8/oNlaGcnZJBZoQ7uAe4SjJAWNdX3AkNrQTQ+ClmMxO23i4nXseStC+4agkPDYeChdcOzLRJ2f/2S+ukJqsW/tvKoN4bP5/sOpHxuN5qC3p5VbaizIefWBKkKWkCc+DO5paPAHAP7wQj+VFRVp/zhPy3Ufw+8I4VsE1QVPtS1ZLf6eJ5Qr3Se3GxfURld71EhvEHJXVbLdJzUL/2nk6nX1mGcxdXUpvIg2gt7rADrkoYq0ogKbYXyK1pOwljuEO0rykAh5k2pMp6hR7rVO7h3IY2Y6gOYpsBqhWfp/sQcbbZa6m7uge0dx8pUgjd9GY5CyUldNEXX3L5JRLaHP2G5UhDtfnn8Qk3sak8Y1dUR5BatyTnyTR2PWwnCVCZe09NdwLG8tpvl3nJCd8dfzPNFMp1Wb4YuuihKIPWkP2k5I0o4OVJB96wDby2Oy2TAwv9VAxh8dFJ9EvU1S390Pdekx8d0jrxgik35GaLDoeZR7ZhH4IqyzO+/WiNzkkGNrOm8MvN4dmom9kbtuCzgy14K097SrhJuoeDEMJ7CI5Tjwn+3AmfjkUQpXUTR+DzdDPKVRgh23w1c0MUoI1EYchky6st4hefmS4bhZhr5vJ9/QYfUpbywukv9iib4S8msMqOE6iqH86px6L3oubJike6fJBB1ODDTZb6V+fAvapLL6DTGQ+2hm2k1svL8litoeKxZaRIXq2/U3HsDb6ghQBJqP4OB29iP4Lv/FaVZlctV9QM5tC1UGRbCWRBSfQs/UOFAGtlhX8VJJMLTD7VQY6HRU23ehdXAYlJHN5FlkRvXQHdDzx2I8Lx1A3sxTd8MXdOjVKH4BCOp2pIx6zrHwar6qO6uYB3FaXXdYNycNXCUNlY9TFLwq5SFuemg60UdhieVa8hml4v/2sHOsDNV1JGM5zmx/U2qKhk/lq+7jXaCuuYxaTPba1OuMHhY16GiuJVonzKBUtjEDVtwPxJP+cXUaRfD/1w5zS0Ulr9DXcQPnIK39Xdgkn+WJahGzGkI1cda/xFhfNn6KP1R7c2Y4JZSBnWK26kkJhs51E/tGk8m5oInvSjOI5risjuorqlI8X0oZh+JmKQeuhn7KLjKmvmd6iCVnIKtMH5KOM6zGu5nP5hmixMLo8Ge0P6jWyD0ukR7F0lqIPEMc/gv0OIsqZvCSug8eZ964gnYXr+LsqPmojHrG0apiIzg6TtkyHc7BHIDzTXuL/yQ38Dhsnm5OPfCorYK/LFTKPOU4xr+m/6WzydVCmPWwM5+UuN9e1Ce/8TRbfdJVzbCrWQJTUO+R8V5Ouh6m6T2jpqllYDfew5Ylcb1teraRxUFb8xxp6zFWH+eqtbIhzomc+DRunqvv3doVoKfOEJGoRKilzmAt4B69k+0FyN0m2ED5ss6NkNLTbn1LDAmHU/QDBj5oU8j9cxLxi2dUd+z5E8RfNT9NUHvApzRU/Bv1R0MEPlER9Nzuhpb/lhmsLxUJfP8EkYWdUCbyW3QzlbTco4AfhKEDNUfeY7pLt8U/a063mUaGD+4wtofwtmo0L2WWqlSxHErH0aDltYsbwqHqNq2CnuJ3qdKjJh/hlYYrsKLKwwTy2eOnzyrIMB1A0rmhiNc3Iz9tkvJt44ZqhJQ70F+jhW8CIgNQuO49/Q8bcJ5NxWlaVj6Yx/VVIZWeY2uK+zuw3hSEhIu2hE5NLfiC9p//I7vq6i6+fioJwF2Uyf2lzHoGt521FPlUJrH+AioQzvJtcJnaGEwHewSXxGFExyX7y81hVsQGng6shr9lG74TM5KdX/LyLIevpKyin6sz/Qj/0MjTQh2g594Yct6NVPL5QNUC3QlX/RR3hOXE9th5Nhf2hBswWfdVZVJsvMQNoGnOVfvNx6Qudgo9Ra/hMVJV8wdF1XQwFSYqwzgxjkVQ9kS+cZjHEhzAK6qMKYlZIjg+ZGqIvykCWBy4T0dlkBykCq33WsIAOAoJaQjH/V5w1uekes5plQOPRfBuTFmGvWRueVX9VW2V7GcccoE90CTSW7cXzaU+9hdflUeUTkk001/PDCAnbTRXb2h4jPeCZ2O0Gh1JuOu2M97PnZjBd6QrJDuqBL60+kuH4BK+Fo8uzLjmaoO4Z4DvsCpZM9DJtlWKvUEnVmTVVj/SOUFmOxBHCZV7CJJETIKA8rIuZKavxzKaxvQSlxD/exg9g130ifoH20pBJPKAz2F+bwyVUq2Qrd98mshdVNhVTtjJXSFx4wzegSfhAKECfcY1u4Wamu3pPqogO+Fu4bifDU1MZRfepxAh8EeLYn0i4Ey6NWwYD4Yhp6hfK8uiGimFPubcsYXiI/nO58QmN5V4+zm1kpdl3AtoeFLF0MT0Wbqk5KJ37rmqFTWYR+4vLsGN4BM3uGoYUJgLv5irINGiw+upKhA3qOIxkiQjVGfR+uo7dRAv4B1WLbqApcD472903Hz2T6/0jmR6G0xWmEWz2g3U7uYZF1FNgKX7PK5p85lXoGMBAMzzA17Kb+EnZmFfk/eghNI4W9r1pGjGZ14YvbIHcHQbYy/Cbb0FTcW61x83ySGRGjc0SOC/qqKE+p28MfV0hfJhNV0P4VdGQdICcYrKPz/Lb306IfSKl+66z83LiKPokGeuq4pI5oqFMzY6FSQC50RXxgifnnckXEUfkZS9kFNJCn0b38Q4aWXRRt2Rl/pLMkll4fdwuPNaRXW11xT1lBdE2KfBblwAdDz/dNhIJtSZZzFtdWq+BqHZPKB8ukbZwCkf0Ne19X1hMFAvsLZIWFyPGnTe36TC9Ej8U5Tkk8J/0Ai9JpnCJ7iLz+VWzFqqEdyaXGqSWk8I4vYovWonifKW2Iok7p8boFaozGsinis86MpknWoeJoazD4OW5UEXvcxNoUvdDdDdP5Ag7V2xypbHy/eGcjY56yF2qGQwUz1xSaE2jit++h9mpYZpqYwuYyrAGT+QlXDsjVSrUXcwiiaCxfsYOm2lmszyrh4tY/LbrY9+GQqK8+SdSyYO2qsmqbvEi+old7nrCaL1Ed7Gx8B05gJ82C1FGFds3FM9tDvUJa9E4vNJVZTLzy89i2dg4sLQmFMGZ8TkH61lUf4Q94D1xRPTYMZst/IK9vjhskJdJeTdKfXNMdOfvVR5eDS3STUlGczIYHEvdhxZ2LR1ud/NYpqYIMqEs7P6yTbIpz8eru61QjH4mg1AybF17mgESqAN4PRnl8uvTsBpT9SlsJ4tgBKtjIZXua36TRmirSIo+iqX8FIol7pKx5CNEox1EdpGC3WWR5C4/Qf+wm3Rc9Z+fhdraPGi8KsWdT0Y7idMylzVwldSXGf1MeGZSiFGe+1tin67kr6ixag26TYYaSi771i5ueEjr+U4+neqPY6H37KaEFzBGFqfpuZIXUEsyIJST01xd2walDwvtGd0Xr7al/ALSXKbRNHSh1/xe9cHVDs+1hv7ul6xPX5ppZAjlZm446vuIsuiiW+rf8Yhmil+Bc0N3Ej3UxAXcTzWdZxEhaN3HRJaX5VMyyR3jLXxZDTnkbrsM3cA1eD52UGL2imx3xA7FB2wN+c9Opo3UG3rZDeIn9Wz2kCfTRVwEesH2oCn0MRHFzZWZcHm4y8GmVp/4BBzd7pXZbBd+3Kehjfw/N0duh2e4hTmuouCuvjrbo4uZaX5DqOyT+PxsJXTBMIOfstFd2/BF/8fnyximG1rFk/Bb6AWOywqHHSYhPhjy0zjuOWSndcUAMwVVtGtDZrFT1FCF+Bboxaz+wYujXVBNPSRt3TBel3xHhVk/9xASyFLqjEhr+/FFxMh7YiKktkftn5CDNDW7xTd7kcU1MJRWMm9Vb55YbVIl5D36BxqFk6osFmqjl8GTjLp7qCnHWMPa24NoufkdWuo7+j/zxUx0N+hbaBqQW6VGia52kcsnkb1p1/I5vgo26CIertrZgMfT8jqxrkeJfAMtwmAWX95Uo/g814vXll5BStHMzzG50EN8RE4g1WgWNNwtUpG10jl8S1zZvvfT7Urzi5eCKOEtweoMJWKejoFKoTY0TliqpCCU+WsqI7ywhpzipVFyeKKikfE+o63t11qguWAP/Wau6OEQE52l5dkq3BGeqwimFMnktyn4J4uoS3aNakAj8XbqStjpC/nXpL354q/zo3SxATjjuEtpr7H5uiodjVHoivbLhvoxnCDdMdZn/RMz0x/k0UIz3lv/EdN0K3pYdrO72VeeH24La2aqJ7wjWeFLhjlus/jC89FaKC05oN6biWqpgGjYshGQTpdTP8ggEQ9mkuTmgqglsFkrE4UBUNreIbnEMHcE9xRN8P2wlZTjr0xKv1HOEvn531ApJFLt1WdXRk/UKSyjmdxIkke903Ftc7EEC1PVDiaNfToRT/c2j0km6I6mKqcW44GqobuOOyp4goU26hWewpfxE/QZaoo2+L50vx5N8rmG/IefiDeJeuqDiAUFwjqeWX3VU11fdoFn04N9PVhNJoSdZoDMztbZ42YhfaMvueW4Irkmp+sS+hlJLmL5y6aI2KYvhGr6kG1kopid1vuiNlY4aXO5KhJmmTo8AWmF8/qUugcq5rLxb7gCiunu2jnQhZ2C2CGD6gw71CMzw13kQ0xEVogsZdVtHHjLD4j7LiIvxpxswLwYRguoCG6H7isSi/qwwQ0Rp8U4/IeuNq/oSDsDfto8dJx9ExJJyVqwX3S9Hi2TazjLCsNtu1984NXMdnbPLbaTdCv1Xpf02+UTqMZe8QWquBlDKoeEtp3e6+qTa7gV+SnG+VIhOeWop/0g56o0EFf+QC1wOdwRPyJH1U/AvgPJYffZMqEtzo4jhfoiKdOyrT7uqqA1NIvricqK3ei1gBW8DwE5zM8Jl3CCUC8MRpH0EbscEoihOptLBntDP+/CH5RWLkfvQhn1TCahR/w201XcYEvUGZbJbnajXRWyh/Xgt/TqkIBOcEXkPBsZHtiaaKlMbWbDSdGf7ab3aSl51fe3qf3nMM3e9vF5W5/BwQT/21ZQ611W2YGPtb8hHbuuiBP+nG6Op6HVqJUlEMUexs1YH5qbTBILRCY2nORVUeh0V1X/hwrwJuy5u2KWupx0Bj1NXtBsuKkezra58+Ez9NGN1R3x0VRindg7mRGZMA8XNOd4jXCIL+IfXYMAN3RSbVUT+oTFdmfMOl1R72SvPQtpwl95zZUxn+g9MtnVMOvDbXVcRnOd+Hr6iDcWH0g6/xRvD99FYtwJR/YlbD05AmFUneyl71x3W17k8xNRMrnJR1djaUGxlsThY6ARjgBPUSc7kkeH/GQIKilgG+8KRCv8mVLcW+Z300I7NBzNJ0XZZhSR1OPSLmHdMOJF8Wf5HzD9K5zFFXG/sFIewu1RPFSOrULH1JTwUR1UMdUvNQAv5jHwTb3KxuWt8StXkuz3mfklNIcc0z3DPyhn9opkrClsVI/xqRBbwytYQq7gQTYNXi4bmGPyjk+CYuiHfj8fp3vDMZ+QZSRvzW6Yq7OilGQHFMfx3GyZXBa2DMa7S2YeuWeHyMy6p3lo29LNtDR3rq5Ljf+RI2guPkcHy9rkF2mJEvvqNI+4jRUs50FfgWy+u5uDaynIAq15dF4tPIB9KIp8L7PDUv1NVoWWJht6iQrIdfgcLu05vsbHBkGc5mECeyC2spv8F4rG++C80ICkoNXwOlIwXEOJzSyX23UIU0h/mklVoY9lfNdVL/E36VD20u4QbVxm6GeKyfGkEvrFUqPR/H9s/XjiBWp1EAAAAABJRU5ErkJggg=="),s={size:{width:r.width,height:r.height},format:"rgba16float",usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT},i=t.getOrCreateResource("NoiseTexture",s).raw;e.queue.copyExternalImageToTexture({source:r},{texture:i},{width:r.width,height:r.height})}async initDenoise(){}initRandomSample(){const{resourcePool:e}=this;for(let r=1;r<=8;r++)this.samplingDimensions.push(2,2,2,2);this.samples=new zr(1,this.samplingDimensions);const t={size:64*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST};this.stratifiedSamplesBuffer=e.getOrCreateResource("StratifiedSamplesBuffer",t).raw}initUniformBuffer(){const{resourcePool:e}=this,t={size:ft.getStride(),usage:ft.RES_USAGE};this.frameUniformBuffer=e.getOrCreateResource(ft.RES_NAME,t).raw,this.updateFrameUniform();const r={size:mt.getStride(),usage:mt.RES_USAGE};this.sceneUniformBuffer=e.getOrCreateResource(mt.RES_NAME,r).raw,this.updateSceneUniform()}updateFrameUniform(){const{context:e,device:t,camera:r,sampleCount:s,numUniformSamples:i}=this;0==s?(this.samples.restart(),this.strataCount=1):s==i&&(this.strataCount=6,this.samples=new zr(this.strataCount,this.samplingDimensions));const a=new Float32Array(this.samples.next());t.queue.writeBuffer(this.stratifiedSamplesBuffer,0,a);let n=0,o=0;n=(Math.random()-.5)/e.width,o=(Math.random()-.5)/e.height,this.enableDenoise&&this.gBufferPass.updateUniform(r);const l=new ft({viewToWorldMat:r.viewToWorldMat,clipToViewMat:r.clipToViewMat,sampleCount:s,strataSize:1/this.strataCount,jitter:[n,o],cameraAperture:r.aperture,cameraFocus:r.focus}).toArrayBuffer();t.queue.writeBuffer(this.frameUniformBuffer,0,l)}updateSceneUniform(){const{device:e,renderSetting:t}=this,{renderSize:r,bounces:s,backgroundColor:i,enableBackgroundColor:a,backgroundAlpha:n,envMapIntensity:o,envRotMatrix:l,invEnvRotMatrix:u,totalSumValue:c,lightNum:d}=t,h=new mt({envRotMatrix:l.toWebGPUFormat(),invEnvRotMatrix:u.toWebGPUFormat(),backgroundColor:i,envMapIntensity:o,renderSize:r,bounces:s,enableBackgroundColor:a,backgroundAlpha:n,totalSumValue:c,lightNum:d}).toArrayBuffer();e.queue.writeBuffer(this.sceneUniformBuffer,0,h)}async updateScene(e,t){const{camera:r}=this;this.renderSetting=ie(e,0,t),await this.integratorPass.createPipeline(this.renderSetting),this.accumulatePass.syncRenderSetting(this.renderSetting),await this.gBufferPass.createPipeline(this.renderSetting,e,r)}async updateMaterialParams(e){this.renderSetting.enableSSS=e.includeSSS,await this.integratorPass.createPipeline(this.renderSetting),this.gBufferPass.forceUpdateBG()}initTileBuffer(){const{resourcePool:e}=this;this.tileUniformBuffer=e.getOrCreateResource(gt.RES_NAME,{size:gt.getStride(),usage:gt.RES_USAGE}).raw,this.updateTileUniform()}updateTileNumber(e){this.tileCalculator.setTileCount(e),this.reset()}setTileCountSyncRender(e){this.tileCalculator.setTileCount(e),this.updateTileUniform(),this.syncAllPassTileRenderSetting(!1,0,0,0,0),this.tileCalculator.reset()}updateTileUniform(){if(!this.tileUniformBuffer)return;const{device:e,tileOffset:t,tileSize:r,enableTileRender:s,sampleCount:i}=this,a=new gt({tileOffset:t,tileSize:r,tileEnable:Number(s&&i>this.tilePreFullSample)}).toArrayBuffer();e.queue.writeBuffer(this.tileUniformBuffer,0,a)}syncTracerSetting(e){Object.assign(this.renderSetting,e),this.updateSceneUniform(),this.screenPass.setToneMapping(e.toneMapping)}updateRenderSize(e){this.screenPass.setDownsamplingFactor(e),this.accumulatePass.syncRenderSize(),this.reset()}syncAllPassTileRenderSetting(e,t,r,s,i){this.integratorPass.syncTileRenderSetting(e,t,r,s,i)}reset(){this.sampleCount=0,this.pipelineConfig.needsClean=!0,this.updateTileUniform(),this.syncAllPassTileRenderSetting(!1,0,0,0,0),this.tileCalculator.reset()}setSize(){this.rg.setSize(),this.screenPass.setSize(),this.gBufferPass.setSize(),this.tileCalculator.setSize(),this.reset()}updateBindingGroup(){this.rg.forceUpdateBG()}addPass(){this.needsUpdateBG&&(this.updateBindingGroup(),this.needsUpdateBG=!1);const{rg:e,enableDenoise:t}=this;e.addPass(Zt.ID,this.integratorPass),e.addPass(Kt.ID,this.accumulatePass),t&&e.addPass(Vt.ID,this.gBufferPass),this.screenPass.setInputPass(Kt.ID),e.addPass(dt.ID,this.screenPass)}renderFull(e){this.updateFrameUniform(),this.integratorPass.tileSetting.enable=!1,this.addPass(),this.rg.execute(e),this.sampleCount++}renderTile(e){const{x:t,y:r,tileWidth:s,tileHeight:i,isFirstTile:a,isLastTile:n}=this.tileCalculator.nextTile();a&&this.updateFrameUniform(),this.tileOffset=[t,r],this.tileSize=[s,i],this.updateTileUniform(),this.syncAllPassTileRenderSetting(!0,t,r,s,i),this.addPass(),this.rg.execute(e),n&&this.sampleCount++}render(e){var t;const{pipelineConfig:r}=this;if(r.needsClean){const s=null==(t=this.resourcePool.getResourceByName("RTLightTexture"))?void 0:t.raw;s&&this.clearTexPass.clear(e,s),r.needsClean=!1}this.enableTileRender&&this.sampleCount>this.tilePreFullSample?this.renderTile(e):this.renderFull(e)}}navigator.gpu&&navigator.gpu.getPreferredCanvasFormat||(window.GPUBufferUsage={},window.GPUTextureUsage={});var Cr=(e=>(e[e.Linear=0]="Linear",e[e.ACES=1]="ACES",e[e.Neutral=2]="Neutral",e))(Cr||{});class Fr{constructor(r,s,i={}){this.pixelRatio=1,this.geoType="Mesh",this.integrator="PT",this.targetSampleCount=0,this._viewportSize=[],this._downsamplingSize=[],this.inited=!1,this.isBuilding=!1,this.needsUpdate=!1,this.movingDownsampling=H,this._bounces=2,this._backgroundColor=new t,this._enableBackgroundColor=!1,this._backgroundAlpha=1,this._envMapIntensity=1,this._envRotation=0,this._envRotMatrix=new l,this._totalSumValue=0,this._invEnvRotMatrix=new l,this._toneMapping="Linear",this._preSampleCount=0,this._downsamplingFactor=K,this._enableTileRender=Z,this._tileNumber=O,this._enableDenoise=Y,this.forceUpdateOneFullSample=!1,this.forceDownsamplingDraw=!1,this.onBuildingBeginCallback=()=>{},this.onBuildingProgressCallback=e=>{},this.onBuildingEndCallback=()=>{},this.onSampleFinCallback=()=>{},this.device=r,this.adapter=s,this.canvas=i.canvas||document.createElement("canvas"),this.canvasAlpha=null==i.canvasAlpha||i.canvasAlpha,this.sceneMode=i.sceneMode||"Static",this.useWebWorker=null==i.useWebWorker||i.useWebWorker,this.renderToScreen=null==i.renderToScreen||i.renderToScreen,this.rg=new Q(r),this.environmentLoader=new Be(r,this.rg.resourcePool),this.context=new e(this.device,this.canvas,this.pixelRatio,this.canvasAlpha),this.renderer=new Xr(this.device,this.context,this.rg),"Static"==this.sceneMode?this.sceneBuilder=new Rr(r,this.rg.resourcePool):this.sceneBuilder=new wr(r,this.rg.resourcePool,this.useWebWorker),this.featureOption={supportSGWorkflow:!0,supportUVTrans:!0,supportTexWrap:!0,supportLightSource:!0,supportAlpha:!0,supportAlphaShadow:!0,supportAbsorption:!1,supportCastShadow:!1},i.featureOption&&Object.assign(this.featureOption,i.featureOption),this.rayParamsOption={maxAlphaDepth:5,minIntersectDistance:1e-4},i.rayParamsOption&&Object.assign(this.rayParamsOption,i.rayParamsOption)}set bounces(e){this._bounces=Le(e,2,8),this._syncTracerSetting()}get bounces(){return this._bounces}set envMapIntensity(e){this._envMapIntensity=e,this._syncTracerSetting()}get envMapIntensity(){return this._envMapIntensity}set enableBackgroundColor(e){this._enableBackgroundColor=e,this._syncTracerSetting()}get enableBackgroundColor(){return this._enableBackgroundColor}set backgroundColor(e){"string"==typeof e?this._backgroundColor.fromHex(e):Array.isArray(e)&&this._backgroundColor.fromArray(e),this._backgroundColor.SRGBToLinear(),this._syncTracerSetting()}get backgroundColor(){return this._backgroundColor}set backgroundAlpha(e){this._backgroundAlpha=e,this._syncTracerSetting()}get backgroundAlpha(){return this._backgroundAlpha}set envRotation(e){this._envRotation=e;let t=function(e){return e*Math.PI/180}(e);this._envRotMatrix.fromMatrix4((new n).rotateY(t)),this._invEnvRotMatrix.inverse(this._envRotMatrix),this._syncTracerSetting()}get envRotation(){return this._envRotation}set toneMapping(e){this._toneMapping=e,this.forceUpdateOneFullSample=!0,this._syncTracerSetting()}get toneMapping(){return this._toneMapping}set downsamplingFactor(e){this._downsamplingFactor=Math.floor(Math.max(e,1)),this._downsamplingSize=[this._viewportSize[0]/this._downsamplingFactor,this._viewportSize[1]/this._downsamplingFactor]}get downsamplingFactor(){return this._downsamplingFactor}get sampleCount(){return this.renderer.sampleCount}get size(){return this._viewportSize}set enableTileRender(e){this._enableTileRender=e,this.renderer.enableTileRender=e,this.renderer.reset()}get enableTileRender(){return this._enableTileRender}set tileNumber(e){this._tileNumber=e,this.renderer.updateTileNumber(e)}get tileNumber(){return this._tileNumber}set enableDenoise(e){this._enableDenoise=e,this.renderer.enableDenoise=e,this.forceUpdateOneFullSample=!0}get enableDenoise(){return this._enableDenoise}_syncSeparateRenderModeSetting(){const{enableTileRender:e,tileNumber:t}=this;let r=this.renderer;r.enableTileRender=e,r.tileCalculator.setSize(),r.updateTileNumber(t)}_syncTracerSetting(){const{context:e,geoType:t,integrator:r,sceneMode:s,bounces:i,backgroundColor:a,enableBackgroundColor:n,backgroundAlpha:o,canvasAlpha:l,envMapIntensity:u,featureOption:c,rayParamsOption:d,renderToScreen:h,_envRotMatrix:p,_invEnvRotMatrix:f,_toneMapping:m,_totalSumValue:g}=this;this.tracerSetting={renderSize:[e.width,e.height],geoType:t,integrator:r,sceneMode:s,bounces:i,backgroundColor:a,enableBackgroundColor:n,backgroundAlpha:o,envMapIntensity:u,envRotMatrix:p,invEnvRotMatrix:f,totalSumValue:g,toneMapping:Cr[m],supportCanvasAlpha:l,supportSGWorkflow:c.supportSGWorkflow,supportUVTrans:c.supportUVTrans,supportTexWrap:c.supportTexWrap,supportLightSource:c.supportLightSource,supportAlpha:c.supportAlpha,supportAlphaShadow:c.supportAlphaShadow,supportAbsorption:c.supportAbsorption,supportCastShadow:c.supportCastShadow,maxAlphaDepth:d.maxAlphaDepth,minIntersectDistance:d.minIntersectDistance,renderToScreen:h},this.inited&&this.renderer.syncTracerSetting(this.tracerSetting)}_updateRenderSizeSetting(e,t=1){this.tracerSetting.renderSize=[e[0],e[1]],this.inited&&(this.renderer.syncTracerSetting(this.tracerSetting),this.renderer.updateRenderSize(t))}async buildPipeline(e,t){const{sceneInfo:r,camera:s}=function(e,t){return{sceneInfo:ue(e,!0),camera:de(t)}}(e,t);this.sceneInfo=r,this.camera=s,this.onBuildingBeginCallback&&this.onBuildingBeginCallback(),this.environmentLoader.load(this.environment),this._totalSumValue=this.environmentLoader.totalSumValue,this._syncTracerSetting(),await this.sceneBuilder.build(r,this.onBuildingProgressCallback),await this.renderer.buildPipeline(r,s,this.tracerSetting),this.setSize(this.canvas.width/this.pixelRatio,this.canvas.height/this.pixelRatio),this._syncSeparateRenderModeSetting(),this.inited=!0,this.onBuildingEndCallback&&this.onBuildingEndCallback()}getRenderResGPUTexture(){if(!this.renderToScreen)return this.rg.getRawResFromPool("ScreenPassOutputTexture");console.error("Need to set init tracer renderToScreen to false first")}getGBufferResGPUTexture(){return{albedoTex:this.rg.getRawResFromPool("GBufferOutputColorTexture"),normalTex:this.rg.getRawResFromPool("GBufferOutputNormalTexture")}}getMeshByTHREEID(e){const{meshes:t}=this.sceneInfo,r=`LGL_${e}`;return t.find((e=>r==e.id))}getLightByTHREEID(e){const{lights:t}=this.sceneInfo,r=`LGL_${e}`;return t.find((e=>r==e.id))}static linkMeshWithTHREEMesh(e,t){var r;e.id=`LGL_${t.id}`,e.name=`LGL_${t.name}`,e.tlasMask=!!(null==(r=t.userData)?void 0:r.lgl_tlasMask),e.visible=t.visible,e.localToWorldMat.fromArray(t.matrixWorld.elements)}static linkLightWithTHREELight(e,t){e.id=`LGL_${t.id}`,e.name=`LGL_${t.name}`,e.visible=t.visible}async addMeshFromTHREE(e){if("Static"==this.sceneMode)return void console.error("SceneMode need to be Dynamic!");if(this.isBuilding)return;this.isBuilding=!0;const{sceneInfo:t}=this,{geometryConvertMap:r}=t;let s=ge(e.material),i=r.get(e.geometry.id);const a=!i;a&&(i=pe(e.geometry),r.set(e.geometry.id,i));const n=new z(i,s);if(Fr.linkMeshWithTHREEMesh(n,e),a)return this.sceneInfo.meshes.push(n),await this.sceneBuilder.addMeshesToBLAS(this.sceneInfo,[n],this.onBuildingProgressCallback),await this.updateSceneStructure(s.isIncludeTexture()),this.rg.forceUpdateBG(),this.needsUpdate=!0,this.isBuilding=!1,n;this.addTracerInstanceMeshes([n])}async removeMeshFromTHREE(e){const t=this.getMeshByTHREEID(e.id),{meshes:r}=this.sceneInfo;if(!r.length)return;if(this.isBuilding)return;this.isBuilding=!0;const s=r.indexOf(t);r.splice(s,1),await this.updateSceneStructure(),this.rg.forceUpdateBG(),this.needsUpdate=!0,this.isBuilding=!1}cloneMeshFromTHREE(e,t,r=!0){const s=this.getMeshByTHREEID(e).clone(r);return Fr.linkMeshWithTHREEMesh(s,t),s}updateMeshTransformFromTHREE(e){e.updateMatrixWorld(!0);this.getMeshByTHREEID(e.id).localToWorldMat.fromArray(e.matrixWorld.toArray())}async updateMeshMaterialParamsFromTHREE(e){ge(e.material,this.getMeshByTHREEID(e.id).material),await this.updateMaterialParams()}updateTextureParamsFromTHREE(e){fe(e.material,this.getMeshByTHREEID(e.id).material),this.sceneBuilder.updateUVTransBuffer(this.sceneInfo),this.needsUpdate=!0}async rebuildMeshMaterialFromTHREE(e){if(this.isBuilding)return;this.isBuilding=!0;const t=ge(e.material);if(this.getMeshByTHREEID(e.id).material=t,"Dynamic"==this.sceneMode)await this.updateSceneStructure(t.isIncludeTexture());else{const e=le(this.sceneInfo.meshes);this.sceneInfo.materialIndexMap=e,this.sceneInfo.materials=Array.from(e.keys()),await this.sceneBuilder.rebuildMaterialRelated(this.sceneInfo)}this.rg.forceUpdateBG(),this.needsUpdate=!0,this.isBuilding=!1}addLightFromTHREE(e){const t=ce(e);this.sceneInfo.lights.push(t),Fr.linkLightWithTHREELight(t,e),this.sceneBuilder.updateLightBuffer(this.sceneInfo),this.renderer.renderSetting.lightNum=this.sceneInfo.lights.length,this.renderer.updateSceneUniform(),this.needsUpdate=!0}removeLightFromTHREE(e){const{lights:t}=this.sceneInfo,r=this.getLightByTHREEID(e.id);if(!t.length||!r)return;const s=t.indexOf(r);t.splice(s,1),this.sceneBuilder.updateLightBuffer(this.sceneInfo),this.renderer.renderSetting.lightNum=this.sceneInfo.lights.length,this.renderer.updateSceneUniform(),this.needsUpdate=!0}updateLightFromTHREE(e){const t=this.getLightByTHREEID(e.id),r=ce(e);t.copy(r),this.sceneBuilder.updateLightBuffer(this.sceneInfo),this.needsUpdate=!0}async addSceneFromTHREE(e){if(this.isBuilding)return;this.isBuilding=!0,this.onBuildingBeginCallback&&this.onBuildingBeginCallback();const t=this.sceneInfo.geometryConvertMap.size,r=ue(e,!1,this.sceneInfo.geometryConvertMap),s=r.meshes,i=s.some((e=>e.material.isIncludeTexture())),a=t!=this.sceneInfo.geometryConvertMap.size;this.sceneInfo.meshes.push(...s),a&&(this.sceneInfo.geometryConvertMap=new Map([...this.sceneInfo.geometryConvertMap,...r.geometryConvertMap]),await this.sceneBuilder.addMeshesToBLAS(this.sceneInfo,s,this.onBuildingProgressCallback)),await this.updateSceneStructure(i),r.includeSSS&&!this.sceneInfo.includeSSS&&(this.sceneInfo.includeSSS=r.includeSSS,await this.renderer.updateMaterialParams(this.sceneInfo)),this.rg.forceUpdateBG(),this.needsUpdate=!0,this.isBuilding=!1,this.onBuildingEndCallback&&this.onBuildingEndCallback()}async replaceMainSceneFromTHREE(e){if(this.isBuilding)return;this.isBuilding=!0,this.onBuildingBeginCallback&&this.onBuildingBeginCallback();const t=ue(e);await this.sceneBuilder.build(t,this.onBuildingProgressCallback),this.sceneInfo=t,await this.renderer.updateScene(t,this.tracerSetting),this.renderer.needsUpdateBG=!0,this.needsUpdate=!0,this.isBuilding=!1,this.onBuildingEndCallback&&this.onBuildingEndCallback()}setMeshTLASMaskStatusFromTHREE(e,t){const r=this.getMeshByTHREEID(e.id);return r&&(r.tlasMask=t),r}setMeshVisibleFromTHREE(e,t){const r=this.getMeshByTHREEID(e.id);return r&&(r.visible=t),r}syncGroupVisibleFromTHREE(e){var t;if(e.isLight)this.updateLightFromTHREE(e);else{if(e.isMesh){const t=Me(e);this.setMeshTLASMaskStatusFromTHREE(e,!t)}else null!=(null==(t=null==e?void 0:e.children)?void 0:t.length)&&e.traverse((e=>{const t=e;if(t.isMesh){const e=Me(t);this.setMeshTLASMaskStatusFromTHREE(t,!e)}}));this.rebuildTLAS()}}async syncCastShadowStatusFromTHREE(e){this.featureOption.supportCastShadow?(Array.isArray(e)||(e=[e]),e.forEach((e=>{const t=this.getMeshByTHREEID(e.id).material;"Metalness"==t.workflow?t.glossiness=e.castShadow?1:0:t.roughness=e.castShadow?1:0})),await this.updateMaterialParams()):console.error("Need to set tracer.featureOption.supportCastShadow to true first!")}async addTracerInstanceMeshes(e){if(this.isBuilding||!e.length)return;this.isBuilding=!0,this.sceneInfo.meshes.push(...e);const t=e.some((e=>e.material.isIncludeTexture()));await this.updateSceneStructure(t),this.rg.forceUpdateBG(),this.needsUpdate=!0,this.isBuilding=!1}updateEnvLight(e){this.environment=e,this.environmentLoader.load(this.environment),this._totalSumValue=this.environmentLoader.totalSumValue,this._syncTracerSetting(),this.renderer.needsUpdateBG=!0,this.needsUpdate=!0}async updateMaterialParams(){this.isBuilding||(this.isBuilding=!0,function(e){const{materials:t}=e;let r=!1;t.forEach((e=>{e.subsurface>0&&(r=!0)})),e.includeSSS=r}(this.sceneInfo),await this.renderer.updateMaterialParams(this.sceneInfo),this.sceneBuilder.updateMaterialParams(this.sceneInfo),this.renderer.needsUpdateBG=!0,this.renderer.reset(),this.isBuilding=!1)}updateTLAS(){"Static"==this.sceneMode||this.isBuilding||(this.sceneBuilder.rebuildTLAS(this.sceneInfo),this.needsUpdate=!0,this.forceDownsamplingDraw=!0)}rebuildTLAS(){"Static"==this.sceneMode||this.isBuilding||(this.sceneBuilder.rebuildTLAS(this.sceneInfo,!0),this.rg.forceUpdateBG(),this.needsUpdate=!0)}async rebuildBVH(){"Dynamic"==this.sceneMode||this.isBuilding||(this.isBuilding=!0,await this.sceneBuilder.rebuildBVH(this.sceneInfo),this.rg.forceUpdateBG(),this.isBuilding=!1,this.needsUpdate=!0)}async updateSceneStructure(e=!1){if("Static"==this.sceneMode)return void console.error("SceneMode need to be Dynamic!");const t=le(this.sceneInfo.meshes);this.sceneInfo.materialIndexMap=t,this.sceneInfo.materials=Array.from(t.keys()),await this.sceneBuilder.rebuildMaterialBuffer(this.sceneInfo,e),this.renderer.gBufferPass.initMeshUniformBuffer(),this.renderer.gBufferPass.forceUpdateBG(),this.sceneBuilder.rebuildTLAS(this.sceneInfo,!0)}areCamerasEqual(e,t){return e.type!=t.type?(t=e.clone(),!1):"OrthographicCamera"===e.type?ye(e.viewToWorldMat,t.viewToWorldMat)&&e.zoom==t.zoom:ye(e.viewToWorldMat,t.viewToWorldMat)}syncCamera(e){if(!e)throw new Error("Need to pass camera into render(camera) method!");e.updateMatrixWorld(!0),de(e,this.renderer.camera)}setTileCountSyncRender(e){this._tileNumber=e,this.renderer.setTileCountSyncRender(e)}setSize(e,t,r=!0){const{canvas:s,context:i,_downsamplingFactor:a}=this,n=Math.floor(e*i.pixelRatio),o=Math.floor(t*i.pixelRatio);s.width=n,s.height=o,this._viewportSize=[n,o],this._downsamplingSize=[n/a,o/a],r&&(s.style.width=`${e}px`,s.style.height=`${t}px`),this._updateRenderSizeSetting(this._viewportSize),this.inited&&this.renderer.setSize()}setPixelRatio(e,t=!1){const{context:r,_viewportSize:s}=this;r.pixelRatio=e,this.setSize(s[0]/e,s[1]/e,t)}setCanvasSizeByPixelRatio(e){const{canvas:t,context:r,_downsamplingFactor:s}=this,i=[Se(t.style.width),Se(t.style.height)];r.pixelRatio=e;const a=Math.floor(i[0]*r.pixelRatio),n=Math.floor(i[1]*r.pixelRatio);this._viewportSize=[a,n],this._downsamplingSize=[a/s,n/s],t.width=a,t.height=n}renderCommand(e,t=!1){const{device:r}=this,{camera:s,lastCamera:i}=this.renderer;this._preSampleCount=this.renderer.sampleCount,0!==this.targetSampleCount&&this._preSampleCount>=this.targetSampleCount&&!this.forceUpdateOneFullSample||(this.renderer.enableTileRender=this.enableTileRender&&!t,this.renderer.render(e),r.queue.submit([e.finish()]),i.copy(s),this.onSampleFinCallback&&this._preSampleCount!=this.renderer.sampleCount&&r.queue.onSubmittedWorkDone().then((()=>{"function"==typeof this.onSampleFinCallback&&this.onSampleFinCallback()})),this._preSampleCount!=this.renderer.sampleCount&&this.forceUpdateOneFullSample&&(this.forceUpdateOneFullSample=!1))}render(e){if(!this.inited||this.isBuilding)return;this.syncCamera(e);const{_downsamplingSize:t,downsamplingFactor:r,movingDownsampling:s,_viewportSize:i,tracerSetting:a}=this,{device:n,camera:o,lastCamera:l}=this.renderer,u=n.createCommandEncoder();if(!this.areCamerasEqual(o,l)||this.forceDownsamplingDraw){if(this.forceDownsamplingDraw&&(this.forceDownsamplingDraw=!1),s)return this._updateRenderSizeSetting(t,r),void this.renderCommand(u,!0);this.renderer.reset()}a.renderSize[0]==i[0]&&a.renderSize[1]==i[1]||this._updateRenderSizeSetting(i),this.needsUpdate&&(this.needsUpdate=!1,this.renderer.reset()),this.renderCommand(u)}dispose(){this.rg.resourcePool.destroy()}}export{Fr as LGLTracer,W as Light,z as Mesh,N as PrincipledBSDFMaterial};
