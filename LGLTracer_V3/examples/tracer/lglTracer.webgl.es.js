const t=["EXT_color_buffer_float"],e=["OES_texture_float_linear"],n=4,a=!0,i=!0,s=4,r=!1,o=.05,l=.02,c=.35;class u extends Array{constructor(t=0,e=t,n=e){return"string"==typeof t&&([t,e,n]=u.hexToRGB(t)),t>1&&(t/=255,e/=255,n/=255),super(t,e,n),this}get isColor(){return!0}get r(){return this[0]}set r(t){this[0]=t}get g(){return this[1]}set g(t){this[1]=t}get b(){return this[2]}set b(t){this[2]=t}set(t,e,n){return"string"==typeof t&&([t,e,n]=u.hexToRGB(t)),t.length?this.copy(t):(this[0]=t,this[1]=e,this[2]=n,this)}copy(t){return this[0]=t[0],this[1]=t[1],this[2]=t[2],this}fromHex(t){const e=u.hexToRGB(t);this.fromArray(e)}getHex(){const[t,e,n]=this,a=t=>Math.round(255*t).toString(16).padStart(2,"0");return`#${a(t)}${a(e)}${a(n)}`}static hexToRGB(t){4===t.length&&(t=t[0]+t[1]+t[1]+t[2]+t[2]+t[3]+t[3]);const e=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(t);return e||console.warn(`Unable to convert hex string ${t} to rgb values`),[parseInt(e[1],16)/255,parseInt(e[2],16)/255,parseInt(e[3],16)/255]}static rgbToHex(t){t.length&&3==t.length||console.error(`Unable to convert rgb array ${t} to hex value`);let e="#";for(let n=0;n<t.length;n++){let a=Number(t[n]).toString(16);a.length<2&&(a="0"+a),e+=a}return e}static hslToRGB(t,e,n){let a,i,s;if(0==e)a=i=s=n;else{let r=function(t,e,n){return n<0&&(n+=1),n>1&&(n-=1),n<1/6?t+6*(e-t)*n:n<.5?e:n<2/3?t+(e-t)*(2/3-n)*6:t},o=n<.5?n*(1+e):n+e-n*e,l=2*n-o;a=r(l,o,t+1/3),i=r(l,o,t),s=r(l,o,t-1/3)}return[a,i,s]}static rgbToHsl(t,e,n){t/=255,e/=255,n/=255;let a,i,s=Math.max(t,e,n),r=Math.min(t,e,n),o=(s+r)/2;if(s==r)a=i=0;else{let l=s-r;switch(i=o>.5?l/(2-s-r):l/(s+r),s){case t:a=(e-n)/l+(e<n?6:0);break;case e:a=(n-t)/l+2;break;case n:a=(t-e)/l+4}a/=6}return[a,i,o]}static rgbToHsv(t,e,n){let a,i,s;t/=255,e/=255,n/=255;let r=Math.min(t,e,n),o=s=Math.max(t,e,n),l=o-r;if(o==r)a=0;else{switch(o){case t:a=(e-n)/l+(e<n?6:0);break;case e:a=2+(n-t)/l;break;case n:a=4+(t-e)/l}a=Math.round(60*a)}return i=0==o?0:1-r/o,i=Math.round(100*i),s=Math.round(100*s),[a,i,s]}fromArray(t,e=0){return this[0]=t[e],this[1]=t[e+1],this[2]=t[e+2],this}toArray(){return Array.from(this)}SRGBToLinearSingle(t){return t<.04045?.0773993808*t:Math.pow(.9478672986*t+.0521327014,2.4)}SRGBToLinear(){return this[0]=this.SRGBToLinearSingle(this[0]),this[1]=this.SRGBToLinearSingle(this[1]),this[2]=this.SRGBToLinearSingle(this[2]),this}LinearToSRGBSingle(t){return t<.0031308?12.92*t:1.055*Math.pow(t,.41666)-.055}LinearToSRGB(){return this[0]=this.LinearToSRGBSingle(this[0]),this[1]=this.LinearToSRGBSingle(this[1]),this[2]=this.LinearToSRGBSingle(this[2]),this}luminance(){return.2126*this[0]+.7152*this[1]+.0722*this[2]}addColor(t,e){return this[0]=t[0]+e[0],this[1]=t[1]+e[1],this[2]=t[2]+e[2],this}scale(t){return this[0]=this[0]*t,this[1]=this[1]*t,this[2]=this[2]*t,this}}function d(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function f(t,e,n){let a=e[0],i=e[1],s=e[2],r=e[3],o=e[4],l=e[5],c=e[6],u=e[7],d=e[8],f=e[9],h=e[10],p=e[11],m=e[12],x=e[13],T=e[14],g=e[15],v=n[0],S=n[1],b=n[2],A=n[3];return t[0]=v*a+S*o+b*d+A*m,t[1]=v*i+S*l+b*f+A*x,t[2]=v*s+S*c+b*h+A*T,t[3]=v*r+S*u+b*p+A*g,v=n[4],S=n[5],b=n[6],A=n[7],t[4]=v*a+S*o+b*d+A*m,t[5]=v*i+S*l+b*f+A*x,t[6]=v*s+S*c+b*h+A*T,t[7]=v*r+S*u+b*p+A*g,v=n[8],S=n[9],b=n[10],A=n[11],t[8]=v*a+S*o+b*d+A*m,t[9]=v*i+S*l+b*f+A*x,t[10]=v*s+S*c+b*h+A*T,t[11]=v*r+S*u+b*p+A*g,v=n[12],S=n[13],b=n[14],A=n[15],t[12]=v*a+S*o+b*d+A*m,t[13]=v*i+S*l+b*f+A*x,t[14]=v*s+S*c+b*h+A*T,t[15]=v*r+S*u+b*p+A*g,t}function h(t,e){let n=e[0]+e[5]+e[10],a=0;return n>0?(a=2*Math.sqrt(n+1),t[3]=.25*a,t[0]=(e[6]-e[9])/a,t[1]=(e[8]-e[2])/a,t[2]=(e[1]-e[4])/a):e[0]>e[5]&&e[0]>e[10]?(a=2*Math.sqrt(1+e[0]-e[5]-e[10]),t[3]=(e[6]-e[9])/a,t[0]=.25*a,t[1]=(e[1]+e[4])/a,t[2]=(e[8]+e[2])/a):e[5]>e[10]?(a=2*Math.sqrt(1+e[5]-e[0]-e[10]),t[3]=(e[8]-e[2])/a,t[0]=(e[1]+e[4])/a,t[1]=.25*a,t[2]=(e[6]+e[9])/a):(a=2*Math.sqrt(1+e[10]-e[0]-e[5]),t[3]=(e[1]-e[4])/a,t[0]=(e[8]+e[2])/a,t[1]=(e[6]+e[9])/a,t[2]=.25*a),t}function p(t,e){let n=e[0],a=e[1],i=e[2],s=e[3],r=n+n,o=a+a,l=i+i,c=n*r,u=a*r,d=a*o,f=i*r,h=i*o,p=i*l,m=s*r,x=s*o,T=s*l;return t[0]=1-d-p,t[1]=u+T,t[2]=f-x,t[3]=0,t[4]=u-T,t[5]=1-c-p,t[6]=h+m,t[7]=0,t[8]=f+x,t[9]=h-m,t[10]=1-c-d,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}class m extends Array{constructor(t=1,e=0,n=0,a=0,i=0,s=1,r=0,o=0,l=0,c=0,u=1,d=0,f=0,h=0,p=0,m=1){return super(t,e,n,a,i,s,r,o,l,c,u,d,f,h,p,m),this}get isMatrix4(){return!0}set x(t){this[12]=t}get x(){return this[12]}set y(t){this[13]=t}get y(){return this[13]}set z(t){this[14]=t}get z(){return this[14]}set w(t){this[15]=t}get w(){return this[15]}set(t,e,n,a,i,s,r,o,l,c,u,d,f,h,p,m){return t.length?this.copy(t):(function(t,e,n,a,i,s,r,o,l,c,u,d,f,h,p,m,x){t[0]=e,t[1]=n,t[2]=a,t[3]=i,t[4]=s,t[5]=r,t[6]=o,t[7]=l,t[8]=c,t[9]=u,t[10]=d,t[11]=f,t[12]=h,t[13]=p,t[14]=m,t[15]=x}(this,t,e,n,a,i,s,r,o,l,c,u,d,f,h,p,m),this)}translate(t,e=this){return function(t,e,n){let a,i,s,r,o,l,c,u,d,f,h,p,m=n[0],x=n[1],T=n[2];e===t?(t[12]=e[0]*m+e[4]*x+e[8]*T+e[12],t[13]=e[1]*m+e[5]*x+e[9]*T+e[13],t[14]=e[2]*m+e[6]*x+e[10]*T+e[14],t[15]=e[3]*m+e[7]*x+e[11]*T+e[15]):(a=e[0],i=e[1],s=e[2],r=e[3],o=e[4],l=e[5],c=e[6],u=e[7],d=e[8],f=e[9],h=e[10],p=e[11],t[0]=a,t[1]=i,t[2]=s,t[3]=r,t[4]=o,t[5]=l,t[6]=c,t[7]=u,t[8]=d,t[9]=f,t[10]=h,t[11]=p,t[12]=a*m+o*x+d*T+e[12],t[13]=i*m+l*x+f*T+e[13],t[14]=s*m+c*x+h*T+e[14],t[15]=r*m+u*x+p*T+e[15])}(this,e,t),this}rotateX(t,e=this){return function(t,e,n){let a=Math.sin(n),i=Math.cos(n),s=e[4],r=e[5],o=e[6],l=e[7],c=e[8],u=e[9],d=e[10],f=e[11];e!==t&&(t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15]),t[4]=s*i+c*a,t[5]=r*i+u*a,t[6]=o*i+d*a,t[7]=l*i+f*a,t[8]=c*i-s*a,t[9]=u*i-r*a,t[10]=d*i-o*a,t[11]=f*i-l*a}(this,e,t),this}rotateY(t,e=this){return function(t,e,n){let a=Math.sin(n),i=Math.cos(n),s=e[0],r=e[1],o=e[2],l=e[3],c=e[8],u=e[9],d=e[10],f=e[11];e!==t&&(t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15]),t[0]=s*i-c*a,t[1]=r*i-u*a,t[2]=o*i-d*a,t[3]=l*i-f*a,t[8]=s*a+c*i,t[9]=r*a+u*i,t[10]=o*a+d*i,t[11]=l*a+f*i}(this,e,t),this}rotateZ(t,e=this){return function(t,e,n){let a=Math.sin(n),i=Math.cos(n),s=e[0],r=e[1],o=e[2],l=e[3],c=e[4],u=e[5],d=e[6],f=e[7];e!==t&&(t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=e[11],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15]),t[0]=s*i+c*a,t[1]=r*i+u*a,t[2]=o*i+d*a,t[3]=l*i+f*a,t[4]=c*i-s*a,t[5]=u*i-r*a,t[6]=d*i-o*a,t[7]=f*i-l*a}(this,e,t),this}scale(t,e=this){return function(t,e,n){let a=n[0],i=n[1],s=n[2];t[0]=e[0]*a,t[1]=e[1]*a,t[2]=e[2]*a,t[3]=e[3]*a,t[4]=e[4]*i,t[5]=e[5]*i,t[6]=e[6]*i,t[7]=e[7]*i,t[8]=e[8]*s,t[9]=e[9]*s,t[10]=e[10]*s,t[11]=e[11]*s,t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15]}(this,e,"number"==typeof t?[t,t,t]:t),this}multiply(t,e){return e?f(this,t,e):f(this,this,t),this}identity(){return d(this),this}copy(t){var e,n;return n=t,(e=this)[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],e[6]=n[6],e[7]=n[7],e[8]=n[8],e[9]=n[9],e[10]=n[10],e[11]=n[11],e[12]=n[12],e[13]=n[13],e[14]=n[14],e[15]=n[15],this}fromPerspective({fov:t,aspect:e,near:n,far:a}={}){return function(t,e,n,a,i){let s=1/Math.tan(e/2),r=1/(a-i);t[0]=s/n,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=s,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=(i+a)*r,t[11]=-1,t[12]=0,t[13]=0,t[14]=2*i*a*r,t[15]=0}(this,t,e,n,a),this}fromOrthogonal({left:t,right:e,bottom:n,top:a,near:i,far:s}){return function(t,e,n,a,i,s,r){let o=1/(e-n),l=1/(a-i),c=1/(s-r);t[0]=-2*o,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=-2*l,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=2*c,t[11]=0,t[12]=(e+n)*o,t[13]=(i+a)*l,t[14]=(r+s)*c,t[15]=1}(this,t,e,n,a,i,s),this}fromQuaternion(t){return p(this,t),this}setPosition(t){return this.x=t[0],this.y=t[1],this.z=t[2],this}transpose(t=this){return function(t,e){if(t===e){let n=e[1],a=e[2],i=e[3],s=e[6],r=e[7],o=e[11];t[1]=e[4],t[2]=e[8],t[3]=e[12],t[4]=n,t[6]=e[9],t[7]=e[13],t[8]=a,t[9]=s,t[11]=e[14],t[12]=i,t[13]=r,t[14]=o}else t[0]=e[0],t[1]=e[4],t[2]=e[8],t[3]=e[12],t[4]=e[1],t[5]=e[5],t[6]=e[9],t[7]=e[13],t[8]=e[2],t[9]=e[6],t[10]=e[10],t[11]=e[14],t[12]=e[3],t[13]=e[7],t[14]=e[11],t[15]=e[15]}(this,t),this}inverse(t=this){return function(t,e){let n=e[0],a=e[1],i=e[2],s=e[3],r=e[4],o=e[5],l=e[6],c=e[7],u=e[8],d=e[9],f=e[10],h=e[11],p=e[12],m=e[13],x=e[14],T=e[15],g=n*o-a*r,v=n*l-i*r,S=n*c-s*r,b=a*l-i*o,A=a*c-s*o,M=i*c-s*l,y=u*m-d*p,L=u*x-f*p,F=u*T-h*p,P=d*x-f*m,R=d*T-h*m,I=f*T-h*x,N=g*I-v*R+S*P+b*F-A*L+M*y;N&&(N=1/N,t[0]=(o*I-l*R+c*P)*N,t[1]=(i*R-a*I-s*P)*N,t[2]=(m*M-x*A+T*b)*N,t[3]=(f*A-d*M-h*b)*N,t[4]=(l*F-r*I-c*L)*N,t[5]=(n*I-i*F+s*L)*N,t[6]=(x*S-p*M-T*v)*N,t[7]=(u*M-f*S+h*v)*N,t[8]=(r*R-o*F+c*y)*N,t[9]=(a*F-n*R-s*y)*N,t[10]=(p*A-m*S+T*g)*N,t[11]=(d*S-u*A-h*g)*N,t[12]=(o*L-r*P-l*y)*N,t[13]=(n*P-a*L+i*y)*N,t[14]=(m*v-p*b-x*g)*N,t[15]=(u*b-d*v+f*g)*N)}(this,t),this}compose(t,e,n){return function(t,e,n,a){let i=e[0],s=e[1],r=e[2],o=e[3],l=i+i,c=s+s,u=r+r,d=i*l,f=i*c,h=i*u,p=s*c,m=s*u,x=r*u,T=o*l,g=o*c,v=o*u,S=a[0],b=a[1],A=a[2];t[0]=(1-(p+x))*S,t[1]=(f+v)*S,t[2]=(h-g)*S,t[3]=0,t[4]=(f-v)*b,t[5]=(1-(d+x))*b,t[6]=(m+T)*b,t[7]=0,t[8]=(h+g)*A,t[9]=(m-T)*A,t[10]=(1-(d+p))*A,t[11]=0,t[12]=n[0],t[13]=n[1],t[14]=n[2],t[15]=1}(this,t,e,n),this}getRotation(t){return h(t,this),this}extractRotation(t){let e=[];return h(e,t),p(this,e),this}fromRotation(t,e){return function(t,e,n){let a,i,s,r=n[0],o=n[1],l=n[2],c=Math.sqrt(r*r+o*o+l*l);Math.abs(c)<1e-6||(c=1/c,r*=c,o*=c,l*=c,a=Math.sin(e),i=Math.cos(e),s=1-i,t[0]=r*r*s+i,t[1]=o*r*s+l*a,t[2]=l*r*s-o*a,t[3]=0,t[4]=r*o*s-l*a,t[5]=o*o*s+i,t[6]=l*o*s+r*a,t[7]=0,t[8]=r*l*s+o*a,t[9]=o*l*s-r*a,t[10]=l*l*s+i,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1)}(this,t,e),this}getTranslation(t){var e,n;return n=this,(e=t)[0]=n[12],e[1]=n[13],e[2]=n[14],this}getScaling(t){return function(t,e){let n=e[0],a=e[1],i=e[2],s=e[4],r=e[5],o=e[6],l=e[8],c=e[9],u=e[10];t[0]=Math.sqrt(n*n+a*a+i*i),t[1]=Math.sqrt(s*s+r*r+o*o),t[2]=Math.sqrt(l*l+c*c+u*u)}(t,this),this}getMaxScaleOnAxis(){return function(t){let e=t[0],n=t[1],a=t[2],i=t[4],s=t[5],r=t[6],o=t[8],l=t[9],c=t[10];const u=e*e+n*n+a*a,d=i*i+s*s+r*r,f=o*o+l*l+c*c;return Math.sqrt(Math.max(u,d,f))}(this)}lookAt(t,e,n){return function(t,e,n,a){let i=e[0],s=e[1],r=e[2],o=a[0],l=a[1],c=a[2],u=i-n[0],d=s-n[1],f=r-n[2],h=u*u+d*d+f*f;h>0&&(h=1/Math.sqrt(h),u*=h,d*=h,f*=h);let p=l*f-c*d,m=c*u-o*f,x=o*d-l*u;h=p*p+m*m+x*x,h>0&&(h=1/Math.sqrt(h),p*=h,m*=h,x*=h),t[0]=p,t[1]=m,t[2]=x,t[3]=0,t[4]=d*x-f*m,t[5]=f*p-u*x,t[6]=u*m-d*p,t[7]=0,t[8]=u,t[9]=d,t[10]=f,t[11]=0,t[12]=i,t[13]=s,t[14]=r,t[15]=1}(this,t,e,n),this}lookAtTarget(t,e,n){return function(t,e,n,a){let i,s,r,o,l,c,u,f,h,p,m=e[0],x=e[1],T=e[2],g=a[0],v=a[1],S=a[2],b=n[0],A=n[1],M=n[2];Math.abs(m-b)<1e-6&&Math.abs(x-A)<1e-6&&Math.abs(T-M)<1e-6?d(t):(u=m-b,f=x-A,h=T-M,p=1/Math.sqrt(u*u+f*f+h*h),u*=p,f*=p,h*=p,i=v*h-S*f,s=S*u-g*h,r=g*f-v*u,p=Math.sqrt(i*i+s*s+r*r),p?(p=1/p,i*=p,s*=p,r*=p):(i=0,s=0,r=0),o=f*r-h*s,l=h*i-u*r,c=u*s-f*i,p=Math.sqrt(o*o+l*l+c*c),p?(p=1/p,o*=p,l*=p,c*=p):(o=0,l=0,c=0),t[0]=i,t[1]=o,t[2]=u,t[3]=0,t[4]=s,t[5]=l,t[6]=f,t[7]=0,t[8]=r,t[9]=c,t[10]=h,t[11]=0,t[12]=-(i*m+s*x+r*T),t[13]=-(o*m+l*x+c*T),t[14]=-(u*m+f*x+h*T),t[15]=1)}(this,t,e,n),this}determinant(){return function(t){let e=t[0],n=t[1],a=t[2],i=t[3],s=t[4],r=t[5],o=t[6],l=t[7],c=t[8],u=t[9],d=t[10],f=t[11],h=t[12],p=t[13],m=t[14],x=t[15];return(e*r-n*s)*(d*x-f*m)-(e*o-a*s)*(u*x-f*p)+(e*l-i*s)*(u*m-d*p)+(n*o-a*r)*(c*x-f*h)-(n*l-i*r)*(c*m-d*h)+(a*l-i*o)*(c*p-u*h)}(this)}fromArray(t,e=0){for(var n=0;n<16;n++)this[n]=t[n+e];return this}toArray(t=[],e=0){let n=this;return t[e]=n[0],t[e+1]=n[1],t[e+2]=n[2],t[e+3]=n[3],t[e+4]=n[4],t[e+5]=n[5],t[e+6]=n[6],t[e+7]=n[7],t[e+8]=n[8],t[e+9]=n[9],t[e+10]=n[10],t[e+11]=n[11],t[e+12]=n[12],t[e+13]=n[13],t[e+14]=n[14],t[e+15]=n[15],t}static copyTo(t=[],e=[]){t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=e[11],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15]}}function x(t,e,n){let a=e[0],i=e[1],s=e[2],r=e[3],o=e[4],l=e[5],c=e[6],u=e[7],d=e[8],f=n[0],h=n[1],p=n[2],m=n[3],x=n[4],T=n[5],g=n[6],v=n[7],S=n[8];return t[0]=f*a+h*r+p*c,t[1]=f*i+h*o+p*u,t[2]=f*s+h*l+p*d,t[3]=m*a+x*r+T*c,t[4]=m*i+x*o+T*u,t[5]=m*s+x*l+T*d,t[6]=g*a+v*r+S*c,t[7]=g*i+v*o+S*u,t[8]=g*s+v*l+S*d,t}new m;class T extends Array{constructor(t=1,e=0,n=0,a=0,i=1,s=0,r=0,o=0,l=1){return super(t,e,n,a,i,s,r,o,l),this}get isMatrix3(){return!0}set(t,e,n,a,i,s,r,o,l){return t.length?this.copy(t):(function(t,e,n,a,i,s,r,o,l,c){t[0]=e,t[1]=n,t[2]=a,t[3]=i,t[4]=s,t[5]=r,t[6]=o,t[7]=l,t[8]=c}(this,t,e,n,a,i,s,r,o,l),this)}transpose(){return function(t){let e;e=t[1],t[1]=t[3],t[3]=e,e=t[2],t[2]=t[6],t[6]=e,e=t[5],t[5]=t[7],t[7]=e}(this),this}inverse(t=this){return function(t,e){let n=e[0],a=e[1],i=e[2],s=e[3],r=e[4],o=e[5],l=e[6],c=e[7],u=e[8],d=u*r-o*c,f=-u*s+o*l,h=c*s-r*l,p=n*d+a*f+i*h;p&&(p=1/p,t[0]=d*p,t[1]=(-u*a+i*c)*p,t[2]=(o*a-i*r)*p,t[3]=f*p,t[4]=(u*n-i*l)*p,t[5]=(-o*n+i*s)*p,t[6]=h*p,t[7]=(-c*n+a*l)*p,t[8]=(r*n-a*s)*p)}(this,t),this}translate(t,e=this){return function(t,e,n){let a=e[0],i=e[1],s=e[2],r=e[3],o=e[4],l=e[5],c=e[6],u=e[7],d=e[8],f=n[0],h=n[1];t[0]=a,t[1]=i,t[2]=s,t[3]=r,t[4]=o,t[5]=l,t[6]=f*a+h*r+c,t[7]=f*i+h*o+u,t[8]=f*s+h*l+d}(this,e,t),this}rotate(t,e=this){return function(t,e,n){let a=e[0],i=e[1],s=e[2],r=e[3],o=e[4],l=e[5],c=e[6],u=e[7],d=e[8],f=Math.sin(n),h=Math.cos(n);t[0]=h*a+f*r,t[1]=h*i+f*o,t[2]=h*s+f*l,t[3]=h*r-f*a,t[4]=h*o-f*i,t[5]=h*l-f*s,t[6]=c,t[7]=u,t[8]=d}(this,e,t),this}scale(t,e=this){return function(t,e,n){let a=n[0],i=n[1];t[0]=a*e[0],t[1]=a*e[1],t[2]=a*e[2],t[3]=i*e[3],t[4]=i*e[4],t[5]=i*e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8]}(this,e,t),this}multiply(t,e){return e?x(this,t,e):x(this,this,t),this}identity(){var t;return(t=this)[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=1,t[5]=0,t[6]=0,t[7]=0,t[8]=1,this}copy(t){var e,n;return n=t,(e=this)[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],e[6]=n[6],e[7]=n[7],e[8]=n[8],this}fromMatrix4(t){var e,n;return n=t,(e=this)[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[4],e[4]=n[5],e[5]=n[6],e[6]=n[8],e[7]=n[9],e[8]=n[10],this}fromQuaternion(t){return function(t,e){let n=e[0],a=e[1],i=e[2],s=e[3],r=n+n,o=a+a,l=i+i,c=n*r,u=a*r,d=a*o,f=i*r,h=i*o,p=i*l,m=s*r,x=s*o,T=s*l;t[0]=1-d-p,t[3]=u-T,t[6]=f+x,t[1]=u+T,t[4]=1-c-p,t[7]=h-m,t[2]=f-x,t[5]=h+m,t[8]=1-c-d}(this,t),this}fromBasis(t,e,n){return this.set(t[0],t[1],t[2],e[0],e[1],e[2],n[0],n[1],n[2]),this}getNormalMatrix(t){return function(t,e){let n=e[0],a=e[1],i=e[2],s=e[3],r=e[4],o=e[5],l=e[6],c=e[7],u=e[8],d=e[9],f=e[10],h=e[11],p=e[12],m=e[13],x=e[14],T=e[15],g=n*o-a*r,v=n*l-i*r,S=n*c-s*r,b=a*l-i*o,A=a*c-s*o,M=i*c-s*l,y=u*m-d*p,L=u*x-f*p,F=u*T-h*p,P=d*x-f*m,R=d*T-h*m,I=f*T-h*x,N=g*I-v*R+S*P+b*F-A*L+M*y;N&&(N=1/N,t[0]=(o*I-l*R+c*P)*N,t[1]=(l*F-r*I-c*L)*N,t[2]=(r*R-o*F+c*y)*N,t[3]=(i*R-a*I-s*P)*N,t[4]=(n*I-i*F+s*L)*N,t[5]=(a*F-n*R-s*y)*N,t[6]=(m*M-x*A+T*b)*N,t[7]=(x*S-p*M-T*v)*N,t[8]=(p*A-m*S+T*g)*N)}(this,t),this}clone(){return(new T).copy(this)}fromArray(t,e=0){for(var n=0;n<9;n++)this[n]=t[n+e];return this}toArray(){return Array.from(this)}toWebGPUFormat(){const t=new Float32Array(12);return t[3]=0,t[7]=0,t[11]=0,t[0]=this[0],t[1]=this[1],t[2]=this[2],t[4]=this[3],t[5]=this[4],t[6]=this[5],t[8]=this[6],t[9]=this[7],t[10]=this[8],t}}function g(t,e,n){return t[0]=e[0]+n[0],t[1]=e[1]+n[1],t[2]=e[2]+n[2],t}function v(t,e,n){return t[0]=e[0]-n[0],t[1]=e[1]-n[1],t[2]=e[2]-n[2],t}function S(t,e,n){return t[0]=e[0]*n,t[1]=e[1]*n,t[2]=e[2]*n,t}function b(t,e){let n=e[0],a=e[1],i=e[2],s=n*n+a*a+i*i;return s>0&&(s=1/Math.sqrt(s),t[0]=e[0]*s,t[1]=e[1]*s,t[2]=e[2]*s),t}function A(t,e){return t[0]*e[0]+t[1]*e[1]+t[2]*e[2]}function M(t,e,n){let a=e[0],i=e[1],s=e[2],r=n[3]*a+n[7]*i+n[11]*s+n[15];return r=r||1,t[0]=(n[0]*a+n[4]*i+n[8]*s+n[12])/r,t[1]=(n[1]*a+n[5]*i+n[9]*s+n[13])/r,t[2]=(n[2]*a+n[6]*i+n[10]*s+n[14])/r,t}function y(t,e,n){let a=e[0],i=e[1],s=e[2];return t[0]=a*n[0]+i*n[3]+s*n[6],t[1]=a*n[1]+i*n[4]+s*n[7],t[2]=a*n[2]+i*n[5]+s*n[8],t}const L=function(){let t=[];return function(e,n,a,i,s,r){let o,l;for(n||(n=3),a||(a=0),l=i?Math.min(i*n+a,e.length):e.length,o=a;o<l;o+=n)t[0]=e[o],t[1]=e[o+1],t[2]=e[o+2],s(t,t,r),e[o]=t[0],e[o+1]=t[1],e[o+2]=t[2];return e}}();function F(t,e,n){let a=e[0],i=e[1],s=e[2],r=e[3],o=n[0],l=n[1],c=n[2],u=n[3];return t[0]=a*u+r*o+i*c-s*l,t[1]=i*u+r*l+s*o-a*c,t[2]=s*u+r*c+a*l-i*o,t[3]=r*u-a*o-i*l-s*c,t}const P=function(t,e){return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t},R=function(t,e,n,a,i){return t[0]=e,t[1]=n,t[2]=a,t[3]=i,t},I=function(t,e){return t[0]*e[0]+t[1]*e[1]+t[2]*e[2]+t[3]*e[3]},N=function(t,e){let n=e[0],a=e[1],i=e[2],s=e[3],r=n*n+a*a+i*i+s*s;return r>0&&(r=1/Math.sqrt(r),t[0]=n*r,t[1]=a*r,t[2]=i*r,t[3]=s*r),t};class X extends Array{constructor(t=0,e=0,n=0,a=1){return super(t,e,n,a),this.onChange=()=>{},this}get isQuaternion(){return!0}get x(){return this[0]}set x(t){this[0]=t,this.onChange()}get y(){return this[1]}set y(t){this[1]=t,this.onChange()}get z(){return this[2]}set z(t){this[2]=t,this.onChange()}get w(){return this[3]}set w(t){this[3]=t,this.onChange()}identity(){var t;return(t=this)[0]=0,t[1]=0,t[2]=0,t[3]=1,this.onChange(),this}set(t,e,n,a){return t.length?this.copy(t):(R(this,t,e,n,a),this.onChange(),this)}rotateX(t){return function(t,e,n){n*=.5;let a=e[0],i=e[1],s=e[2],r=e[3],o=Math.sin(n),l=Math.cos(n);t[0]=a*l+r*o,t[1]=i*l+s*o,t[2]=s*l-i*o,t[3]=r*l-a*o}(this,this,t),this.onChange(),this}rotateY(t){return function(t,e,n){n*=.5;let a=e[0],i=e[1],s=e[2],r=e[3],o=Math.sin(n),l=Math.cos(n);t[0]=a*l-s*o,t[1]=i*l+r*o,t[2]=s*l+a*o,t[3]=r*l-i*o}(this,this,t),this.onChange(),this}rotateZ(t){return function(t,e,n){n*=.5;let a=e[0],i=e[1],s=e[2],r=e[3],o=Math.sin(n),l=Math.cos(n);t[0]=a*l+i*o,t[1]=i*l-a*o,t[2]=s*l+r*o,t[3]=r*l-s*o}(this,this,t),this.onChange(),this}inverse(t=this){return function(t,e){let n=e[0],a=e[1],i=e[2],s=e[3],r=n*n+a*a+i*i+s*s,o=r?1/r:0;t[0]=-n*o,t[1]=-a*o,t[2]=-i*o,t[3]=s*o}(this,t),this.onChange(),this}conjugate(t=this){var e,n;return n=t,(e=this)[0]=-n[0],e[1]=-n[1],e[2]=-n[2],e[3]=n[3],this.onChange(),this}copy(t){return P(this,t),this.onChange(),this}normalize(t=this){return N(this,t),this.onChange(),this}multiply(t,e){return e?F(this,t,e):F(this,this,t),this.onChange(),this}dot(t){return I(this,t)}fromMatrix3(t){return function(t,e){let n,a=e[0]+e[4]+e[8];if(a>0)n=Math.sqrt(a+1),t[3]=.5*n,n=.5/n,t[0]=(e[5]-e[7])*n,t[1]=(e[6]-e[2])*n,t[2]=(e[1]-e[3])*n;else{let a=0;e[4]>e[0]&&(a=1),e[8]>e[3*a+a]&&(a=2);let i=(a+1)%3,s=(a+2)%3;n=Math.sqrt(e[3*a+a]-e[3*i+i]-e[3*s+s]+1),t[a]=.5*n,n=.5/n,t[3]=(e[3*i+s]-e[3*s+i])*n,t[i]=(e[3*i+a]+e[3*a+i])*n,t[s]=(e[3*s+a]+e[3*a+s])*n}}(this,t),this.onChange(),this}fromEuler(t){return function(t,e,n="YXZ"){let a=Math.sin(.5*e[0]),i=Math.cos(.5*e[0]),s=Math.sin(.5*e[1]),r=Math.cos(.5*e[1]),o=Math.sin(.5*e[2]),l=Math.cos(.5*e[2]);"XYZ"===n?(t[0]=a*r*l+i*s*o,t[1]=i*s*l-a*r*o,t[2]=i*r*o+a*s*l,t[3]=i*r*l-a*s*o):"YXZ"===n?(t[0]=a*r*l+i*s*o,t[1]=i*s*l-a*r*o,t[2]=i*r*o-a*s*l,t[3]=i*r*l+a*s*o):"ZXY"===n?(t[0]=a*r*l-i*s*o,t[1]=i*s*l+a*r*o,t[2]=i*r*o+a*s*l,t[3]=i*r*l-a*s*o):"ZYX"===n?(t[0]=a*r*l-i*s*o,t[1]=i*s*l+a*r*o,t[2]=i*r*o-a*s*l,t[3]=i*r*l+a*s*o):"YZX"===n?(t[0]=a*r*l+i*s*o,t[1]=i*s*l+a*r*o,t[2]=i*r*o-a*s*l,t[3]=i*r*l-a*s*o):"XZY"===n&&(t[0]=a*r*l-i*s*o,t[1]=i*s*l-a*r*o,t[2]=i*r*o+a*s*l,t[3]=i*r*l+a*s*o)}(this,t,t.order),this}slerp(t,e,n){return function(t,e,n,a){let i,s,r,o,l,c=e[0],u=e[1],d=e[2],f=e[3],h=n[0],p=n[1],m=n[2],x=n[3];s=c*h+u*p+d*m+f*x,s<0&&(s=-s,h=-h,p=-p,m=-m,x=-x),1-s>1e-6?(i=Math.acos(s),r=Math.sin(i),o=Math.sin((1-a)*i)/r,l=Math.sin(a*i)/r):(o=1-a,l=a),t[0]=o*c+l*h,t[1]=o*u+l*p,t[2]=o*d+l*m,t[3]=o*f+l*x}(this,t,e,n),this}fromArray(t,e=0){return this[0]=t[e],this[1]=t[e+1],this[2]=t[e+2],this[3]=t[e+3],this}toArray(){return Array.from(this)}}function w(t,e,n){return t[0]=e[0]+n[0],t[1]=e[1]+n[1],t}function W(t,e,n){return t[0]=e[0]-n[0],t[1]=e[1]-n[1],t}function _(t,e,n){return t[0]=e[0]*n,t[1]=e[1]*n,t}function E(t){var e=t[0],n=t[1];return Math.sqrt(e*e+n*n)}class z extends Array{constructor(t=0,e=t){return super(t,e),this}get isVector2(){return!0}get x(){return this[0]}set x(t){this[0]=t}get y(){return this[1]}set y(t){this[1]=t}get width(){return this[0]}set width(t){this[0]=t}get height(){return this[1]}set height(t){this[1]=t}set(t,e=t){return t.length?this.copy(t):(function(t,e,n){t[0]=e,t[1]=n}(this,t,e),this)}copy(t){var e,n;return n=t,(e=this)[0]=n[0],e[1]=n[1],this}add(t,e){return e?w(this,t,e):w(this,this,t),this}sub(t,e){return e?W(this,t,e):W(this,this,t),this}multiply(t){var e,n,a;return t.length?(n=this,a=t,(e=this)[0]=n[0]*a[0],e[1]=n[1]*a[1]):_(this,this,t),this}divide(t){var e,n,a;return t.length?(n=this,a=t,(e=this)[0]=n[0]/a[0],e[1]=n[1]/a[1]):_(this,this,1/t),this}scale(t){return _(this,this,t),this}distance(t){return t?(e=this,a=(n=t)[0]-e[0],i=n[1]-e[1],Math.sqrt(a*a+i*i)):E(this);var e,n,a,i}squaredDistance(t){return t?(e=this,a=(n=t)[0]-e[0],i=n[1]-e[1],a*a+i*i):function(t){var e=t[0],n=t[1];return e*e+n*n}(this);var e,n,a,i}len(){return E(this)}squaredLength(){return this.squaredDistance()}negate(t=this){var e,n;return n=t,(e=this)[0]=-n[0],e[1]=-n[1],this}inverse(t=this){var e,n;return n=t,(e=this)[0]=1/n[0],e[1]=1/n[1],this}normalize(){var t,e,n,a,i;t=this,n=(e=this)[0],a=e[1],(i=n*n+a*a)>0&&(i=1/Math.sqrt(i),t[0]=e[0]*i,t[1]=e[1]*i)}dot(t){return n=t,(e=this)[0]*n[0]+e[1]*n[1];var e,n}cross(t,e){return a=e,(n=t)[0]*a[1]-n[1]*a[0];var n,a}lerp(t,e,n){!function(t,e,n,a){var i=e[0],s=e[1];t[0]=i+a*(n[0]-i),t[1]=s+a*(n[1]-s)}(this,t,e,n)}applyMatrix3(t){var e,n,a,i,s;return e=this,a=t,i=(n=this)[0],s=n[1],e[0]=a[0]*i+a[3]*s+a[6],e[1]=a[1]*i+a[4]*s+a[7],this}applyMatrix4(t){return function(t,e,n){let a=e[0],i=e[1];t[0]=n[0]*a+n[4]*i+n[12],t[1]=n[1]*a+n[5]*i+n[13]}(this,this,t),this}equals(t){return n=t,(e=this)[0]===n[0]&&e[1]===n[1];var e,n}clone(){return new z(this[0],this[1])}fromArray(t,e=0){return this[0]=t[e],this[1]=t[e+1],this}toArray(){return Array.from(this)}}class C extends Array{constructor(t=0,e=t,n=t){return super(t,e,n),this.constant=1,this}get isVector3(){return!0}get x(){return this[0]}set x(t){this[0]=t}get y(){return this[1]}set y(t){this[1]=t}get z(){return this[2]}set z(t){this[2]=t}set(t,e=t,n=t){return t.length?this.copy(t):(function(t,e,n,a){t[0]=e,t[1]=n,t[2]=a}(this,t,e,n),this)}copy(t){var e,n;return n=t,(e=this)[0]=n[0],e[1]=n[1],e[2]=n[2],this}add(t,e){return e?g(this,t,e):g(this,this,t),this}sub(t,e){return e?v(this,t,e):v(this,this,t),this}multiply(t){var e,n,a;return t.length?(n=this,a=t,(e=this)[0]=n[0]*a[0],e[1]=n[1]*a[1],e[2]=n[2]*a[2]):S(this,this,t),this}divide(t){var e,n,a;return t.length?(n=this,a=t,(e=this)[0]=n[0]/a[0],e[1]=n[1]/a[1],e[2]=n[2]/a[2]):S(this,this,1/t),this}scale(t){return S(this,this,t),this}distance(t){return t?function(t,e){let n=e[0]-t[0],a=e[1]-t[1],i=e[2]-t[2];return Math.sqrt(n*n+a*a+i*i)}(this,t):function(t){let e=t[0],n=t[1],a=t[2];return Math.sqrt(e*e+n*n+a*a)}(this)}squaredDistance(t){return t?function(t,e){let n=e[0]-t[0],a=e[1]-t[1],i=e[2]-t[2];return n*n+a*a+i*i}(this,t):function(t){let e=t[0],n=t[1],a=t[2];return e*e+n*n+a*a}(this)}squaredLength(){return this.squaredDistance()}negate(t=this){var e,n;return n=t,(e=this)[0]=-n[0],e[1]=-n[1],e[2]=-n[2],this}reflect(t){let e=t.clone();return this.sub(e.multiply(2*this.dot(t)))}inverse(t=this){var e,n;return n=t,(e=this)[0]=1/n[0],e[1]=1/n[1],e[2]=1/n[2],this}normalize(){return b(this,this),this}dot(t){return A(this,t)}cross(t,e){return function(t,e,n){let a=e[0],i=e[1],s=e[2],r=n[0],o=n[1],l=n[2];t[0]=i*l-s*o,t[1]=s*r-a*l,t[2]=a*o-i*r}(this,t,e),this}lerp(t,e,n){return function(t,e,n,a){let i=e[0],s=e[1],r=e[2];t[0]=i+a*(n[0]-i),t[1]=s+a*(n[1]-s),t[2]=r+a*(n[2]-r)}(this,t,e,n),this}hermite(t,e,n,a,i){return function(t,e,n,a,i,s){let r=s*s,o=r*(2*s-3)+1,l=r*(s-2)+s,c=r*(s-1),u=r*(3-2*s);t[0]=e[0]*o+n[0]*l+a[0]*c+i[0]*u,t[1]=e[1]*o+n[1]*l+a[1]*c+i[1]*u,t[2]=e[2]*o+n[2]*l+a[2]*c+i[2]*u}(this,t,e,n,a,i),this}bezier(t,e,n,a,i){return function(t,e,n,a,i,s){let r=1-s,o=r*r,l=s*s,c=o*r,u=3*s*o,d=3*l*r,f=l*s;t[0]=e[0]*c+n[0]*u+a[0]*d+i[0]*f,t[1]=e[1]*c+n[1]*u+a[1]*d+i[1]*f,t[2]=e[2]*c+n[2]*u+a[2]*d+i[2]*f}(this,t,e,n,a,i),this}applyMatrix4(t){return M(this,this,t),this}applyMatrix3(t){return y(this,this,t),this}applyQuaternion(t){return function(t,e,n){let a=e[0],i=e[1],s=e[2],r=n[0],o=n[1],l=n[2],c=n[3],u=c*a+o*s-l*i,d=c*i+l*a-r*s,f=c*s+r*i-o*a,h=-r*a-o*i-l*s;t[0]=u*c+h*-r+d*-l-f*-o,t[1]=d*c+h*-o+f*-r-u*-l,t[2]=f*c+h*-l+u*-o-d*-r}(this,this,t),this}setFromMatrixPosition(t){return this.x=t[12],this.y=t[13],this.z=t[14],this}angle(t){return function(t,e){let n=[...t],a=[...e];b(n,n),b(a,a);let i=A(n,a);return i>1?0:i<-1?Math.PI:Math.acos(i)}(this,t)}equals(t){return n=t,(e=this)[0]===n[0]&&e[1]===n[1]&&e[2]===n[2];var e,n}clone(){return new C(this[0],this[1],this[2])}fromArray(t,e=0){return this[0]=t[e],this[1]=t[e+1],this[2]=t[e+2],this}min(t){return this[0]=Math.min(this[0],t.x),this[1]=Math.min(this[1],t.y),this[2]=Math.min(this[2],t.z),this}max(t){return this[0]=Math.max(this[0],t.x),this[1]=Math.max(this[1],t.y),this[2]=Math.max(this[2],t.z),this}toArray(){return Array.from(this)}static copyTo(t,e){t[0]=e[0],t[1]=e[1],t[2]=e[2]}}const G=[new C,new C,new C,new C,new C,new C,new C,new C];class U{constructor(t=new C(1/0),e=new C(-1/0)){this.min=t,this.max=e}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(t){return this.isEmpty()?t.set(0,0,0):t.add(this.min,this.max).multiply(.5)}getSize(t){return this.isEmpty()?t.set(0,0,0):t.sub(this.max,this.min)}expandByPoint(t){return this.min.min(t),this.max.max(t),this}union(t){return this.min.min(t.min),this.max.max(t.max),this}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}intersectsBox(t){return!(t.max.x<this.min.x||t.min.x>this.max.x||t.max.y<this.min.y||t.min.y>this.max.y||t.max.z<this.min.z||t.min.z>this.max.z)}setFromPoints(t){this.makeEmpty();for(let e=0,n=t.length;e<n;e++)this.expandByPoint(t[e]);return this}applyMatrix4(t){return this.isEmpty()||(G[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(t),G[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(t),G[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(t),G[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(t),G[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(t),G[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(t),G[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(t),G[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(t),this.setFromPoints(G)),this}}class D{constructor(){this.name="",this.type="",this.isRayTracingMaterial=!0}setValues(t){if(void 0!==t)for(const e in t){const n=t[e];if(void 0===n){console.warn(`${this.name}: ${e} parameter is undefined.`);continue}const a=this[e];void 0!==a&&(a&&a.isColor?a.set(n):a&&a.isVector3&&n&&n.isVector3?a.copy(n):this[e]=n)}}copy(t){}}class V extends D{constructor(t){super(),this.type="PrincipleBSDF",this.workflow="Metalness",this.color=new u(1,1,1),this.roughness=.5,this.metalness=0,this.transmission=0,this.ior=1.5,this.specularTint=0,this.clearcoat=0,this.clearcoatRoughness=0,this.sheen=0,this.sheenTint=.5,this.atDistance=1,this.extinction=new u(1,1,1),this.anisotropic=0,this.subsurface=0,this.subsurfaceColor=new u(1,1,1),this.subsurfaceMFP=.05,this.emissiveColor=new u(0,0,0),this.normalScale=new z(1,1),this.opacity=1,this.map=null,this.normalMap=null,this.roughnessMap=null,this.metalnessMap=null,this.emissiveMap=null,this.specularColor=new u(1,1,1),this.glossiness=1,this.specularMap=null,this.glossinessMap=null,this.setValues(t)}copy(t){return this.name=`copy_${t.name}`,this.type=t.type,this.workflow=t.workflow,this.color=(new u).copy(t.color),this.roughness=t.roughness,this.metalness=t.metalness,this.transmission=t.transmission,this.ior=t.ior,this.specularTint=t.specularTint,this.clearcoat=t.clearcoat,this.clearcoatRoughness=t.clearcoatRoughness,this.sheen=t.sheen,this.sheenTint=t.sheenTint,this.atDistance=t.atDistance,this.anisotropic=t.anisotropic,this.extinction=(new u).copy(t.extinction),this.subsurface=t.subsurface,this.subsurfaceColor=(new u).copy(t.subsurfaceColor),this.subsurfaceMFP=t.subsurfaceMFP,this.emissiveColor=(new u).copy(t.emissiveColor),this.normalScale=(new z).copy(t.normalScale),this.opacity=t.opacity,this.map=t.map,this.normalMap=t.normalMap,this.roughnessMap=t.roughnessMap,this.metalnessMap=t.metalnessMap,this.emissiveMap=t.emissiveMap,this.specularColor=(new u).copy(t.specularColor),this.glossiness=t.glossiness,this.specularMap=t.specularMap,this.glossinessMap=t.glossinessMap,this}clone(){return(new V).copy(this)}}class B{constructor(){this.focus=10,this.aperture=0,this.zoom=1,this.tempVec3a=new C,this.tempVec3b=new C,this.type="PerspectiveCamera",this.viewToWorldMat=new m,this.worldToViewMat=new m,this.viewToClipMat=new m,this.clipToViewMat=new m,this.position=new C}copy(t){return this.type=t.type,this.focus=t.focus,this.aperture=t.aperture,this.zoom=t.zoom,this.viewToWorldMat.copy(t.viewToWorldMat),this.worldToViewMat.copy(t.worldToViewMat),this.viewToClipMat.copy(t.viewToClipMat),this.clipToViewMat.copy(t.clipToViewMat),this.position.copy(t.position),this}clone(){return(new B).copy(this)}updateFrustum(){this.frustum||(this.frustum=[new C,new C,new C,new C,new C,new C]);const t=(new m).multiply(this.viewToClipMat,this.worldToViewMat);this.frustum[0].set(t[3]-t[0],t[7]-t[4],t[11]-t[8]).constant=t[15]-t[12],this.frustum[1].set(t[3]+t[0],t[7]+t[4],t[11]+t[8]).constant=t[15]+t[12],this.frustum[2].set(t[3]+t[1],t[7]+t[5],t[11]+t[9]).constant=t[15]+t[13],this.frustum[3].set(t[3]-t[1],t[7]-t[5],t[11]-t[9]).constant=t[15]-t[13],this.frustum[4].set(t[3]-t[2],t[7]-t[6],t[11]-t[10]).constant=t[15]-t[14],this.frustum[5].set(t[3]+t[2],t[7]+t[6],t[11]+t[10]).constant=t[15]+t[14];for(let e=0;e<6;e++){const t=1/this.frustum[e].distance();this.frustum[e].multiply(t),this.frustum[e].constant*=t}}frustumIntersectsMesh(t){if(!t.geometry.position)return!0;if(!t.geometry.aabb)return!0;const e=t.geometry.aabb;e.getCenter(this.tempVec3a);const n=this.tempVec3a,a=e.min.distance(e.max)/2;n.applyMatrix4(t.localToWorldMat);const i=a*t.localToWorldMat.getMaxScaleOnAxis();return this.frustumIntersectsSphere(n,i)}frustumIntersectsSphere(t,e){const n=this.tempVec3b;for(let a=0;a<6;a++){const i=this.frustum[a];if(n.copy(i).dot(t)+i.constant<-e)return!1}return!0}}class H{constructor(t,e){this.array=t,this.itemSize=e}getItem(t,e){const n=this.array,a=this.itemSize,i=e*a;for(let s=0;s<a;s++)t[s]=n[i+s]}get count(){return this.array.length/this.itemSize}}class K{constructor(t,e,n,a){this.position=t,this.normal=e,this.uv=n,this.indices=a}}class k extends K{constructor(){const t=new Float32Array([.5,.5,.5,.5,.5,-.5,.5,-.5,.5,.5,-.5,-.5,-.5,.5,-.5,-.5,.5,.5,-.5,-.5,-.5,-.5,-.5,.5,-.5,.5,-.5,.5,.5,-.5,-.5,.5,.5,.5,.5,.5,-.5,-.5,.5,.5,-.5,.5,-.5,-.5,-.5,.5,-.5,-.5,-.5,.5,.5,.5,.5,.5,-.5,-.5,.5,.5,-.5,.5,.5,.5,-.5,-.5,.5,-.5,.5,-.5,-.5,-.5,-.5,-.5]),e=new Float32Array([1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1]),n=new Float32Array([0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,0]),a=new Uint16Array([0,2,1,2,3,1,4,6,5,6,7,5,8,10,9,10,11,9,12,14,13,14,15,13,16,18,17,18,19,17,20,22,21,22,23,21]);super(new H(t,3),new H(e,3),new H(n,2),new H(a,1)),this.name="LGL_DefaultCubeGeometry",this.aabb=new U(new C(-.5,-.5,-.5),new C(.5,.5,.5))}}class O{constructor(t=new k,e=new V){this.geometry=t,this.material=e,this.visible=!0,this.tlasMask=!1,this.localToWorldMat=new m}get worldToLocalMat(){return(new m).inverse(this.localToWorldMat)}copy(t){return this.geometry=t.geometry,this.material.copy(t.material),this.localToWorldMat.copy(t.localToWorldMat),this}clone(t=!0){let e=this.material;t&&(e=this.material.clone());const n=new O(this.geometry,e);return n.localToWorldMat.copy(this.localToWorldMat),n}}class Y{constructor(t){this.image=t,this.isTexture=!0,this.uvTransMat=new T,this.wrapS=0,this.wrapT=0,this.flipY=!1}}class Q{constructor(){this.resourcePool={},this.renderPipelines=new Map}getPipelineByCacheKey(t,e){const n=`${t}-${e}`;return this.renderPipelines.get(n)?this.renderPipelines.get(n):null}setPipelineByCacheKey(t,e,n){const a=`${t}-${e}`;this.renderPipelines.set(a,n)}clearPipelineCache(){Array.from(this.renderPipelines.values()).forEach((t=>t.dispose())),this.renderPipelines=new Map}getResourceByName(t){return this.resourcePool[t]}getRawResourceByName(t){var e;return null==(e=this.resourcePool[t])?void 0:e.raw}destoryResourceByName(t){this.resourcePool[t]&&(this.resourcePool[t].raw.dispose(),delete this.resourcePool[t])}setResource(t,e,n="Texture"){this.destoryResourceByName(t),this.resourcePool[t]={raw:e,type:n}}updateResource(t,e,n="Texture"){this.destoryResourceByName(t),this.resourcePool[t]={raw:e,type:n}}getPool(){return this.resourcePool}destroy(){for(const t in this.resourcePool){this.resourcePool[t].raw.dispose()}this.resourcePool={}}}function Z(t,e,n){return Object.assign({},n,{lightsNum:t.lightsNum,lightsData:t.lightsData,materialDefines:t.materialDefines,bvhDefines:t.bvhDefines,enableSSS:t.includeSSS,enableVolume:t.includeVolume,enableAtomsphere:t.includeAtomsphere})}const q=["color","roughness","metalness","transmission","ior","clearcoat","clearcoatRoughness","sheen","sheenTint","specularTint","atDistance","extinction","anisotropic","subsurface","subsurfaceColor","subsurfaceMFP","normalScale","opacity","specularColor","glossiness","glossiness","emissiveIntensity","emissive"],J=["map","normalMap","roughnessMap","metalnessMap","specularMap","glossinessMap","emissiveMap"],j={1e3:0,1001:1,1002:2};function $(t){const e=new Map;for(const n of t){const t=n.material;let a=e.get(t);void 0===a&&(a=e.size,e.set(t,a))}return 0==e.size&&e.set(new D,0),e}function tt(t,e=!1){t.updateMatrixWorld(!0);const n=[],a=[];if(e){const t=new O;t.name="LGLDefaultMesh",t.material.name="LGLDefaultMaterial",t.visible=!1,t.localToWorldMat.scale([1e-4,1e-4,1e-4]),n.push(t)}let i=!1;const s=new Map,r=new Map;t.traverse((t=>{if(t.isMesh){let e=t;if(e.geometry){let t=e.material;if(e.material||(t=new V),e.userData.useLGLMaterial&&e.userData.LGLMaterial)t=e.userData.LGLMaterial;else{const n=s.get(t);n?t=n:(t=it(e.material),s.set(e.material,t))}t.subsurface>0&&(i=!0);let a=r.get(e.geometry.id);a||(a=function(t){var e,n;const a=nt(t,"position"),i=nt(t,"normal"),s=nt(t,"uv"),r=t.getIndex(),o=new K(a&&new H(a.array,a.itemSize),i&&new H(i.array,i.itemSize),s&&new H(s.array,s.itemSize),r&&new H(r.array,r.itemSize));o.id=`LGL_${t.id}`,o.name=`LGL_${t.name}`,t.boundingBox||t.computeBoundingBox();return o.aabb=new U,o.aabb.min.fromArray(null==(e=t.boundingBox)?void 0:e.min.toArray()),o.aabb.max.fromArray(null==(n=t.boundingBox)?void 0:n.max.toArray()),o}(e.geometry),r.set(e.geometry.id,a));const o=new O(a,t);Ge.linkMeshWithTHREEMesh(o,e),n.push(o)}else console.warn(`${t.name} need geometry data`)}t.isLight&&t.visible&&a.push(t)}));const o=$(n),l=function(t){if(!t.length)return null;const e=new m,n=new X;return function(t){const e={};return e.position=t.map((t=>t.position)),e.emission=t.map((t=>t.emission)),e.p1=t.map((t=>t.p1)),e.p2=t.map((t=>t.p2)),e.radius=t.map((t=>t.radius)),e.area=t.map((t=>t.area)),e.type=t.map((t=>t.type)),e.visible=t.map((t=>t.visible)),e.position=[].concat(...e.position.map((t=>t.toArray()))),e.emission=[].concat(...e.emission.map((t=>t.toArray()))),e.p1=[].concat(...e.p1.map((t=>t.toArray()))),e.p2=[].concat(...e.p2.map((t=>t.toArray()))),e.params=function(...t){let e=0;for(let a=0;a<t.length;a++){const n=t[a],i=n.data?n.data.length/n.channels:0;e=Math.max(e,i)}const n=[];for(let a=0;a<e;a++)for(let e=0;e<t.length;e++){const{data:i=[],channels:s}=t[e];for(let t=0;t<s;t++)n.push(i[a*s+t])}return n}({data:e.radius,channels:1},{data:e.area,channels:1},{data:e.type,channels:1},{data:e.visible,channels:1}),e}(t.map((t=>{const a=t,i={},s=new C;switch(a.updateWorldMatrix(!0,!1),s.setFromMatrixPosition(a.matrixWorld.elements),i.position=s,i.emission=(new C).fromArray(a.color.toArray()).multiply(a.intensity),i.radius=a.radius||0,i.area=0,i.visible=Number(a.visible),i.p1=new C,i.p2=new C,a.type){case"RectAreaLight":if(i.type=0,e.fromArray(a.matrixWorld.elements),e.getRotation(n),a.width&&a.height){const t=new C(a.width,0,0);t.applyQuaternion(n);const e=new C(0,a.height,0);e.applyQuaternion(n),i.p1.copy(e),i.p2.copy(t),i.area=(new C).cross(i.p1,i.p2).distance()}break;case"PointLight":i.type=2,i.area=0;break;case"DirectionalLight":i.type=1,a.target&&i.p1.fromArray(a.target.position.toArray()),i.area=0;break;case"SpotLight":i.type=3;const t=new C;a.target&&t.fromArray(a.target.position.toArray());const r=(new C).sub(t,s).normalize();i.p1.copy(r),i.p2.x=Math.cos(a.angle),i.p2.y=Math.cos(a.angle*(1-a.penumbra)),i.p2.z=a.decay;break;default:console.warn(`Not support light type: ${a.type}`)}return i})))}(a);return{meshes:n,materialIndexMap:o,materials:Array.from(o.keys()),geometryConvertMap:r,lightsNum:a.length,lightsData:l,includeSSS:i,includeVolume:!1,includeAtomsphere:!1}}function et(t,e){t.updateMatrixWorld(!0);const n=e||new B;return n.type=t.type,n.viewToWorldMat.fromArray(t.matrixWorld.elements),n.worldToViewMat.fromArray(t.matrixWorldInverse.elements),n.clipToViewMat.fromArray(t.projectionMatrixInverse.elements),n.viewToClipMat.fromArray(t.projectionMatrix.elements),n.position.fromArray(t.position.toArray()),null!=t.aperture&&(n.aperture=t.aperture||0),null!=t.focus&&(n.focus=t.focus||0),null!=t.zoom&&(n.zoom=t.zoom||1),n}function nt(t,e){const n=t.getAttribute(e);return(null==n?void 0:n.isInterleavedBufferAttribute)?n.clone():n}function at(t){if(!t)return null;const e=new Y(t.image);return e.flipY=t.flipY,e}function it(t,e){var n,a,i,s,r,o,l,c,u;Array.isArray(t)&&(t=t[0]);const d=e||new V;return d.name=`LGL_${t.name}`,function(t,e){q.forEach((n=>{if(null==t[n]&&null==t.userData[n])switch(n){case"emissive":t.userData[n]=e.emissiveColor.toArray();break;case"emissiveIntensity":t.userData[n]=1;break;default:t.userData[n]=e[n].toArray?e[n].toArray():e[n]}}))}(t,d),t.color?d.color.fromArray(t.color.toArray()):d.color.fromArray(t.userData.color),d.roughness=null!=(n=t.roughness)?n:t.userData.roughness,d.metalness=null!=(a=t.metalness)?a:t.userData.metalness,d.transmission=null!=(i=t.transmission)?i:t.userData.transmission,d.ior=null!=(s=t.ior)?s:t.userData.ior,t.emissive?d.emissiveColor.fromArray(t.emissive.toArray()).scale(t.emissiveIntensity):d.emissiveColor.fromArray(t.userData.emissive).scale(t.userData.emissiveIntensity),t.normalScale?d.normalScale.fromArray(t.normalScale.toArray()):d.normalScale.fromArray(t.userData.normalScale),d.clearcoat=null!=(r=t.clearcoat)?r:t.userData.clearcoat,d.clearcoatRoughness=null!=(o=t.clearcoatRoughness)?o:t.userData.clearcoatRoughness,d.sheen=null!=(l=t.sheen)?l:t.userData.sheen,d.sheenTint=null!=(c=t.sheenTint)?c:t.userData.sheenTint,d.opacity=null!=(u=t.opacity)?u:t.userData.opacity,d.map=at(t.map),d.normalMap=at(t.normalMap),d.emissiveMap=at(t.emissiveMap),d.roughnessMap=at(t.roughnessMap),d.metalnessMap=at(t.metalnessMap),t.isGLTFSpecularGlossinessMaterial&&(d.workflow="Specular",d.specularColor.fromArray(t.specular.toArray()),d.glossiness=t.glossiness,d.specularMap=at(t.specularMap),d.glossinessMap=at(t.glossinessMap)),d.subsurface=t.userData.subsurface,d.subsurfaceMFP=t.userData.subsurfaceMFP,d.subsurfaceColor.fromArray(t.userData.subsurfaceColor),d.specularTint=t.userData.specularTint,d.atDistance=t.userData.atDistance,d.extinction.fromArray(t.userData.extinction),d.anisotropic=t.userData.anisotropic,function(t,e){J.forEach((n=>{const a=t[n],i=e[n];a&&(a.updateMatrix(),i.uvTransMat.fromArray(a.matrix.toArray()),i.wrapS=j[a.wrapS],i.wrapT=j[a.wrapT])}))}(t,d),d}class st{constructor(t,e){this.gl=t;const{color:n,depth:a}=e;this.color=n,this.depth=a,this.framebuffer=t.createFramebuffer(),this.init()}bind(){const{gl:t,framebuffer:e}=this;t.bindFramebuffer(t.FRAMEBUFFER,e)}unbind(){const{gl:t}=this;t.bindFramebuffer(t.FRAMEBUFFER,null)}dispose(){const{gl:t,framebuffer:e}=this;t.deleteFramebuffer(e)}init(){const{gl:t,color:e,depth:n}=this;this.bind();const a=[];for(let i in e){const n=Number(i);void 0===n&&console.error("invalid location");const s=e[n];t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0+n,s.target,s.texture,0),a.push(t.COLOR_ATTACHMENT0+n)}t.drawBuffers(a),n&&t.framebufferRenderbuffer(t.FRAMEBUFFER,t.DEPTH_ATTACHMENT,n.target,n.texture),this.unbind()}}function rt(t,e){const n={};for(const a of e)n[a]=t.getExtension(a);return n}function ot(t,e){return{values:`uniform${t}${e}`,array:`uniform${t}${e}v`}}function lt(t,e){return{matrix:t===e?`uniformMatrix${t}fv`:`uniformMatrix${t}x${e}fv`}}class ct{constructor(t,e){this.gl=t;const n=function(t,e){const n={},a=t.getProgramParameter(e,t.ACTIVE_UNIFORMS);for(let i=0;i<a;i++){const{name:a,type:s}=t.getActiveUniform(e,i),r=t.getUniformLocation(e,a);r&&(n[a]={type:s,location:r})}return n}(t,e);this.uniforms={};for(let a in n){const{type:t,location:e}=n[a],i={type:t,location:e,v0:0,v1:0,v2:0,v3:0};this.uniforms[a]=i}this.typeMap=function(t){return{[t.FLOAT]:ot(1,"f"),[t.FLOAT_VEC2]:ot(2,"f"),[t.FLOAT_VEC3]:ot(3,"f"),[t.FLOAT_VEC4]:ot(4,"f"),[t.INT]:ot(1,"i"),[t.INT_VEC2]:ot(2,"i"),[t.INT_VEC3]:ot(3,"i"),[t.INT_VEC4]:ot(4,"i"),[t.UNSIGNED_INT]:ot(1,"ui"),[t.UNSIGNED_INT_VEC2]:ot(2,"ui"),[t.UNSIGNED_INT_VEC3]:ot(3,"ui"),[t.UNSIGNED_INT_VEC4]:ot(4,"ui"),[t.SAMPLER_2D]:ot(1,"i"),[t.SAMPLER_3D]:ot(1,"i"),[t.SAMPLER_2D_ARRAY]:ot(1,"i"),[t.FLOAT_MAT2]:lt(2,2),[t.FLOAT_MAT3]:lt(3,3),[t.FLOAT_MAT4]:lt(4,4),[t.INT_SAMPLER_2D]:ot(1,"i")}}(t),this.needsUpload=[],this.failedUnis=new Set}setUniform(t,e,n,a,i){const s=this.uniforms[t];s?(s.v0=e,s.v1=n,s.v2=a,s.v3=i,this.needsUpload.push(s)):this.failedUnis.has(t)||this.failedUnis.add(t)}setStructUniform(t,e){if(e.length)for(let n=0;n<e.length;n++){const a=e[n];Object.keys(a).map((e=>{let i=a[e];(i.isColor||i.isMatrix3||i.isMatrix4||i.isVector3||i.isVector2||i.isVector4)&&(i=i.toArray()),this.setUniform(`${t}[${n}].${e}`,i)}))}else Object.keys(e).map((n=>{const a=e[n];this.setUniform(`${t}.${n}[0]`,a)}))}upload(){const{gl:t,needsUpload:e,typeMap:n}=this;for(;e.length>0;){const{type:a,location:i,v0:s,v1:r,v2:o,v3:l}=e.pop(),c=n[a];if(s&&s.length)if(c.matrix){const e=s,n=r||!1;t[c.matrix](i,n,e)}else t[c.array](i,s);else t[c.values](i,s,r,o,l)}}}function ut(t,e,n,a){let i="#version 300 es\nprecision highp float;\nprecision highp int;\nprecision highp isampler2D;\nprecision highp usampler2D;\n";return a&&(i+=function(t){let e="";for(const n in t){const a=t[n];a&&(e+=`#define ${n} ${a}\n`)}return e}(a)),i+=n.source?n.source:n,function(t,e,n){const a=t.createShader(e);if(t.shaderSource(a,n),t.compileShader(a),t.getShaderParameter(a,t.COMPILE_STATUS))return a;const i=n.split("\n").map(((t,e)=>`${e+1}: ${t}`)).join("\n");throw console.error(i),t.getShaderInfoLog(a)}(t,e,i)}function dt(t,{defines:e,vertex:n}){return ut(t,t.VERTEX_SHADER,n,e)}class ft{constructor(t,e){this.gl=t,this.params=e;const{fragment:n,vertex:a}=e,i=a instanceof WebGLShader?a:dt(t,e),s=n instanceof WebGLShader?n:function(t,{defines:e,fragment:n}){return ut(t,t.FRAGMENT_SHADER,n,e)}(t,e),r=function(t,e,n,a,i){const s=t.createProgram();if(t.attachShader(s,e),t.attachShader(s,n),a&&t.transformFeedbackVaryings(s,a,i),t.linkProgram(s),t.detachShader(s,e),t.detachShader(s,n),t.getProgramParameter(s,t.LINK_STATUS))return s;throw t.getProgramInfoLog(s)}(t,i,s);this.program=r,this.uniformSetter=new ct(t,r),this.attribLocs=function(t,e){const n={},a=t.getProgramParameter(e,t.ACTIVE_ATTRIBUTES);for(let i=0;i<a;i++){const{name:a}=t.getActiveAttrib(e,i);a&&(n[a]=t.getAttribLocation(e,a))}return n}(t,r),this.textures={},this.nextTexUnit=1}setUniform(t,e,n,a,i){this.uniformSetter.setUniform(t,e,n,a,i)}setStructUniform(t,e){this.uniformSetter.setStructUniform(t,e)}setTexture(t,e){if(e)if(this.textures[t])this.textures[t].tex=e;else{const n=this.nextTexUnit++;this.uniformSetter.setUniform(t,n),this.textures[t]={unit:n,tex:e}}}bindTextures(){const{gl:t,textures:e}=this;for(let n in e){const{tex:a,unit:i}=e[n];t.activeTexture(t.TEXTURE0+i),t.bindTexture(a.target,a.texture)}}useProgram(t=!0){const{gl:e,uniformSetter:n,program:a}=this;e.useProgram(a),n.upload(),t&&this.bindTextures()}disposeProgram(){const{gl:t,program:e}=this;t.deleteProgram(e)}dispose(){const{gl:t,textures:e}=this;for(const n in e){const{tex:a}=e[n];t.deleteTexture(a.texture)}this.disposeProgram()}}class ht{constructor(t){this.gl=t;const e=t.createVertexArray();t.bindVertexArray(e);t.bindBuffer(t.ARRAY_BUFFER,t.createBuffer()),t.bufferData(t.ARRAY_BUFFER,new Float32Array([-1,-1,0,3,-1,0,-1,3,0]),t.STATIC_DRAW),t.enableVertexAttribArray(0),t.vertexAttribPointer(0,3,t.FLOAT,!1,0,0);t.bindBuffer(t.ARRAY_BUFFER,t.createBuffer()),t.bufferData(t.ARRAY_BUFFER,new Float32Array([0,0,2,0,0,2]),t.STATIC_DRAW),t.enableVertexAttribArray(1),t.vertexAttribPointer(1,2,t.FLOAT,!1,0,0),t.bindVertexArray(null),this.vao=e,this.vertexShader=dt(t,{vertex:"layout(location = 0) in vec2 aPosition;\nlayout(location = 1) in vec2 aUv;\n\nout vec2 vCoord;\n\nvoid main() {\n\tvCoord = aUv;\n\tgl_Position = vec4(aPosition, 0., 1.);\n}",defines:null})}draw(){const{gl:t,vao:e}=this;t.bindVertexArray(e),t.drawArrays(t.TRIANGLES,0,3)}}function pt(t,e,n){return.2126*t+.7152*e+.0722*n}function mt(t,e,n){return Math.min(Math.max(t,e),n)}function xt(t,e,n=1e-4){for(let a=0;a<t.length;a++)if(Math.abs(t[a]-e[a])>n)return!1;return!0}function Tt(t,e){return t.type!=e.type?(e=t.clone(),!1):"OrthographicCamera"===t.type?xt(t.viewToWorldMat,e.viewToWorldMat)&&t.zoom==e.zoom:xt(t.viewToWorldMat,e.viewToWorldMat)}function gt(){console.error("Only webgpu version supports this feature")}function vt(t,e){return{1:t.RED_INTEGER,2:t.RG_INTEGER,3:t.RGB_INTEGER,4:t.RGBA_INTEGER}[e]}class St{constructor(t,e){this.gl=t;let n,{width:a,height:i,data:s,length:r=1,channels:o,storage:l,flipY:c=!1,gammaCorrection:u=!1,wrapS:d=t.CLAMP_TO_EDGE,wrapT:f=t.CLAMP_TO_EDGE,minFilter:h=t.NEAREST,magFilter:p=t.NEAREST}=e;a=a||s.width||0,i=i||s.height||0,this.texture=t.createTexture(),Array.isArray(s)&&(n=s,s=n[0]);let m=this.target=n||r>1?t.TEXTURE_2D_ARRAY:t.TEXTURE_2D;t.activeTexture(t.TEXTURE0),t.bindTexture(m,this.texture),t.texParameteri(m,t.TEXTURE_MIN_FILTER,h),t.texParameteri(m,t.TEXTURE_MAG_FILTER,p),t.texParameteri(m,t.TEXTURE_WRAP_S,d),t.texParameteri(m,t.TEXTURE_WRAP_T,f),o||(o=s&&s.length?s.length/(a*i):4),o=mt(o,1,4);const{type:x,format:T,internalFormat:g}=function(t,e,n,a,i){let s,r;const o=a instanceof Uint8Array||a instanceof HTMLImageElement||a instanceof HTMLCanvasElement||a instanceof ImageData||a instanceof ImageBitmap,l=a instanceof Float32Array,c=a instanceof Int32Array,u=a instanceof Uint32Array;let d=function(t,e){return{1:t.RED,2:t.RG,3:t.RGB,4:t.RGBA}[e]}(t,e);return"byte"===n||!n&&o?(r={1:t.R8,2:t.RG8,3:i?t.SRGB8:t.RGB8,4:i?t.SRGB8_ALPHA8:t.RGBA8}[e],s=t.UNSIGNED_BYTE):"float"===n||!n&&l?(r={1:t.R32F,2:t.RG32F,3:t.RGB32F,4:t.RGBA32F}[e],s=t.FLOAT):"halfFloat"===n?(r={1:t.R16F,2:t.RG16F,3:t.RGB16F,4:t.RGBA16F}[e],s=t.HALF_FLOAT):"snorm"===n?(r={1:t.R8_SNORM,2:t.RG8_SNORM,3:t.RGB8_SNORM,4:t.RGBA8_SNORM}[e],s=t.UNSIGNED_BYTE):"int"===n||!n&&c?(r={1:t.R32I,2:t.RG32I,3:t.RGB32I,4:t.RGBA32I}[e],s=t.INT,d=vt(t,e)):("uint"===n||!n&&u)&&(r={1:t.R32UI,2:t.RG32UI,3:t.RGB32UI,4:t.RGBA32UI}[e],s=t.UNSIGNED_INT,d=vt(t,e)),{format:d,internalFormat:r,type:s}}(t,o,l,s,u);if(n){t.texStorage3D(m,1,g,a,i,n.length);for(let e=0;e<n.length;e++){const s=n[e].width||a,r=n[e].height||i;t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL,Array.isArray(c)?c[e]:c),t.texSubImage3D(m,0,0,0,e,s,r,1,T,x,n[e])}}else r>1?t.texStorage3D(m,1,g,a,i,r):(t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL,c),t.texStorage2D(m,1,g,a,i),s&&t.texSubImage2D(m,0,0,0,a,i,T,x,s));t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL,!1)}dispose(){const{gl:t,texture:e}=this;t.deleteTexture(e)}}class bt{constructor(t,e,n){this.gl=t;const a=t.createRenderbuffer(),i=t.RENDERBUFFER;t.bindRenderbuffer(i,a),t.renderbufferStorage(t.RENDERBUFFER,t.DEPTH_COMPONENT24,e,n),t.bindRenderbuffer(i,null),this.gl=t,this.texture=a,this.target=i}dispose(){const{gl:t,texture:e}=this;t.deleteRenderbuffer(e)}}function At(t,e){const n=new t.constructor(e);return n.set(t),n}class Mt extends St{constructor(t,e,n=4){const a=function(t){const e=Math.round(Math.log2(Math.sqrt(t))),n=2**e,a=Math.ceil(t/n);return{columnsLog:e,columns:n,rows:a,size:a*n}}(e.length/n),i=a.columns,s=a.rows;super(t,{data:At(e,n*i*s),width:i,height:s}),this.textureDim=a}}function yt(t,e,n,a,i,s,r){const o=Math.min(r.length/s,n);for(let l=0;l<o;l++)for(let n=0;n<s;n++)t[e](a+l*i+4*n,r[s*l+n],!0)}class Lt{constructor(t,e,n){this.gl=t;const a=t.getUniformBlockIndex(e,n),i=t.getActiveUniformBlockParameter(e,a,t.UNIFORM_BLOCK_DATA_SIZE),s=function(t,e,n){const a=t.getActiveUniformBlockParameter(e,n,t.UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES),i=t.getActiveUniforms(e,a,t.UNIFORM_OFFSET),s=t.getActiveUniforms(e,a,t.UNIFORM_ARRAY_STRIDE),r={};for(let o=0;o<a.length;o++){const{name:n,type:l,size:c}=t.getActiveUniform(e,a[o]);r[n]={type:l,size:c,offset:i[o],stride:s[o]}}return r}(t,e,a),r=t.createBuffer();t.bindBuffer(t.UNIFORM_BUFFER,r),t.bufferData(t.UNIFORM_BUFFER,i,t.STATIC_DRAW);const o=new DataView(new ArrayBuffer(i));this.uniforms=s,this.buffer=r,this.data=o}set(t,e){const{gl:n,uniforms:a,data:i}=this;if(!a[t])return void console.warn("No uniform property with name ",t);const{type:s,size:r,offset:o,stride:l}=a[t];switch(s){case n.FLOAT:yt(i,"setFloat32",r,o,l,1,e);break;case n.FLOAT_VEC2:yt(i,"setFloat32",r,o,l,2,e);break;case n.FLOAT_VEC3:yt(i,"setFloat32",r,o,l,3,e);break;case n.FLOAT_VEC4:yt(i,"setFloat32",r,o,l,4,e);break;case n.INT:yt(i,"setInt32",r,o,l,1,e);break;case n.INT_VEC2:yt(i,"setInt32",r,o,l,2,e);break;case n.INT_VEC3:yt(i,"setInt32",r,o,l,3,e);break;case n.INT_VEC4:yt(i,"setInt32",r,o,l,4,e);break;case n.BOOL:yt(i,"setUint32",r,o,l,1,e);break;case n.FLOAT_MAT4:yt(i,"setFloat32",r,o,l,16,e);break;default:console.warn("UniformBuffer: Unsupported type")}}bind(t){const{gl:e,buffer:n,data:a}=this;e.bindBuffer(e.UNIFORM_BUFFER,n),e.bufferSubData(e.UNIFORM_BUFFER,0,a),e.bindBufferBase(e.UNIFORM_BUFFER,t,n)}dispose(){const{gl:t,buffer:e}=this;t.deleteBuffer(e)}}const Ft=Pt();function Pt(){const t=new ArrayBuffer(4),e=new Float32Array(t),n=new Uint32Array(t),a=new Uint32Array(512),i=new Uint32Array(512);for(let l=0;l<256;++l){const t=l-127;t<-27?(a[l]=0,a[256|l]=32768,i[l]=24,i[256|l]=24):t<-14?(a[l]=1024>>-t-14,a[256|l]=1024>>-t-14|32768,i[l]=-t-1,i[256|l]=-t-1):t<=15?(a[l]=t+15<<10,a[256|l]=t+15<<10|32768,i[l]=13,i[256|l]=13):t<128?(a[l]=31744,a[256|l]=64512,i[l]=24,i[256|l]=24):(a[l]=31744,a[256|l]=64512,i[l]=13,i[256|l]=13)}const s=new Uint32Array(2048),r=new Uint32Array(64),o=new Uint32Array(64);for(let l=1;l<1024;++l){let t=l<<13,e=0;for(;0==(8388608&t);)t<<=1,e-=8388608;t&=-8388609,e+=947912704,s[l]=t|e}for(let l=1024;l<2048;++l)s[l]=939524096+(l-1024<<13);for(let l=1;l<31;++l)r[l]=l<<23;r[31]=1199570944,r[32]=2147483648;for(let l=33;l<63;++l)r[l]=2147483648+(l-32<<23);r[63]=3347054592;for(let l=1;l<64;++l)32!==l&&(o[l]=1024);return{floatView:e,uint32View:n,baseTable:a,shiftTable:i,mantissaTable:s,exponentTable:r,offsetTable:o}}function Rt(t){if(t instanceof Uint16Array)return t;const e=new Uint16Array(t.length);return t.map(((t,n)=>e[n]=function(t){Math.abs(t)>65504&&console.warn("toHalfFloat(): Value out of range."),t=Math.max(-65504,Math.min(65504,t)),Ft.floatView[0]=t;const e=Ft.uint32View[0],n=e>>23&511;return Ft.baseTable[n]+((8388607&e)>>Ft.shiftTable[n])}(t))),e}function It(t,e,n=0,a=t.length){let i=n,s=n+a-1;for(;i<s;){const n=i+s>>1;t[n]<e?i=n+1:s=n}return i-n}const Nt={width:1,height:1,data:new Float32Array(4)},Xt=class{constructor(t,e){this.gl=t,this.resourcePool=e,this.totalSumValue=1}destory(){const{resourcePool:t}=this;t.destoryResourceByName(Xt.ENVMAP_RES_NAME),t.destoryResourceByName(Xt.ENVMAP_MARGINAL_WEIGHTS_RES_NAME),t.destoryResourceByName(Xt.ENVMAP_CONDITIONAL_WEIGHTS_RES_NAME)}load(t){t||(t=Nt);const{gl:e,resourcePool:n}=this;this.destory();const a=t.width,i=t.height,s=Rt(t.data),r=new St(e,{data:s,storage:"halfFloat",minFilter:e.LINEAR,magFilter:e.LINEAR,width:a,height:i}),{marginalDataArray:o,conditionalDataArray:l,totalSumValue:c}=function(t){const{width:e,height:n,data:a}=t,i=new Float32Array(e*n),s=new Float32Array(e*n),r=new Float32Array(n),o=new Float32Array(n);let l=0,c=0;for(let f=0;f<n;f++){let t=0;for(let n=0;n<e;n++){const r=f*e+n,o=pt(a[4*r+0],a[4*r+1],a[4*r+2]);t+=o,l+=o,i[r]=o,s[r]=t}if(0!==t)for(let n=f*e,a=f*e+e;n<a;n++)i[n]/=t,s[n]/=t;c+=t,r[f]=t,o[f]=c}if(0!==c)for(let f=0,h=r.length;f<h;f++)r[f]/=c,o[f]/=c;const u=new Float32Array(n),d=new Float32Array(e*n);for(let f=0;f<n;f++){const t=It(o,(f+1)/n);u[f]=(t+.5)/n}for(let f=0;f<n;f++)for(let t=0;t<e;t++){const n=f*e+t,a=It(s,(t+1)/e,f*e,e);d[n]=(a+.5)/e}return{marginalDataArray:u,conditionalDataArray:d,totalSumValue:l}}(t);this.totalSumValue=c;const u=new St(e,{data:o,storage:"float",channels:1,width:i,height:1}),d=new St(e,{data:l,storage:"float",channels:1,width:a,height:i});n.setResource(Xt.ENVMAP_RES_NAME,r),n.setResource(Xt.ENVMAP_MARGINAL_WEIGHTS_RES_NAME,u),n.setResource(Xt.ENVMAP_CONDITIONAL_WEIGHTS_RES_NAME,d)}};let wt=Xt;function Wt(t,e=!1){const n=new Map;let a=0,i=0,s=0,r=0;const o=[];o.push({vertexSplitIndex:0,indicesSplitIndex:0});for(const l of t){let t=l.geometry;if(null==n.get(t)){t.indices||Et(t),t.uv||zt(t),e&&(t=_t(t,l.localToWorldMat)),t.normal?L(t.normal.array,3,0,void 0,b,void 0):Ct(t),s+=t.position.count,r+=t.indices.count,o.push({vertexSplitIndex:3*s,indicesSplitIndex:r});const a=n.size;n.set(t,a),l.geometry=t}a+=t.position.count,i+=t.indices.count}return{vertexTotalCount:s,indicesTotalCount:r,geoInfoSplitIndex:o,renderVertexCount:a,renderIndicesCount:i,geometryIndexMap:n}}function _t(t,e){const n=new K(new H(t.position.array.slice(),t.position.itemSize),t.normal&&new H(t.normal.array.slice(),t.normal.itemSize),t.uv&&new H(t.uv.array,t.uv.itemSize),t.indices&&new H(t.indices.array,t.indices.itemSize)),a=(new T).getNormalMatrix(e);return L(n.position.array,3,0,null,M,e),n.normal&&L(n.normal.array,3,0,null,y,a),n}function Et(t){const e=t.position;if(!e)return void console.warn("No position attribute");const n=new Uint32Array(e.count);for(let a=0;a<n.length;a++)n[a]=a;return t.indices=new H(n,1),t}function zt(t){const e=t.position,n=new Float32Array(2*e.count);for(let a=0;a<n.length;a++)n[a]=Math.random();return t.uv=new H(n,2),t}function Ct(t){const e=t.indices.array,n=t.position.array;t.normal=new H(new Float32Array(n.length),3);const a=t.normal.array,i=new C,s=new C,r=new C,o=new C,l=new C,c=new C,u=e.length;let d,f,h;for(let p=0;p<u;){e?(d=e[p++],f=e[p++],h=e[p++]):(d=p++,f=p++,h=p++),i.set(n[3*d],n[3*d+1],n[3*d+2]),s.set(n[3*f],n[3*f+1],n[3*f+2]),r.set(n[3*h],n[3*h+1],n[3*h+2]),o.sub(i,s),l.sub(s,r),c.cross(o,l);for(let t=0;t<3;t++)a[3*d+t]=a[3*d+t]+c[t],a[3*f+t]=a[3*f+t]+c[t],a[3*h+t]=a[3*h+t]+c[t]}for(let p=0;p<a.length;)c.set(a[p],a[p+1],a[p+2]),c.normalize(),a[p++]=c[0],a[p++]=c[1],a[p++]=c[2]}function Gt(t,e,n){const a=[],{renderVertexCount:i,renderIndicesCount:s}=n;for(const o of t){let t=o.geometry;const n=o.material;let i=e.get(n);a.push({geometry:t,materialID:i})}const r=function(t,e,n){const a=new H(new Float32Array(3*e),3),i=new H(new Float32Array(3*e),3),s=new H(new Float32Array(2*e),2),r=new H(new Uint32Array(n),1),o=new H(new Int32Array(2*e),2),l=new K(a,i,s,r);l.materialMeshIndex=o;let c=0,u=0,d=0;for(const{geometry:f,materialID:h}of t){const t=f.position.count;["position","normal","uv"].forEach((t=>{f[t]&&l[t].array.set(f[t].array,c*f[t].itemSize)}));const e=f.indices.array;for(let n=0;n<e.length;n++)r.array[u+n]=c+e[n];for(let n=0;n<2*t;)o.array[2*c+n++]=h,o.array[2*c+n++]=d;c+=t,u+=e.length,d++}return l}(a,i,s);return{geometry:r,vertexCount:i,IndicesCount:s,visible:!0}}wt.ENVMAP_RES_NAME="EnvMapTexture",wt.ENVMAP_MARGINAL_WEIGHTS_RES_NAME="EnvMapMarginalWeightsTexture",wt.ENVMAP_CONDITIONAL_WEIGHTS_RES_NAME="EnvMapConditionalWeightsTexture";class Ut{constructor(t,e){this.gl=t,this.fullscreenTriangle=e}createPipeline(){const{gl:t,fullscreenTriangle:e}=this,n={gl:t,vertex:e.vertexShader,fragment:"\nlayout(location = 0) out vec4 out_color;\n\nin vec2 vCoord;\n\nuniform sampler2D inputTex;\n\nvoid main() {\n\tvec4 light = texture(inputTex, vCoord);\n\tout_color = light;\n}"};this.renderPass=new ft(t,n),this.fullscreenTriangle=e}draw(t){let{inputTex:e}=t;this.renderPass.setTexture("inputTex",e),this.renderPass.useProgram(),this.fullscreenTriangle.draw()}dispose(){this.renderPass.dispose()}}async function Dt(t,e){const n=new Map;let a=0;e.forEach((t=>{Object.keys(t).forEach((e=>{var i;if(null==(i=t[e])?void 0:i.isTexture){const i=t[e].image;let s=n.get(i);void 0===s&&a<255&&(s=n.size,n.set(i,s),a++)}}))}));let i,s=Array.from(n.keys());return 255==a&&console.warn("Material limit exceeded. Some material information will be lost"),0==s.length?i=function(t){return new St(t,{width:1,height:1,length:2,storage:"byte",minFilter:t.LINEAR,magFilter:t.LINEAR})}(t):(1==s.length&&(s=[s[0],s[0]]),i=await async function(t,e){const n=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,n);const a=new ht(t),i=new Ut(t,a);i.createPipeline();const s=new St(t,{width:2048,height:2048,length:e.length,storage:"byte",channels:4,minFilter:t.LINEAR,magFilter:t.LINEAR});for(let r=0;r<e.length;r++){t.framebufferTextureLayer(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,s.texture,0,r),t.clear(t.COLOR_BUFFER_BIT),t.viewport(0,0,2048,2048);const n=e[r],a=new St(t,{width:n.width,height:n.height,data:n,storage:"byte",channels:4,minFilter:t.LINEAR,magFilter:t.LINEAR});i.draw({inputTex:a}),a.dispose()}return t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteFramebuffer(n),s}(t,s)),{textureImages:s,textureImageMap:n,textureArrayRes:i}}function Vt(...t){let e=0;for(let a=0;a<t.length;a++){const n=t[a],i=n.data?n.data.length/n.channels:0;e=Math.max(e,i)}const n=[];for(let a=0;a<e;a++)for(let e=0;e<t.length;e++){const{data:i=[],channels:s}=t[e];for(let t=0;t<s;t++)n.push(i[a*s+t])}return n}function Bt(t,e){t.color=e.map((t=>t.color)),t.workflow=e.map((t=>"Metalness"===t.workflow?0:1)),t.roughness=e.map((t=>t.roughness)),t.metalness=e.map((t=>t.metalness)),t.transmission=e.map((t=>t.transmission)),t.ior=e.map((t=>t.ior)),t.sheen=e.map((t=>t.sheen)),t.sheenTint=e.map((t=>t.sheenTint)),t.clearcoat=e.map((t=>t.clearcoat)),t.clearcoatRoughness=e.map((t=>t.clearcoatRoughness)),t.emissiveColor=e.map((t=>t.emissiveColor)),t.opacity=e.map((t=>t.opacity)),t.specularTint=e.map((t=>t.specularTint)),t.atDistance=e.map((t=>t.atDistance)),t.normalScale=e.map((t=>t.normalScale)),t.subsurfaceColor=e.map((t=>t.subsurfaceColor)),t.subsurface=e.map((t=>t.subsurface)),t.extinction=e.map((t=>t.extinction)),t.subsurfaceMFP=e.map((t=>t.subsurfaceMFP)),t.specularColor=e.map((t=>t.specularColor)),t.glossiness=e.map((t=>t.glossiness))}function Ht(t,e){t.set("Materials.colorWorkflow[0]",Vt({data:[].concat(...e.color),channels:3},{data:e.workflow,channels:1})),t.set("Materials.roughMetalTransIOR[0]",Vt({data:e.roughness,channels:1},{data:e.metalness,channels:1},{data:e.transmission,channels:1},{data:e.ior,channels:1})),t.set("Materials.sheenTintClearcoatRoughness[0]",Vt({data:e.sheen,channels:1},{data:e.sheenTint,channels:1},{data:e.clearcoat,channels:1},{data:e.clearcoatRoughness,channels:1})),t.set("Materials.emissiveAlpha[0]",Vt({data:[].concat(...e.emissiveColor),channels:3},{data:e.opacity,channels:1})),t.set("Materials.specularTintAtDistanceNormalScale[0]",Vt({data:e.specularTint,channels:1},{data:e.atDistance,channels:1},{data:[].concat(...e.normalScale),channels:2})),t.set("Materials.subsurfaceAndColor[0]",Vt({data:e.subsurface,channels:1},{data:[].concat(...e.subsurfaceColor),channels:3})),t.set("Materials.extinctionSubsurfaceMFP[0]",Vt({data:[].concat(...e.extinction),channels:3},{data:e.subsurfaceMFP,channels:1})),t.set("Materials.specularColorGlossiness[0]",Vt({data:[].concat(...e.specularColor),channels:3},{data:e.glossiness,channels:1}))}function Kt(t,e,n){const a=[],i=[];e.map(((t,e)=>{const s=kt(n,t.map),r=kt(n,t.normalMap),o=kt(n,t.roughnessMap),l=kt(n,t.metalnessMap);a.push(s,r,o,l);const c=kt(n,t.emissiveMap),u=kt(n,t.specularMap),d=kt(n,t.glossinessMap);i.push(c,u,d,-1)})),t.diffuseNormalRoughnessMetalnessMapIndex=a,t.emissiveSpecularGlossinessMapIndex=i}function kt(t,e){return(null==e?void 0:e.image)?t.get(e.image):-1}function Ot(t,e){return Ht(t,e),function(t,e){t.set("Materials.diffuseNormalRoughnessMetalnessMapIndex[0]",e.diffuseNormalRoughnessMetalnessMapIndex),t.set("Materials.emissiveSpecularGlossinessMapIndex[0]",e.emissiveSpecularGlossinessMapIndex)}(t,e),t.bind(0),t}function Yt(t,e){const n={};Bt(n,e),Ht(t,n),t.bind(0)}async function Qt(t,e,n){const a={};Bt(a,n);const{textureImageMap:i,textureArrayRes:s}=await Dt(t,n);return Kt(a,n,i),Ot(e,a),{textureArrayRes:s}}async function Zt(t,e,n=!1){const a={};Bt(a,e);const{textureImageMap:i,textureArrayRes:s}=await Dt(t,e);Kt(a,e,i);const{defines:r,materialBuffer:o}=function(t,e,n=!1){const a={BVH_DYNAMIC:n,NUM_MESHES:e.length,NUM_MATERIALS:e.length},i=new ft(t,{vertex:{source:"void main() {}"},fragment:{source:"// UBO-1\n#ifdef NUM_MATERIALS\nuniform Materials {\n\tvec4 colorWorkflow[NUM_MATERIALS];\n\tvec4 roughMetalTransIOR[NUM_MATERIALS];\n\tvec4 sheenTintClearcoatRoughness[NUM_MATERIALS];\n\tvec4 emissiveAlpha[NUM_MATERIALS];\n\tvec4 specularTintAtDistanceNormalScale[NUM_MATERIALS];\n\tvec4 subsurfaceAndColor[NUM_MATERIALS];\n\tvec4 extinctionSubsurfaceMFP[NUM_MATERIALS];\n\tvec4 specularColorGlossiness[NUM_MATERIALS];\n\n\tivec4 diffuseNormalRoughnessMetalnessMapIndex[NUM_MATERIALS];\n\tivec4 emissiveSpecularGlossinessMapIndex[NUM_MATERIALS];\n\n} materials;\n#endif\nvoid main() {}"},defines:a}),s=new Lt(t,i.program,"Materials");return i.dispose(),{defines:a,materialBuffer:s}}(t,e,n);return Ot(o,a),{materialDefines:r,bufferData:a,materialBuffer:o,textureArrayRes:s,textureImageMap:i}}const qt=["map","normalMap","roughnessMap","metalnessMap","specularMap","glossinessMap","emissiveMap"];function Jt(t,e){const{mapNum:n,perMatrixLength:a,perWrappingDataLength:i,uvTransDataLength:s,bufferSize:r}=function(t){const e=qt.length,n=t.size*e*9,a=t.size*e*3;return{mapNum:e,perMatrixLength:9,perWrappingDataLength:3,uvTransDataLength:n,textureWrappingDataLength:a,bufferSize:n+a}}(e),o=new Float32Array(r),l=new T,c=n*a,u=n*i;e.forEach(((t,e)=>{qt.forEach(((n,r)=>{const d=e[`${n}`];let f=l;d&&(f=d.uvTransMat);for(let e=0;e<a;e++)o[c*t+r*a+e]=f[e];let h=0,p=0;d&&(h=d.wrapS,p=d.wrapT);const m=s+t*u+r*i;o[m+0]=h,o[m+1]=p,o[m+2]=0}))}));const d=new Mt(t,o,3);return{uvTransDefines:{UV_TRANS_COLUMNS:d.textureDim.columnsLog,TEX_WRAP_DATA_INDEX:s/3},uvTransformBufferTex:d}}function jt(t,e,n=0,a=t.length,i=Math.floor((n+a)/2)){for(let s=n;s<=i;s++){let n=s,i=t[s];for(let r=s+1;r<a;r++)e(i,t[r])||(n=r,i=t[r],$t(t,s,n))}}function $t(t,e,n){const a=t[n];t[n]=t[e],t[e]=a}let te,ee=0,ne=0,ae=0,ie=!1;const se=new C;function re(t,e){return{primitives:t,bounds:e}}function oe(t,e,n){let a=n[e]-t.min[e];return t.max[e]>t.min[e]&&(a/=t.max[e]-t.min[e]),a}function le(t){return t.getSize(se),2*(se.x*se.z+se.x*se.y+se.z*se.y)}function ce(t,e,n,a=!1){const i=new U;for(let c=e;c<n;c++)i.union(t[c].bounds);if(ie){ae+=1,te((ae+ne)/ee)}const s=n-e;if(1===s)return re(t.slice(e,n),i);{const c=new U;for(let a=e;a<n;a++)c.expandByPoint(t[a].center);const u=(c.getSize(se),se.x>se.z?se.x>se.y?"x":"y":se.z>se.y?"z":"y");let d=Math.floor((e+n)/2);if(s<=4)jt(t,((t,e)=>t.center[u]<e.center[u]),e,n,d);else if(c.max[u]===c.min[u]){if(!a)return re(t.slice(e,n),i);jt(t,((t,e)=>t.center[u]<e.center[u]),e,n,d)}else{const a=12,s=[];for(let t=0;t<a;t++)s.push({bounds:new U,count:0});for(let i=e;i<n;i++){let e=Math.floor(a*oe(c,u,t[i].center));e===s.length&&(e=s.length-1),s[e].count++,s[e].bounds.union(t[i].bounds)}const r=[];for(let t=0;t<s.length-1;t++){const e=new U,n=new U;let a=0,o=0;for(let i=0;i<=t;i++)e.union(s[i].bounds),a+=s[i].count;for(let i=t+1;i<s.length;i++)n.union(s[i].bounds),o+=s[i].count;r.push(.1+(a*le(e)+o*le(n))/le(i))}let o=r[0],l=0;for(let t=1;t<r.length;t++)r[t]<o&&(o=r[t],l=t);d=function(t,e,n=0,a=t.length){for(;n!==a;){for(;e(t[n]);)if(++n===a)return n;do{if(n===--a)return n}while(!e(t[a]));$t(t,n,a),n++}return n}(t,(t=>{let e=Math.floor(s.length*oe(c,u,t.center));return e===s.length&&(e=s.length-1),e<=l}),e,n)}return r=u,o=ce(t,e,d,a),l=ce(t,d,n,a),{child0:o,child1:l,bounds:(new U).union(o.bounds).union(l.bounds),splitAxis:r}}var r,o,l}function ue(t,e,n){const a=function(t,e,n){const a=[];for(let i=0;i<t.length;i++){const s=t[i],{material:r,geometry:o}=s,l=new U;l.copy(o.aabb).applyMatrix4(s.localToWorldMat);const c={bounds:l,center:l.getCenter(new C),meshID:i,geometryID:e.get(o),materialID:n.get(r),visible:s.visible};a.push(c)}return a}(t,e,n);ie=!1;return ce(a,0,a.length,!0)}function de(t,e){const{primitiveInfoArr:n}=function(t){let e=0;const n=[];for(let a=0;a<t.length;a++){const i=[],s=t[a],r=s.indices,o=s.position,l=s.materialMeshIndex,c=new C,u=new C,d=new C,f=new C,h=new C;for(let t=0;t<r.array.length;t+=3){const n=r.array[t],a=r.array[t+1],s=r.array[t+2],p=new U,m=3,x=n*m;c.x=o.array[x],c.y=o.array[x+1],c.z=o.array[x+2];const T=a*m;u.x=o.array[T],u.y=o.array[T+1],u.z=o.array[T+2];const g=s*m;d.x=o.array[g],d.y=o.array[g+1],d.z=o.array[g+2],p.expandByPoint(c),p.expandByPoint(u),p.expandByPoint(d),f.sub(d,c),h.sub(u,c);const v=(new C).cross(h,f).normalize(),S={bounds:p,center:p.getCenter(new C),indices:[n+e,a+e,s+e],faceNormal:v,materialID:l&&l.array[n*l.itemSize]};i.push(S)}e+=s.position.array.length/3,n.push(i)}return{primitiveInfoArr:n}}(t),a=[];if(e){ee=0,ne=0,ie=!0,te=e;for(let t=0;t<n.length;t++)ee+=2*n[t].length-1}for(let i=0;i<n.length;i++){const t=n[i];ae=0;const e=ce(t,0,t.length);ne+=2*t.length-1,a.push(e)}return{blasBVHs:a}}function fe(t,e=0,n=[]){const a=[];let i=1;const s={x:0,y:1,z:2},r=(t,o=1)=>{if(i=Math.max(o,i),t.primitives){const e=t;for(let t=0;t<e.primitives.length;t++){const i=e.primitives[t];if(void 0!==i.indices){const t=i;a.push(t.indices[0],t.indices[1],t.indices[2],-1,t.faceNormal.x,t.faceNormal.y,t.faceNormal.z,t.materialID||0)}else{const t=i;a.push(n[t.geometryID],t.materialID,t.meshID,-1,Number(t.visible),0,0,0)}}}else{const n=t,i=n.bounds;a.push(i.min.x,i.min.y,i.min.z,s[n.splitAxis],i.max.x,i.max.y,i.max.z,-1);const l=a.length-1;r(n.child0,o+1),a[l]=a.length/4+e,r(n.child1,o+1)}};return r(t),{count:a.length/4,maxDepth:i,flatData:a}}function he(t,e){return fe(t,0,e)}function pe(t,e=0){const n=[];let a=[],i=1;for(let s=0;s<t.length;s++){const r=fe(t[s],e);i=Math.max(r.maxDepth,i),a.push(e),e+=r.count,n.push(r)}return{blasBufferSplitIndex:a,totalBLASDataLength:4*e,totalBLASDataCount:e,flatBVHInfos:n,maxDepth:i}}const me="IWZ1bmN0aW9uKCl7InVzZSBzdHJpY3QiO2NvbnN0IHQ9MWUtNjtmdW5jdGlvbiBuKHQpe3JldHVybiB0WzBdPTEsdFsxXT0wLHRbMl09MCx0WzNdPTAsdFs0XT0wLHRbNV09MSx0WzZdPTAsdFs3XT0wLHRbOF09MCx0WzldPTAsdFsxMF09MSx0WzExXT0wLHRbMTJdPTAsdFsxM109MCx0WzE0XT0wLHRbMTVdPTEsdH1mdW5jdGlvbiBpKHQsbixpKXtsZXQgcz1uWzBdLGU9blsxXSxyPW5bMl0saD1uWzNdLGE9bls0XSxvPW5bNV0sdT1uWzZdLGw9bls3XSxjPW5bOF0sbT1uWzldLGY9blsxMF0seD1uWzExXSx5PW5bMTJdLHA9blsxM10sZz1uWzE0XSxNPW5bMTVdLGQ9aVswXSx6PWlbMV0sdz1pWzJdLGI9aVszXTtyZXR1cm4gdFswXT1kKnMreiphK3cqYytiKnksdFsxXT1kKmUreipvK3cqbStiKnAsdFsyXT1kKnIreip1K3cqZitiKmcsdFszXT1kKmgreipsK3cqeCtiKk0sZD1pWzRdLHo9aVs1XSx3PWlbNl0sYj1pWzddLHRbNF09ZCpzK3oqYSt3KmMrYip5LHRbNV09ZCplK3oqbyt3Km0rYipwLHRbNl09ZCpyK3oqdSt3KmYrYipnLHRbN109ZCpoK3oqbCt3KngrYipNLGQ9aVs4XSx6PWlbOV0sdz1pWzEwXSxiPWlbMTFdLHRbOF09ZCpzK3oqYSt3KmMrYip5LHRbOV09ZCplK3oqbyt3Km0rYipwLHRbMTBdPWQqcit6KnUrdypmK2IqZyx0WzExXT1kKmgreipsK3cqeCtiKk0sZD1pWzEyXSx6PWlbMTNdLHc9aVsxNF0sYj1pWzE1XSx0WzEyXT1kKnMreiphK3cqYytiKnksdFsxM109ZCplK3oqbyt3Km0rYipwLHRbMTRdPWQqcit6KnUrdypmK2IqZyx0WzE1XT1kKmgreipsK3cqeCtiKk0sdH1mdW5jdGlvbiBzKHQsbil7bGV0IGk9blswXStuWzVdK25bMTBdLHM9MDtyZXR1cm4gaT4wPyhzPTIqTWF0aC5zcXJ0KGkrMSksdFszXT0uMjUqcyx0WzBdPShuWzZdLW5bOV0pL3MsdFsxXT0obls4XS1uWzJdKS9zLHRbMl09KG5bMV0tbls0XSkvcyk6blswXT5uWzVdJiZuWzBdPm5bMTBdPyhzPTIqTWF0aC5zcXJ0KDErblswXS1uWzVdLW5bMTBdKSx0WzNdPShuWzZdLW5bOV0pL3MsdFswXT0uMjUqcyx0WzFdPShuWzFdK25bNF0pL3MsdFsyXT0obls4XStuWzJdKS9zKTpuWzVdPm5bMTBdPyhzPTIqTWF0aC5zcXJ0KDErbls1XS1uWzBdLW5bMTBdKSx0WzNdPShuWzhdLW5bMl0pL3MsdFswXT0oblsxXStuWzRdKS9zLHRbMV09LjI1KnMsdFsyXT0obls2XStuWzldKS9zKToocz0yKk1hdGguc3FydCgxK25bMTBdLW5bMF0tbls1XSksdFszXT0oblsxXS1uWzRdKS9zLHRbMF09KG5bOF0rblsyXSkvcyx0WzFdPShuWzZdK25bOV0pL3MsdFsyXT0uMjUqcyksdH1mdW5jdGlvbiBlKHQsbil7bGV0IGk9blswXSxzPW5bMV0sZT1uWzJdLHI9blszXSxoPWkraSxhPXMrcyxvPWUrZSx1PWkqaCxsPXMqaCxjPXMqYSxtPWUqaCxmPWUqYSx4PWUqbyx5PXIqaCxwPXIqYSxnPXIqbztyZXR1cm4gdFswXT0xLWMteCx0WzFdPWwrZyx0WzJdPW0tcCx0WzNdPTAsdFs0XT1sLWcsdFs1XT0xLXUteCx0WzZdPWYreSx0WzddPTAsdFs4XT1tK3AsdFs5XT1mLXksdFsxMF09MS11LWMsdFsxMV09MCx0WzEyXT0wLHRbMTNdPTAsdFsxNF09MCx0WzE1XT0xLHR9ZnVuY3Rpb24gcih0LG4saSl7cmV0dXJuIHRbMF09blswXStpWzBdLHRbMV09blsxXStpWzFdLHRbMl09blsyXStpWzJdLHR9ZnVuY3Rpb24gaCh0LG4saSl7cmV0dXJuIHRbMF09blswXS1pWzBdLHRbMV09blsxXS1pWzFdLHRbMl09blsyXS1pWzJdLHR9ZnVuY3Rpb24gYSh0LG4saSl7cmV0dXJuIHRbMF09blswXSppLHRbMV09blsxXSppLHRbMl09blsyXSppLHR9ZnVuY3Rpb24gbyh0LG4pe2xldCBpPW5bMF0scz1uWzFdLGU9blsyXSxyPWkqaStzKnMrZSplO3JldHVybiByPjAmJihyPTEvTWF0aC5zcXJ0KHIpLHRbMF09blswXSpyLHRbMV09blsxXSpyLHRbMl09blsyXSpyKSx0fWZ1bmN0aW9uIHUodCxuKXtyZXR1cm4gdFswXSpuWzBdK3RbMV0qblsxXSt0WzJdKm5bMl19bmV3IGNsYXNzIGV4dGVuZHMgQXJyYXl7Y29uc3RydWN0b3IodD0xLG49MCxpPTAscz0wLGU9MCxyPTEsaD0wLGE9MCxvPTAsdT0wLGw9MSxjPTAsbT0wLGY9MCx4PTAseT0xKXtyZXR1cm4gc3VwZXIodCxuLGkscyxlLHIsaCxhLG8sdSxsLGMsbSxmLHgseSksdGhpc31nZXQgaXNNYXRyaXg0KCl7cmV0dXJuITB9c2V0IHgodCl7dGhpc1sxMl09dH1nZXQgeCgpe3JldHVybiB0aGlzWzEyXX1zZXQgeSh0KXt0aGlzWzEzXT10fWdldCB5KCl7cmV0dXJuIHRoaXNbMTNdfXNldCB6KHQpe3RoaXNbMTRdPXR9Z2V0IHooKXtyZXR1cm4gdGhpc1sxNF19c2V0IHcodCl7dGhpc1sxNV09dH1nZXQgdygpe3JldHVybiB0aGlzWzE1XX1zZXQodCxuLGkscyxlLHIsaCxhLG8sdSxsLGMsbSxmLHgseSl7cmV0dXJuIHQubGVuZ3RoP3RoaXMuY29weSh0KTooZnVuY3Rpb24odCxuLGkscyxlLHIsaCxhLG8sdSxsLGMsbSxmLHgseSxwKXt0WzBdPW4sdFsxXT1pLHRbMl09cyx0WzNdPWUsdFs0XT1yLHRbNV09aCx0WzZdPWEsdFs3XT1vLHRbOF09dSx0WzldPWwsdFsxMF09Yyx0WzExXT1tLHRbMTJdPWYsdFsxM109eCx0WzE0XT15LHRbMTVdPXB9KHRoaXMsdCxuLGkscyxlLHIsaCxhLG8sdSxsLGMsbSxmLHgseSksdGhpcyl9dHJhbnNsYXRlKHQsbj10aGlzKXtyZXR1cm4gZnVuY3Rpb24odCxuLGkpe2xldCBzLGUscixoLGEsbyx1LGwsYyxtLGYseCx5PWlbMF0scD1pWzFdLGc9aVsyXTtuPT09dD8odFsxMl09blswXSp5K25bNF0qcCtuWzhdKmcrblsxMl0sdFsxM109blsxXSp5K25bNV0qcCtuWzldKmcrblsxM10sdFsxNF09blsyXSp5K25bNl0qcCtuWzEwXSpnK25bMTRdLHRbMTVdPW5bM10qeStuWzddKnArblsxMV0qZytuWzE1XSk6KHM9blswXSxlPW5bMV0scj1uWzJdLGg9blszXSxhPW5bNF0sbz1uWzVdLHU9bls2XSxsPW5bN10sYz1uWzhdLG09bls5XSxmPW5bMTBdLHg9blsxMV0sdFswXT1zLHRbMV09ZSx0WzJdPXIsdFszXT1oLHRbNF09YSx0WzVdPW8sdFs2XT11LHRbN109bCx0WzhdPWMsdFs5XT1tLHRbMTBdPWYsdFsxMV09eCx0WzEyXT1zKnkrYSpwK2MqZytuWzEyXSx0WzEzXT1lKnkrbypwK20qZytuWzEzXSx0WzE0XT1yKnkrdSpwK2YqZytuWzE0XSx0WzE1XT1oKnkrbCpwK3gqZytuWzE1XSl9KHRoaXMsbix0KSx0aGlzfXJvdGF0ZVgodCxuPXRoaXMpe3JldHVybiBmdW5jdGlvbih0LG4saSl7bGV0IHM9TWF0aC5zaW4oaSksZT1NYXRoLmNvcyhpKSxyPW5bNF0saD1uWzVdLGE9bls2XSxvPW5bN10sdT1uWzhdLGw9bls5XSxjPW5bMTBdLG09blsxMV07biE9PXQmJih0WzBdPW5bMF0sdFsxXT1uWzFdLHRbMl09blsyXSx0WzNdPW5bM10sdFsxMl09blsxMl0sdFsxM109blsxM10sdFsxNF09blsxNF0sdFsxNV09blsxNV0pLHRbNF09ciplK3Uqcyx0WzVdPWgqZStsKnMsdFs2XT1hKmUrYypzLHRbN109byplK20qcyx0WzhdPXUqZS1yKnMsdFs5XT1sKmUtaCpzLHRbMTBdPWMqZS1hKnMsdFsxMV09bSplLW8qc30odGhpcyxuLHQpLHRoaXN9cm90YXRlWSh0LG49dGhpcyl7cmV0dXJuIGZ1bmN0aW9uKHQsbixpKXtsZXQgcz1NYXRoLnNpbihpKSxlPU1hdGguY29zKGkpLHI9blswXSxoPW5bMV0sYT1uWzJdLG89blszXSx1PW5bOF0sbD1uWzldLGM9blsxMF0sbT1uWzExXTtuIT09dCYmKHRbNF09bls0XSx0WzVdPW5bNV0sdFs2XT1uWzZdLHRbN109bls3XSx0WzEyXT1uWzEyXSx0WzEzXT1uWzEzXSx0WzE0XT1uWzE0XSx0WzE1XT1uWzE1XSksdFswXT1yKmUtdSpzLHRbMV09aCplLWwqcyx0WzJdPWEqZS1jKnMsdFszXT1vKmUtbSpzLHRbOF09cipzK3UqZSx0WzldPWgqcytsKmUsdFsxMF09YSpzK2MqZSx0WzExXT1vKnMrbSplfSh0aGlzLG4sdCksdGhpc31yb3RhdGVaKHQsbj10aGlzKXtyZXR1cm4gZnVuY3Rpb24odCxuLGkpe2xldCBzPU1hdGguc2luKGkpLGU9TWF0aC5jb3MoaSkscj1uWzBdLGg9blsxXSxhPW5bMl0sbz1uWzNdLHU9bls0XSxsPW5bNV0sYz1uWzZdLG09bls3XTtuIT09dCYmKHRbOF09bls4XSx0WzldPW5bOV0sdFsxMF09blsxMF0sdFsxMV09blsxMV0sdFsxMl09blsxMl0sdFsxM109blsxM10sdFsxNF09blsxNF0sdFsxNV09blsxNV0pLHRbMF09ciplK3Uqcyx0WzFdPWgqZStsKnMsdFsyXT1hKmUrYypzLHRbM109byplK20qcyx0WzRdPXUqZS1yKnMsdFs1XT1sKmUtaCpzLHRbNl09YyplLWEqcyx0WzddPW0qZS1vKnN9KHRoaXMsbix0KSx0aGlzfXNjYWxlKHQsbj10aGlzKXtyZXR1cm4gZnVuY3Rpb24odCxuLGkpe2xldCBzPWlbMF0sZT1pWzFdLHI9aVsyXTt0WzBdPW5bMF0qcyx0WzFdPW5bMV0qcyx0WzJdPW5bMl0qcyx0WzNdPW5bM10qcyx0WzRdPW5bNF0qZSx0WzVdPW5bNV0qZSx0WzZdPW5bNl0qZSx0WzddPW5bN10qZSx0WzhdPW5bOF0qcix0WzldPW5bOV0qcix0WzEwXT1uWzEwXSpyLHRbMTFdPW5bMTFdKnIsdFsxMl09blsxMl0sdFsxM109blsxM10sdFsxNF09blsxNF0sdFsxNV09blsxNV19KHRoaXMsbiwibnVtYmVyIj09dHlwZW9mIHQ/W3QsdCx0XTp0KSx0aGlzfW11bHRpcGx5KHQsbil7cmV0dXJuIG4/aSh0aGlzLHQsbik6aSh0aGlzLHRoaXMsdCksdGhpc31pZGVudGl0eSgpe3JldHVybiBuKHRoaXMpLHRoaXN9Y29weSh0KXt2YXIgbixpO3JldHVybiBpPXQsKG49dGhpcylbMF09aVswXSxuWzFdPWlbMV0sblsyXT1pWzJdLG5bM109aVszXSxuWzRdPWlbNF0sbls1XT1pWzVdLG5bNl09aVs2XSxuWzddPWlbN10sbls4XT1pWzhdLG5bOV09aVs5XSxuWzEwXT1pWzEwXSxuWzExXT1pWzExXSxuWzEyXT1pWzEyXSxuWzEzXT1pWzEzXSxuWzE0XT1pWzE0XSxuWzE1XT1pWzE1XSx0aGlzfWZyb21QZXJzcGVjdGl2ZSh7Zm92OnQsYXNwZWN0Om4sbmVhcjppLGZhcjpzfT17fSl7cmV0dXJuIGZ1bmN0aW9uKHQsbixpLHMsZSl7bGV0IHI9MS9NYXRoLnRhbihuLzIpLGg9MS8ocy1lKTt0WzBdPXIvaSx0WzFdPTAsdFsyXT0wLHRbM109MCx0WzRdPTAsdFs1XT1yLHRbNl09MCx0WzddPTAsdFs4XT0wLHRbOV09MCx0WzEwXT0oZStzKSpoLHRbMTFdPS0xLHRbMTJdPTAsdFsxM109MCx0WzE0XT0yKmUqcypoLHRbMTVdPTB9KHRoaXMsdCxuLGkscyksdGhpc31mcm9tT3J0aG9nb25hbCh7bGVmdDp0LHJpZ2h0Om4sYm90dG9tOmksdG9wOnMsbmVhcjplLGZhcjpyfSl7cmV0dXJuIGZ1bmN0aW9uKHQsbixpLHMsZSxyLGgpe2xldCBhPTEvKG4taSksbz0xLyhzLWUpLHU9MS8oci1oKTt0WzBdPS0yKmEsdFsxXT0wLHRbMl09MCx0WzNdPTAsdFs0XT0wLHRbNV09LTIqbyx0WzZdPTAsdFs3XT0wLHRbOF09MCx0WzldPTAsdFsxMF09Mip1LHRbMTFdPTAsdFsxMl09KG4raSkqYSx0WzEzXT0oZStzKSpvLHRbMTRdPShoK3IpKnUsdFsxNV09MX0odGhpcyx0LG4saSxzLGUsciksdGhpc31mcm9tUXVhdGVybmlvbih0KXtyZXR1cm4gZSh0aGlzLHQpLHRoaXN9c2V0UG9zaXRpb24odCl7cmV0dXJuIHRoaXMueD10WzBdLHRoaXMueT10WzFdLHRoaXMuej10WzJdLHRoaXN9dHJhbnNwb3NlKHQ9dGhpcyl7cmV0dXJuIGZ1bmN0aW9uKHQsbil7aWYodD09PW4pe2xldCBpPW5bMV0scz1uWzJdLGU9blszXSxyPW5bNl0saD1uWzddLGE9blsxMV07dFsxXT1uWzRdLHRbMl09bls4XSx0WzNdPW5bMTJdLHRbNF09aSx0WzZdPW5bOV0sdFs3XT1uWzEzXSx0WzhdPXMsdFs5XT1yLHRbMTFdPW5bMTRdLHRbMTJdPWUsdFsxM109aCx0WzE0XT1hfWVsc2UgdFswXT1uWzBdLHRbMV09bls0XSx0WzJdPW5bOF0sdFszXT1uWzEyXSx0WzRdPW5bMV0sdFs1XT1uWzVdLHRbNl09bls5XSx0WzddPW5bMTNdLHRbOF09blsyXSx0WzldPW5bNl0sdFsxMF09blsxMF0sdFsxMV09blsxNF0sdFsxMl09blszXSx0WzEzXT1uWzddLHRbMTRdPW5bMTFdLHRbMTVdPW5bMTVdfSh0aGlzLHQpLHRoaXN9aW52ZXJzZSh0PXRoaXMpe3JldHVybiBmdW5jdGlvbih0LG4pe2xldCBpPW5bMF0scz1uWzFdLGU9blsyXSxyPW5bM10saD1uWzRdLGE9bls1XSxvPW5bNl0sdT1uWzddLGw9bls4XSxjPW5bOV0sbT1uWzEwXSxmPW5bMTFdLHg9blsxMl0seT1uWzEzXSxwPW5bMTRdLGc9blsxNV0sTT1pKmEtcypoLGQ9aSpvLWUqaCx6PWkqdS1yKmgsdz1zKm8tZSphLGI9cyp1LXIqYSx2PWUqdS1yKm8scT1sKnktYyp4LEE9bCpwLW0qeCxCPWwqZy1mKngsST1jKnAtbSp5LEQ9YypnLWYqeSxQPW0qZy1mKnAsUz1NKlAtZCpEK3oqSSt3KkItYipBK3YqcTtTJiYoUz0xL1MsdFswXT0oYSpQLW8qRCt1KkkpKlMsdFsxXT0oZSpELXMqUC1yKkkpKlMsdFsyXT0oeSp2LXAqYitnKncpKlMsdFszXT0obSpiLWMqdi1mKncpKlMsdFs0XT0obypCLWgqUC11KkEpKlMsdFs1XT0oaSpQLWUqQityKkEpKlMsdFs2XT0ocCp6LXgqdi1nKmQpKlMsdFs3XT0obCp2LW0qeitmKmQpKlMsdFs4XT0oaCpELWEqQit1KnEpKlMsdFs5XT0ocypCLWkqRC1yKnEpKlMsdFsxMF09KHgqYi15KnorZypNKSpTLHRbMTFdPShjKnotbCpiLWYqTSkqUyx0WzEyXT0oYSpBLWgqSS1vKnEpKlMsdFsxM109KGkqSS1zKkErZSpxKSpTLHRbMTRdPSh5KmQteCp3LXAqTSkqUyx0WzE1XT0obCp3LWMqZCttKk0pKlMpfSh0aGlzLHQpLHRoaXN9Y29tcG9zZSh0LG4saSl7cmV0dXJuIGZ1bmN0aW9uKHQsbixpLHMpe2xldCBlPW5bMF0scj1uWzFdLGg9blsyXSxhPW5bM10sbz1lK2UsdT1yK3IsbD1oK2gsYz1lKm8sbT1lKnUsZj1lKmwseD1yKnUseT1yKmwscD1oKmwsZz1hKm8sTT1hKnUsZD1hKmwsej1zWzBdLHc9c1sxXSxiPXNbMl07dFswXT0oMS0oeCtwKSkqeix0WzFdPShtK2QpKnosdFsyXT0oZi1NKSp6LHRbM109MCx0WzRdPShtLWQpKncsdFs1XT0oMS0oYytwKSkqdyx0WzZdPSh5K2cpKncsdFs3XT0wLHRbOF09KGYrTSkqYix0WzldPSh5LWcpKmIsdFsxMF09KDEtKGMreCkpKmIsdFsxMV09MCx0WzEyXT1pWzBdLHRbMTNdPWlbMV0sdFsxNF09aVsyXSx0WzE1XT0xfSh0aGlzLHQsbixpKSx0aGlzfWdldFJvdGF0aW9uKHQpe3JldHVybiBzKHQsdGhpcyksdGhpc31leHRyYWN0Um90YXRpb24odCl7bGV0IG49W107cmV0dXJuIHMobix0KSxlKHRoaXMsbiksdGhpc31mcm9tUm90YXRpb24obixpKXtyZXR1cm4gZnVuY3Rpb24obixpLHMpe2xldCBlLHIsaCxhPXNbMF0sbz1zWzFdLHU9c1syXSxsPU1hdGguc3FydChhKmErbypvK3UqdSk7TWF0aC5hYnMobCk8dHx8KGw9MS9sLGEqPWwsbyo9bCx1Kj1sLGU9TWF0aC5zaW4oaSkscj1NYXRoLmNvcyhpKSxoPTEtcixuWzBdPWEqYSpoK3IsblsxXT1vKmEqaCt1KmUsblsyXT11KmEqaC1vKmUsblszXT0wLG5bNF09YSpvKmgtdSplLG5bNV09bypvKmgrcixuWzZdPXUqbypoK2EqZSxuWzddPTAsbls4XT1hKnUqaCtvKmUsbls5XT1vKnUqaC1hKmUsblsxMF09dSp1KmgrcixuWzExXT0wLG5bMTJdPTAsblsxM109MCxuWzE0XT0wLG5bMTVdPTEpfSh0aGlzLG4saSksdGhpc31nZXRUcmFuc2xhdGlvbih0KXt2YXIgbixpO3JldHVybiBpPXRoaXMsKG49dClbMF09aVsxMl0sblsxXT1pWzEzXSxuWzJdPWlbMTRdLHRoaXN9Z2V0U2NhbGluZyh0KXtyZXR1cm4gZnVuY3Rpb24odCxuKXtsZXQgaT1uWzBdLHM9blsxXSxlPW5bMl0scj1uWzRdLGg9bls1XSxhPW5bNl0sbz1uWzhdLHU9bls5XSxsPW5bMTBdO3RbMF09TWF0aC5zcXJ0KGkqaStzKnMrZSplKSx0WzFdPU1hdGguc3FydChyKnIraCpoK2EqYSksdFsyXT1NYXRoLnNxcnQobypvK3UqdStsKmwpfSh0LHRoaXMpLHRoaXN9Z2V0TWF4U2NhbGVPbkF4aXMoKXtyZXR1cm4gZnVuY3Rpb24odCl7bGV0IG49dFswXSxpPXRbMV0scz10WzJdLGU9dFs0XSxyPXRbNV0saD10WzZdLGE9dFs4XSxvPXRbOV0sdT10WzEwXTtjb25zdCBsPW4qbitpKmkrcypzLGM9ZSplK3IqcitoKmgsbT1hKmErbypvK3UqdTtyZXR1cm4gTWF0aC5zcXJ0KE1hdGgubWF4KGwsYyxtKSl9KHRoaXMpfWxvb2tBdCh0LG4saSl7cmV0dXJuIGZ1bmN0aW9uKHQsbixpLHMpe2xldCBlPW5bMF0scj1uWzFdLGg9blsyXSxhPXNbMF0sbz1zWzFdLHU9c1syXSxsPWUtaVswXSxjPXItaVsxXSxtPWgtaVsyXSxmPWwqbCtjKmMrbSptO2Y+MCYmKGY9MS9NYXRoLnNxcnQoZiksbCo9ZixjKj1mLG0qPWYpO2xldCB4PW8qbS11KmMseT11KmwtYSptLHA9YSpjLW8qbDtmPXgqeCt5KnkrcCpwLGY+MCYmKGY9MS9NYXRoLnNxcnQoZikseCo9Zix5Kj1mLHAqPWYpLHRbMF09eCx0WzFdPXksdFsyXT1wLHRbM109MCx0WzRdPWMqcC1tKnksdFs1XT1tKngtbCpwLHRbNl09bCp5LWMqeCx0WzddPTAsdFs4XT1sLHRbOV09Yyx0WzEwXT1tLHRbMTFdPTAsdFsxMl09ZSx0WzEzXT1yLHRbMTRdPWgsdFsxNV09MX0odGhpcyx0LG4saSksdGhpc31sb29rQXRUYXJnZXQoaSxzLGUpe3JldHVybiBmdW5jdGlvbihpLHMsZSxyKXtsZXQgaCxhLG8sdSxsLGMsbSxmLHgseSxwPXNbMF0sZz1zWzFdLE09c1syXSxkPXJbMF0sej1yWzFdLHc9clsyXSxiPWVbMF0sdj1lWzFdLHE9ZVsyXTtNYXRoLmFicyhwLWIpPHQmJk1hdGguYWJzKGctdik8dCYmTWF0aC5hYnMoTS1xKTx0P24oaSk6KG09cC1iLGY9Zy12LHg9TS1xLHk9MS9NYXRoLnNxcnQobSptK2YqZit4KngpLG0qPXksZio9eSx4Kj15LGg9eip4LXcqZixhPXcqbS1kKngsbz1kKmYteiptLHk9TWF0aC5zcXJ0KGgqaCthKmErbypvKSx5Pyh5PTEveSxoKj15LGEqPXksbyo9eSk6KGg9MCxhPTAsbz0wKSx1PWYqby14KmEsbD14KmgtbSpvLGM9bSphLWYqaCx5PU1hdGguc3FydCh1KnUrbCpsK2MqYykseT8oeT0xL3ksdSo9eSxsKj15LGMqPXkpOih1PTAsbD0wLGM9MCksaVswXT1oLGlbMV09dSxpWzJdPW0saVszXT0wLGlbNF09YSxpWzVdPWwsaVs2XT1mLGlbN109MCxpWzhdPW8saVs5XT1jLGlbMTBdPXgsaVsxMV09MCxpWzEyXT0tKGgqcCthKmcrbypNKSxpWzEzXT0tKHUqcCtsKmcrYypNKSxpWzE0XT0tKG0qcCtmKmcreCpNKSxpWzE1XT0xKX0odGhpcyxpLHMsZSksdGhpc31kZXRlcm1pbmFudCgpe3JldHVybiBmdW5jdGlvbih0KXtsZXQgbj10WzBdLGk9dFsxXSxzPXRbMl0sZT10WzNdLHI9dFs0XSxoPXRbNV0sYT10WzZdLG89dFs3XSx1PXRbOF0sbD10WzldLGM9dFsxMF0sbT10WzExXSxmPXRbMTJdLHg9dFsxM10seT10WzE0XSxwPXRbMTVdO3JldHVybihuKmgtaSpyKSooYypwLW0qeSktKG4qYS1zKnIpKihsKnAtbSp4KSsobipvLWUqcikqKGwqeS1jKngpKyhpKmEtcypoKSoodSpwLW0qZiktKGkqby1lKmgpKih1KnktYypmKSsocypvLWUqYSkqKHUqeC1sKmYpfSh0aGlzKX1mcm9tQXJyYXkodCxuPTApe2Zvcih2YXIgaT0wO2k8MTY7aSsrKXRoaXNbaV09dFtpK25dO3JldHVybiB0aGlzfXRvQXJyYXkodD1bXSxuPTApe2xldCBpPXRoaXM7cmV0dXJuIHRbbl09aVswXSx0W24rMV09aVsxXSx0W24rMl09aVsyXSx0W24rM109aVszXSx0W24rNF09aVs0XSx0W24rNV09aVs1XSx0W24rNl09aVs2XSx0W24rN109aVs3XSx0W24rOF09aVs4XSx0W24rOV09aVs5XSx0W24rMTBdPWlbMTBdLHRbbisxMV09aVsxMV0sdFtuKzEyXT1pWzEyXSx0W24rMTNdPWlbMTNdLHRbbisxNF09aVsxNF0sdFtuKzE1XT1pWzE1XSx0fXN0YXRpYyBjb3B5VG8odD1bXSxuPVtdKXt0WzBdPW5bMF0sdFsxXT1uWzFdLHRbMl09blsyXSx0WzNdPW5bM10sdFs0XT1uWzRdLHRbNV09bls1XSx0WzZdPW5bNl0sdFs3XT1uWzddLHRbOF09bls4XSx0WzldPW5bOV0sdFsxMF09blsxMF0sdFsxMV09blsxMV0sdFsxMl09blsxMl0sdFsxM109blsxM10sdFsxNF09blsxNF0sdFsxNV09blsxNV19fTtjbGFzcyBsIGV4dGVuZHMgQXJyYXl7Y29uc3RydWN0b3IodD0wLG49dCxpPXQpe3JldHVybiBzdXBlcih0LG4saSksdGhpcy5jb25zdGFudD0xLHRoaXN9Z2V0IGlzVmVjdG9yMygpe3JldHVybiEwfWdldCB4KCl7cmV0dXJuIHRoaXNbMF19c2V0IHgodCl7dGhpc1swXT10fWdldCB5KCl7cmV0dXJuIHRoaXNbMV19c2V0IHkodCl7dGhpc1sxXT10fWdldCB6KCl7cmV0dXJuIHRoaXNbMl19c2V0IHoodCl7dGhpc1syXT10fXNldCh0LG49dCxpPXQpe3JldHVybiB0Lmxlbmd0aD90aGlzLmNvcHkodCk6KGZ1bmN0aW9uKHQsbixpLHMpe3RbMF09bix0WzFdPWksdFsyXT1zfSh0aGlzLHQsbixpKSx0aGlzKX1jb3B5KHQpe3ZhciBuLGk7cmV0dXJuIGk9dCwobj10aGlzKVswXT1pWzBdLG5bMV09aVsxXSxuWzJdPWlbMl0sdGhpc31hZGQodCxuKXtyZXR1cm4gbj9yKHRoaXMsdCxuKTpyKHRoaXMsdGhpcyx0KSx0aGlzfXN1Yih0LG4pe3JldHVybiBuP2godGhpcyx0LG4pOmgodGhpcyx0aGlzLHQpLHRoaXN9bXVsdGlwbHkodCl7dmFyIG4saSxzO3JldHVybiB0Lmxlbmd0aD8oaT10aGlzLHM9dCwobj10aGlzKVswXT1pWzBdKnNbMF0sblsxXT1pWzFdKnNbMV0sblsyXT1pWzJdKnNbMl0pOmEodGhpcyx0aGlzLHQpLHRoaXN9ZGl2aWRlKHQpe3ZhciBuLGkscztyZXR1cm4gdC5sZW5ndGg/KGk9dGhpcyxzPXQsKG49dGhpcylbMF09aVswXS9zWzBdLG5bMV09aVsxXS9zWzFdLG5bMl09aVsyXS9zWzJdKTphKHRoaXMsdGhpcywxL3QpLHRoaXN9c2NhbGUodCl7cmV0dXJuIGEodGhpcyx0aGlzLHQpLHRoaXN9ZGlzdGFuY2UodCl7cmV0dXJuIHQ/ZnVuY3Rpb24odCxuKXtsZXQgaT1uWzBdLXRbMF0scz1uWzFdLXRbMV0sZT1uWzJdLXRbMl07cmV0dXJuIE1hdGguc3FydChpKmkrcypzK2UqZSl9KHRoaXMsdCk6ZnVuY3Rpb24odCl7bGV0IG49dFswXSxpPXRbMV0scz10WzJdO3JldHVybiBNYXRoLnNxcnQobipuK2kqaStzKnMpfSh0aGlzKX1zcXVhcmVkRGlzdGFuY2UodCl7cmV0dXJuIHQ/ZnVuY3Rpb24odCxuKXtsZXQgaT1uWzBdLXRbMF0scz1uWzFdLXRbMV0sZT1uWzJdLXRbMl07cmV0dXJuIGkqaStzKnMrZSplfSh0aGlzLHQpOmZ1bmN0aW9uKHQpe2xldCBuPXRbMF0saT10WzFdLHM9dFsyXTtyZXR1cm4gbipuK2kqaStzKnN9KHRoaXMpfXNxdWFyZWRMZW5ndGgoKXtyZXR1cm4gdGhpcy5zcXVhcmVkRGlzdGFuY2UoKX1uZWdhdGUodD10aGlzKXt2YXIgbixpO3JldHVybiBpPXQsKG49dGhpcylbMF09LWlbMF0sblsxXT0taVsxXSxuWzJdPS1pWzJdLHRoaXN9cmVmbGVjdCh0KXtsZXQgbj10LmNsb25lKCk7cmV0dXJuIHRoaXMuc3ViKG4ubXVsdGlwbHkoMip0aGlzLmRvdCh0KSkpfWludmVyc2UodD10aGlzKXt2YXIgbixpO3JldHVybiBpPXQsKG49dGhpcylbMF09MS9pWzBdLG5bMV09MS9pWzFdLG5bMl09MS9pWzJdLHRoaXN9bm9ybWFsaXplKCl7cmV0dXJuIG8odGhpcyx0aGlzKSx0aGlzfWRvdCh0KXtyZXR1cm4gdSh0aGlzLHQpfWNyb3NzKHQsbil7cmV0dXJuIGZ1bmN0aW9uKHQsbixpKXtsZXQgcz1uWzBdLGU9blsxXSxyPW5bMl0saD1pWzBdLGE9aVsxXSxvPWlbMl07dFswXT1lKm8tciphLHRbMV09cipoLXMqbyx0WzJdPXMqYS1lKmh9KHRoaXMsdCxuKSx0aGlzfWxlcnAodCxuLGkpe3JldHVybiBmdW5jdGlvbih0LG4saSxzKXtsZXQgZT1uWzBdLHI9blsxXSxoPW5bMl07dFswXT1lK3MqKGlbMF0tZSksdFsxXT1yK3MqKGlbMV0tciksdFsyXT1oK3MqKGlbMl0taCl9KHRoaXMsdCxuLGkpLHRoaXN9aGVybWl0ZSh0LG4saSxzLGUpe3JldHVybiBmdW5jdGlvbih0LG4saSxzLGUscil7bGV0IGg9cipyLGE9aCooMipyLTMpKzEsbz1oKihyLTIpK3IsdT1oKihyLTEpLGw9aCooMy0yKnIpO3RbMF09blswXSphK2lbMF0qbytzWzBdKnUrZVswXSpsLHRbMV09blsxXSphK2lbMV0qbytzWzFdKnUrZVsxXSpsLHRbMl09blsyXSphK2lbMl0qbytzWzJdKnUrZVsyXSpsfSh0aGlzLHQsbixpLHMsZSksdGhpc31iZXppZXIodCxuLGkscyxlKXtyZXR1cm4gZnVuY3Rpb24odCxuLGkscyxlLHIpe2xldCBoPTEtcixhPWgqaCxvPXIqcix1PWEqaCxsPTMqciphLGM9MypvKmgsbT1vKnI7dFswXT1uWzBdKnUraVswXSpsK3NbMF0qYytlWzBdKm0sdFsxXT1uWzFdKnUraVsxXSpsK3NbMV0qYytlWzFdKm0sdFsyXT1uWzJdKnUraVsyXSpsK3NbMl0qYytlWzJdKm19KHRoaXMsdCxuLGkscyxlKSx0aGlzfWFwcGx5TWF0cml4NCh0KXtyZXR1cm4gZnVuY3Rpb24odCxuLGkpe2xldCBzPW5bMF0sZT1uWzFdLHI9blsyXSxoPWlbM10qcytpWzddKmUraVsxMV0qcitpWzE1XTtoPWh8fDEsdFswXT0oaVswXSpzK2lbNF0qZStpWzhdKnIraVsxMl0pL2gsdFsxXT0oaVsxXSpzK2lbNV0qZStpWzldKnIraVsxM10pL2gsdFsyXT0oaVsyXSpzK2lbNl0qZStpWzEwXSpyK2lbMTRdKS9ofSh0aGlzLHRoaXMsdCksdGhpc31hcHBseU1hdHJpeDModCl7cmV0dXJuIGZ1bmN0aW9uKHQsbixpKXtsZXQgcz1uWzBdLGU9blsxXSxyPW5bMl07dFswXT1zKmlbMF0rZSppWzNdK3IqaVs2XSx0WzFdPXMqaVsxXStlKmlbNF0rcippWzddLHRbMl09cyppWzJdK2UqaVs1XStyKmlbOF19KHRoaXMsdGhpcyx0KSx0aGlzfWFwcGx5UXVhdGVybmlvbih0KXtyZXR1cm4gZnVuY3Rpb24odCxuLGkpe2xldCBzPW5bMF0sZT1uWzFdLHI9blsyXSxoPWlbMF0sYT1pWzFdLG89aVsyXSx1PWlbM10sbD11KnMrYSpyLW8qZSxjPXUqZStvKnMtaCpyLG09dSpyK2gqZS1hKnMsZj0taCpzLWEqZS1vKnI7dFswXT1sKnUrZiotaCtjKi1vLW0qLWEsdFsxXT1jKnUrZiotYSttKi1oLWwqLW8sdFsyXT1tKnUrZiotbytsKi1hLWMqLWh9KHRoaXMsdGhpcyx0KSx0aGlzfXNldEZyb21NYXRyaXhQb3NpdGlvbih0KXtyZXR1cm4gdGhpcy54PXRbMTJdLHRoaXMueT10WzEzXSx0aGlzLno9dFsxNF0sdGhpc31hbmdsZSh0KXtyZXR1cm4gZnVuY3Rpb24odCxuKXtsZXQgaT1bLi4udF0scz1bLi4ubl07byhpLGkpLG8ocyxzKTtsZXQgZT11KGkscyk7cmV0dXJuIGU+MT8wOmU8LTE/TWF0aC5QSTpNYXRoLmFjb3MoZSl9KHRoaXMsdCl9ZXF1YWxzKHQpe3JldHVybiBpPXQsKG49dGhpcylbMF09PT1pWzBdJiZuWzFdPT09aVsxXSYmblsyXT09PWlbMl07dmFyIG4saX1jbG9uZSgpe3JldHVybiBuZXcgbCh0aGlzWzBdLHRoaXNbMV0sdGhpc1syXSl9ZnJvbUFycmF5KHQsbj0wKXtyZXR1cm4gdGhpc1swXT10W25dLHRoaXNbMV09dFtuKzFdLHRoaXNbMl09dFtuKzJdLHRoaXN9bWluKHQpe3JldHVybiB0aGlzWzBdPU1hdGgubWluKHRoaXNbMF0sdC54KSx0aGlzWzFdPU1hdGgubWluKHRoaXNbMV0sdC55KSx0aGlzWzJdPU1hdGgubWluKHRoaXNbMl0sdC56KSx0aGlzfW1heCh0KXtyZXR1cm4gdGhpc1swXT1NYXRoLm1heCh0aGlzWzBdLHQueCksdGhpc1sxXT1NYXRoLm1heCh0aGlzWzFdLHQueSksdGhpc1syXT1NYXRoLm1heCh0aGlzWzJdLHQueiksdGhpc310b0FycmF5KCl7cmV0dXJuIEFycmF5LmZyb20odGhpcyl9c3RhdGljIGNvcHlUbyh0LG4pe3RbMF09blswXSx0WzFdPW5bMV0sdFsyXT1uWzJdfX1jb25zdCBjPVtuZXcgbCxuZXcgbCxuZXcgbCxuZXcgbCxuZXcgbCxuZXcgbCxuZXcgbCxuZXcgbF07Y2xhc3MgbXtjb25zdHJ1Y3Rvcih0PW5ldyBsKDEvMCksbj1uZXcgbCgtMS8wKSl7dGhpcy5taW49dCx0aGlzLm1heD1ufW1ha2VFbXB0eSgpe3JldHVybiB0aGlzLm1pbi54PXRoaXMubWluLnk9dGhpcy5taW4uej0xLzAsdGhpcy5tYXgueD10aGlzLm1heC55PXRoaXMubWF4Lno9LTEvMCx0aGlzfWlzRW1wdHkoKXtyZXR1cm4gdGhpcy5tYXgueDx0aGlzLm1pbi54fHx0aGlzLm1heC55PHRoaXMubWluLnl8fHRoaXMubWF4Lno8dGhpcy5taW4uen1nZXRDZW50ZXIodCl7cmV0dXJuIHRoaXMuaXNFbXB0eSgpP3Quc2V0KDAsMCwwKTp0LmFkZCh0aGlzLm1pbix0aGlzLm1heCkubXVsdGlwbHkoLjUpfWdldFNpemUodCl7cmV0dXJuIHRoaXMuaXNFbXB0eSgpP3Quc2V0KDAsMCwwKTp0LnN1Yih0aGlzLm1heCx0aGlzLm1pbil9ZXhwYW5kQnlQb2ludCh0KXtyZXR1cm4gdGhpcy5taW4ubWluKHQpLHRoaXMubWF4Lm1heCh0KSx0aGlzfXVuaW9uKHQpe3JldHVybiB0aGlzLm1pbi5taW4odC5taW4pLHRoaXMubWF4Lm1heCh0Lm1heCksdGhpc31jb3B5KHQpe3JldHVybiB0aGlzLm1pbi5jb3B5KHQubWluKSx0aGlzLm1heC5jb3B5KHQubWF4KSx0aGlzfWludGVyc2VjdHNCb3godCl7cmV0dXJuISh0Lm1heC54PHRoaXMubWluLnh8fHQubWluLng+dGhpcy5tYXgueHx8dC5tYXgueTx0aGlzLm1pbi55fHx0Lm1pbi55PnRoaXMubWF4Lnl8fHQubWF4Lno8dGhpcy5taW4uenx8dC5taW4uej50aGlzLm1heC56KX1zZXRGcm9tUG9pbnRzKHQpe3RoaXMubWFrZUVtcHR5KCk7Zm9yKGxldCBuPTAsaT10Lmxlbmd0aDtuPGk7bisrKXRoaXMuZXhwYW5kQnlQb2ludCh0W25dKTtyZXR1cm4gdGhpc31hcHBseU1hdHJpeDQodCl7cmV0dXJuIHRoaXMuaXNFbXB0eSgpfHwoY1swXS5zZXQodGhpcy5taW4ueCx0aGlzLm1pbi55LHRoaXMubWluLnopLmFwcGx5TWF0cml4NCh0KSxjWzFdLnNldCh0aGlzLm1pbi54LHRoaXMubWluLnksdGhpcy5tYXgueikuYXBwbHlNYXRyaXg0KHQpLGNbMl0uc2V0KHRoaXMubWluLngsdGhpcy5tYXgueSx0aGlzLm1pbi56KS5hcHBseU1hdHJpeDQodCksY1szXS5zZXQodGhpcy5taW4ueCx0aGlzLm1heC55LHRoaXMubWF4LnopLmFwcGx5TWF0cml4NCh0KSxjWzRdLnNldCh0aGlzLm1heC54LHRoaXMubWluLnksdGhpcy5taW4ueikuYXBwbHlNYXRyaXg0KHQpLGNbNV0uc2V0KHRoaXMubWF4LngsdGhpcy5taW4ueSx0aGlzLm1heC56KS5hcHBseU1hdHJpeDQodCksY1s2XS5zZXQodGhpcy5tYXgueCx0aGlzLm1heC55LHRoaXMubWluLnopLmFwcGx5TWF0cml4NCh0KSxjWzddLnNldCh0aGlzLm1heC54LHRoaXMubWF4LnksdGhpcy5tYXgueikuYXBwbHlNYXRyaXg0KHQpLHRoaXMuc2V0RnJvbVBvaW50cyhjKSksdGhpc319ZnVuY3Rpb24gZih0LG4saT0wLHM9dC5sZW5ndGgsZT1NYXRoLmZsb29yKChpK3MpLzIpKXtmb3IobGV0IHI9aTtyPD1lO3IrKyl7bGV0IGk9cixlPXRbcl07Zm9yKGxldCBoPXIrMTtoPHM7aCsrKW4oZSx0W2hdKXx8KGk9aCxlPXRbaF0seCh0LHIsaSkpfX1mdW5jdGlvbiB4KHQsbixpKXtjb25zdCBzPXRbaV07dFtpXT10W25dLHRbbl09c31sZXQgeSxwPTAsZz0wLE09MCxkPSExO2NvbnN0IHo9bmV3IGw7ZnVuY3Rpb24gdyh0LG4pe3JldHVybntwcmltaXRpdmVzOnQsYm91bmRzOm59fWZ1bmN0aW9uIGIodCxuLGkpe2xldCBzPWlbbl0tdC5taW5bbl07cmV0dXJuIHQubWF4W25dPnQubWluW25dJiYocy89dC5tYXhbbl0tdC5taW5bbl0pLHN9ZnVuY3Rpb24gdih0KXtyZXR1cm4gdC5nZXRTaXplKHopLDIqKHoueCp6Lnorei54KnoueSt6Lnoqei55KX1mdW5jdGlvbiBxKHQsbixpLHM9ITEpe2NvbnN0IGU9bmV3IG07Zm9yKGxldCB1PW47dTxpO3UrKyllLnVuaW9uKHRbdV0uYm91bmRzKTtpZihkKXtNKz0xLHkoKE0rZykvcCl9Y29uc3Qgcj1pLW47aWYoMT09PXIpcmV0dXJuIHcodC5zbGljZShuLGkpLGUpO3tjb25zdCB1PW5ldyBtO2ZvcihsZXQgcz1uO3M8aTtzKyspdS5leHBhbmRCeVBvaW50KHRbc10uY2VudGVyKTtjb25zdCBsPSh1LmdldFNpemUoeiksei54Pnouej96Lng+ei55PyJ4IjoieSI6ei56PnoueT8ieiI6InkiKTtsZXQgYz1NYXRoLmZsb29yKChuK2kpLzIpO2lmKHI8PTQpZih0LCgodCxuKT0+dC5jZW50ZXJbbF08bi5jZW50ZXJbbF0pLG4saSxjKTtlbHNlIGlmKHUubWF4W2xdPT09dS5taW5bbF0pe2lmKCFzKXJldHVybiB3KHQuc2xpY2UobixpKSxlKTtmKHQsKCh0LG4pPT50LmNlbnRlcltsXTxuLmNlbnRlcltsXSksbixpLGMpfWVsc2V7Y29uc3Qgcz0xMixyPVtdO2ZvcihsZXQgdD0wO3Q8czt0Kyspci5wdXNoKHtib3VuZHM6bmV3IG0sY291bnQ6MH0pO2ZvcihsZXQgZT1uO2U8aTtlKyspe2xldCBuPU1hdGguZmxvb3IocypiKHUsbCx0W2VdLmNlbnRlcikpO249PT1yLmxlbmd0aCYmKG49ci5sZW5ndGgtMSkscltuXS5jb3VudCsrLHJbbl0uYm91bmRzLnVuaW9uKHRbZV0uYm91bmRzKX1jb25zdCBoPVtdO2ZvcihsZXQgdD0wO3Q8ci5sZW5ndGgtMTt0Kyspe2NvbnN0IG49bmV3IG0saT1uZXcgbTtsZXQgcz0wLGE9MDtmb3IobGV0IGU9MDtlPD10O2UrKyluLnVuaW9uKHJbZV0uYm91bmRzKSxzKz1yW2VdLmNvdW50O2ZvcihsZXQgZT10KzE7ZTxyLmxlbmd0aDtlKyspaS51bmlvbihyW2VdLmJvdW5kcyksYSs9cltlXS5jb3VudDtoLnB1c2goLjErKHMqdihuKSthKnYoaSkpL3YoZSkpfWxldCBhPWhbMF0sbz0wO2ZvcihsZXQgdD0xO3Q8aC5sZW5ndGg7dCsrKWhbdF08YSYmKGE9aFt0XSxvPXQpO2M9ZnVuY3Rpb24odCxuLGk9MCxzPXQubGVuZ3RoKXtmb3IoO2khPT1zOyl7Zm9yKDtuKHRbaV0pOylpZigrK2k9PT1zKXJldHVybiBpO2Rve2lmKGk9PT0tLXMpcmV0dXJuIGl9d2hpbGUoIW4odFtzXSkpO3godCxpLHMpLGkrK31yZXR1cm4gaX0odCwodD0+e2xldCBuPU1hdGguZmxvb3Ioci5sZW5ndGgqYih1LGwsdC5jZW50ZXIpKTtyZXR1cm4gbj09PXIubGVuZ3RoJiYobj1yLmxlbmd0aC0xKSxuPD1vfSksbixpKX1yZXR1cm4gaD1sLGE9cSh0LG4sYyxzKSxvPXEodCxjLGkscykse2NoaWxkMDphLGNoaWxkMTpvLGJvdW5kczoobmV3IG0pLnVuaW9uKGEuYm91bmRzKS51bmlvbihvLmJvdW5kcyksc3BsaXRBeGlzOmh9fXZhciBoLGEsb31mdW5jdGlvbiBBKHQsbil7Y29uc3R7cHJpbWl0aXZlSW5mb0FycjppfT1mdW5jdGlvbih0KXtsZXQgbj0wO2NvbnN0IGk9W107Zm9yKGxldCBzPTA7czx0Lmxlbmd0aDtzKyspe2NvbnN0IGU9W10scj10W3NdLGg9ci5pbmRpY2VzLGE9ci5wb3NpdGlvbixvPXIubWF0ZXJpYWxNZXNoSW5kZXgsdT1uZXcgbCxjPW5ldyBsLGY9bmV3IGwseD1uZXcgbCx5PW5ldyBsO2ZvcihsZXQgdD0wO3Q8aC5hcnJheS5sZW5ndGg7dCs9Myl7Y29uc3QgaT1oLmFycmF5W3RdLHM9aC5hcnJheVt0KzFdLHI9aC5hcnJheVt0KzJdLHA9bmV3IG0sZz0zLE09aSpnO3UueD1hLmFycmF5W01dLHUueT1hLmFycmF5W00rMV0sdS56PWEuYXJyYXlbTSsyXTtjb25zdCBkPXMqZztjLng9YS5hcnJheVtkXSxjLnk9YS5hcnJheVtkKzFdLGMuej1hLmFycmF5W2QrMl07Y29uc3Qgej1yKmc7Zi54PWEuYXJyYXlbel0sZi55PWEuYXJyYXlbeisxXSxmLno9YS5hcnJheVt6KzJdLHAuZXhwYW5kQnlQb2ludCh1KSxwLmV4cGFuZEJ5UG9pbnQoYykscC5leHBhbmRCeVBvaW50KGYpLHguc3ViKGYsdSkseS5zdWIoYyx1KTtjb25zdCB3PShuZXcgbCkuY3Jvc3MoeSx4KS5ub3JtYWxpemUoKSxiPXtib3VuZHM6cCxjZW50ZXI6cC5nZXRDZW50ZXIobmV3IGwpLGluZGljZXM6W2krbixzK24scituXSxmYWNlTm9ybWFsOncsbWF0ZXJpYWxJRDpvJiZvLmFycmF5W2kqby5pdGVtU2l6ZV19O2UucHVzaChiKX1uKz1yLnBvc2l0aW9uLmFycmF5Lmxlbmd0aC8zLGkucHVzaChlKX1yZXR1cm57cHJpbWl0aXZlSW5mb0FycjppfX0odCkscz1bXTtpZihuKXtwPTAsZz0wLGQ9ITAseT1uO2ZvcihsZXQgdD0wO3Q8aS5sZW5ndGg7dCsrKXArPTIqaVt0XS5sZW5ndGgtMX1mb3IobGV0IGU9MDtlPGkubGVuZ3RoO2UrKyl7Y29uc3QgdD1pW2VdO009MDtjb25zdCBuPXEodCwwLHQubGVuZ3RoKTtnKz0yKnQubGVuZ3RoLTEscy5wdXNoKG4pfXJldHVybntibGFzQlZIczpzfX1mdW5jdGlvbiBCKHQsbj0wLGk9W10pe2NvbnN0IHM9W107bGV0IGU9MTtjb25zdCByPXt4OjAseToxLHo6Mn0saD0odCxhPTEpPT57aWYoZT1NYXRoLm1heChhLGUpLHQucHJpbWl0aXZlcyl7Y29uc3Qgbj10O2ZvcihsZXQgdD0wO3Q8bi5wcmltaXRpdmVzLmxlbmd0aDt0Kyspe2NvbnN0IGU9bi5wcmltaXRpdmVzW3RdO2lmKHZvaWQgMCE9PWUuaW5kaWNlcyl7Y29uc3QgdD1lO3MucHVzaCh0LmluZGljZXNbMF0sdC5pbmRpY2VzWzFdLHQuaW5kaWNlc1syXSwtMSx0LmZhY2VOb3JtYWwueCx0LmZhY2VOb3JtYWwueSx0LmZhY2VOb3JtYWwueix0Lm1hdGVyaWFsSUR8fDApfWVsc2V7Y29uc3QgdD1lO3MucHVzaChpW3QuZ2VvbWV0cnlJRF0sdC5tYXRlcmlhbElELHQubWVzaElELC0xLE51bWJlcih0LnZpc2libGUpLDAsMCwwKX19fWVsc2V7Y29uc3QgaT10LGU9aS5ib3VuZHM7cy5wdXNoKGUubWluLngsZS5taW4ueSxlLm1pbi56LHJbaS5zcGxpdEF4aXNdLGUubWF4LngsZS5tYXgueSxlLm1heC56LC0xKTtjb25zdCBvPXMubGVuZ3RoLTE7aChpLmNoaWxkMCxhKzEpLHNbb109cy5sZW5ndGgvNCtuLGgoaS5jaGlsZDEsYSsxKX19O3JldHVybiBoKHQpLHtjb3VudDpzLmxlbmd0aC80LG1heERlcHRoOmUsZmxhdERhdGE6c319c2VsZi5vbm1lc3NhZ2U9ZnVuY3Rpb24oe2RhdGE6dH0pe2NvbnN0e2dlb21ldHJpZXM6bn09dDtsZXQgaT1wZXJmb3JtYW5jZS5ub3coKTtjb25zdCBzPXQ9Pntjb25zdCBuPXBlcmZvcm1hbmNlLm5vdygpOyhuLWk+PTEwfHwxPT09dCkmJihpPW4sc2VsZi5wb3N0TWVzc2FnZSh7ZXJyb3I6bnVsbCxmbGF0QkxBU0JWSEluZm86bnVsbCxwcm9ncmVzczp0fSkpfTt0cnl7Y29uc3R7Ymxhc0JWSHM6dH09QShuLHMpLGk9ZnVuY3Rpb24odCxuPTApe2NvbnN0IGk9W107bGV0IHM9W10sZT0xO2ZvcihsZXQgcj0wO3I8dC5sZW5ndGg7cisrKXtjb25zdCBoPUIodFtyXSxuKTtlPU1hdGgubWF4KGgubWF4RGVwdGgsZSkscy5wdXNoKG4pLG4rPWguY291bnQsaS5wdXNoKGgpfXJldHVybntibGFzQnVmZmVyU3BsaXRJbmRleDpzLHRvdGFsQkxBU0RhdGFMZW5ndGg6NCpuLHRvdGFsQkxBU0RhdGFDb3VudDpuLGZsYXRCVkhJbmZvczppLG1heERlcHRoOmV9fSh0KTtzZWxmLnBvc3RNZXNzYWdlKHtlcnJvcjpudWxsLGZsYXRCTEFTQlZISW5mbzppLHByb2dyZXNzOm51bGx9KX1jYXRjaChlKXtzZWxmLnBvc3RNZXNzYWdlKHtlcnJvcjplLGZsYXRCTEFTQlZISW5mbzpudWxsLHByb2dyZXNzOm51bGx9KX19fSgpOwo=",xe="undefined"!=typeof window&&window.Blob&&new Blob([atob(me)],{type:"text/javascript;charset=utf-8"});function Te(){const t=xe&&(window.URL||window.webkitURL).createObjectURL(xe);try{return t?new Worker(t,{}):new Worker("data:application/javascript;base64,"+me,{type:"module"})}finally{t&&(window.URL||window.webkitURL).revokeObjectURL(t)}}class ge{constructor(){this.worker=new Te,this.building=!1}build(t,e){if(this.building)throw new Error("BVHWorker is building");this.building=!0;const{worker:n}=this;return new Promise(((a,i)=>{n.onmessage=t=>{this.building=!1;const{flatBLASBVHInfo:s,error:r,progress:o}=t.data;r?i(new Error(r)):s?(n.onmessage=null,a(s)):null!=o&&e(o)},Array.isArray(t)||(t=[t]),n.postMessage({geometries:t})}))}}function ve(t){const e=new Float32Array(16*t.length);for(let n=0;n<t.length;n++){const a=t[n].localToWorldMat;for(let t=0;t<16;t++){e[16*n+t]=a[t]}}return e}class Se{constructor(t,e){this.gl=t,this.useWebWorker=e,this.workerBuilder=new ge}rebuildTLAS(t,e=!1){const{gl:n,geometryIndexMap:a}=this;let{meshes:i,materialIndexMap:s}=t;i=i.filter((t=>!t.tlasMask));const r=he(ue(i,a,s),this.lastFlatBLASBVHInfo.blasBufferSplitIndex),o=r.flatData.length,l=new Float32Array(o);l.set(r.flatData,0);const c=new Mt(n,l,4),u=ve(i);return{tlasBuffer:c,transformBuffer:new Mt(n,u,4)}}async buildDynamic(t,e,n,a,i){const{gl:s,useWebWorker:r}=this;this.geometryIndexMap=e;let{meshes:o,materialIndexMap:l}=t;const c=Array.from(e.keys()),u=[];if(c.forEach(((t,e)=>{u[e]={};const n=u[e];n.position=t.position,n.indices=t.indices})),r)this.lastFlatBLASBVHInfo=await this.workerBuilder.build(u,i);else{const{blasBVHs:t}=de(u);this.lastFlatBLASBVHInfo=pe(t)}o=o.filter((t=>!t.tlasMask));const d=he(ue(o,e,l),this.lastFlatBLASBVHInfo.blasBufferSplitIndex),f=this.lastFlatBLASBVHInfo.totalBLASDataLength,h=new Float32Array(f),p=this.lastFlatBLASBVHInfo.flatBVHInfos;let m=0;for(let F=0;F<p.length;F++){const t=p[F].flatData;h.set(t,m),m+=t.length}const x=new Mt(s,h,4),T=d.flatData.length,g=new Float32Array(T);g.set(d.flatData,0);const v=new Mt(s,g,4),S=new Float32Array(4*n),b=new Float32Array(4*n);let A=0;c.forEach((t=>{const e=t.position.array,n=t.normal.array,a=t.uv.array,i=t.position.count;for(let s=0;s<i;s++)S[A+4*s+0]=e[3*s+0],S[A+4*s+1]=e[3*s+1],S[A+4*s+2]=e[3*s+2],S[A+4*s+3]=a?a[2*s+0]:0,b[A+4*s+0]=n[3*s+0],b[A+4*s+1]=n[3*s+1],b[A+4*s+2]=n[3*s+2],b[A+4*s+3]=a?a[2*s+1]:0;A+=4*i}));const M=new Mt(s,S,4),y=new Mt(s,b,4),L=ve(o);return{positionBuffer:M,normalBuffer:y,blasBuffer:x,tlasBuffer:v,transformBuffer:new Mt(s,L,4),maxDepth:this.lastFlatBLASBVHInfo.maxDepth+d.maxDepth}}async buildStatic(t,e){const{gl:n,useWebWorker:a}=this,{geometry:i}=t;if(a)this.lastFlatBLASBVHInfo=await this.workerBuilder.build([i],e);else{const{blasBVHs:t}=de([i]);this.lastFlatBLASBVHInfo=pe(t)}const s=this.lastFlatBLASBVHInfo.flatBVHInfos[0],r=new Float32Array(s.flatData),o=new Mt(n,r,4),l=i.position.count,c=new Float32Array(4*l),u=new Float32Array(4*l),d=i.position.array,f=i.normal.array,h=i.uv.array;for(let p=0;p<l;p++)c[4*p+0]=d[3*p+0],c[4*p+1]=d[3*p+1],c[4*p+2]=d[3*p+2],c[4*p+3]=h?h[2*p+0]:0,u[4*p+0]=f[3*p+0],u[4*p+1]=f[3*p+1],u[4*p+2]=f[3*p+2],u[4*p+3]=h?h[2*p+1]:0;return{positionBuffer:new Mt(n,c,4),normalBuffer:new Mt(n,u,4),bvhBuffer:o,maxDepth:s.maxDepth}}}class be{constructor(t,e,n=!0){this.gl=t,this.resourcePool=e,this.useWebWorker=n,this.bvhBuilder=new Se(t,n)}destroy(){const{resourcePool:t}=this;t.destoryResourceByName("MaterialBuffer"),t.destoryResourceByName("PositionBuffer"),t.destoryResourceByName("NormalBuffer"),t.destoryResourceByName("BVHBuffer"),t.destoryResourceByName("MaterialTextureArray")}async buildBVH(t,e,n){const{resourcePool:a}=this,{maxDepth:i,positionBuffer:s,normalBuffer:r,bvhBuffer:o}=await this.bvhBuilder.buildStatic(e,n);a.setResource("PositionBuffer",s),a.setResource("NormalBuffer",r),a.setResource("BVHBuffer",o),t.bvhDefines={STACK_SIZE:i,BVH_COLUMNS:o.textureDim.columnsLog,VERTEX_COLUMNS:s.textureDim.columnsLog}}async build(t,e){let{meshes:n,materialIndexMap:a,materials:i}=t;this.destroy(),1===n.length&&"LGLDefaultMesh"==n[0].name&&(n[0].visible=!0),n=n.filter((t=>1==t.visible));const s=Wt(n,!0);t.geometryInfo=s;const r=Gt(n,a,s),{materialDefines:o,textureArrayRes:l,materialBuffer:c}=await Zt(this.gl,i,!1);t.mergedMesh=r,this.resourcePool.setResource("MaterialBuffer",c,"Buffer"),this.resourcePool.setResource("MaterialTextureArray",l);const{uvTransDefines:u,uvTransformBufferTex:d}=Jt(this.gl,a);this.resourcePool.setResource("TextureUVTransformBuffer",d),this.lastMaterialBuffer=c,t.materialDefines=o,await this.buildBVH(t,r,e),Object.assign(t.bvhDefines,u)}updateMaterialParams(t){const{lastMaterialBuffer:e}=this,{materials:n}=t;Yt(e,n)}async rebuildMaterialBuffer(t){const{materials:e}=t,{textureArrayRes:n}=await Qt(this.gl,this.lastMaterialBuffer,e);this.resourcePool.setResource("MaterialTextureArray",n)}}class Ae{constructor(t,e,n=!0){this.gl=t,this.resourcePool=e,this.useWebWorker=n,this.bvhBuilder=new Se(t,n)}destroy(){const{resourcePool:t}=this;t.destoryResourceByName("MaterialBuffer"),t.destoryResourceByName("MaterialTextureArray"),t.destoryResourceByName("PositionBuffer"),t.destoryResourceByName("NormalBuffer"),t.destoryResourceByName("TLASBuffer"),t.destoryResourceByName("BLASBuffer"),t.destoryResourceByName("TLASTransformBuffer")}async buildBVH(t,e){const{resourcePool:n}=this,{geometryIndexMap:a,vertexTotalCount:i,indicesTotalCount:s}=t.geometryInfo,{positionBuffer:r,normalBuffer:o,blasBuffer:l,tlasBuffer:c,transformBuffer:u,maxDepth:d}=await this.bvhBuilder.buildDynamic(t,a,i,s,e);n.setResource("PositionBuffer",r),n.setResource("NormalBuffer",o),n.setResource("TLASBuffer",c),n.setResource("TLASTransformBuffer",u),n.setResource("BLASBuffer",l),t.bvhDefines={BVH_DYNAMIC:1,STACK_SIZE:32,BLAS_COLUMNS:l.textureDim.columnsLog,TLAS_COLUMNS:c.textureDim.columnsLog,TLAS_TRANSFORM_COLUMNS:u.textureDim.columnsLog,VERTEX_COLUMNS:r.textureDim.columnsLog}}async build(t,e){let{meshes:n,materials:a,materialIndexMap:i}=t;const s=Wt(n,!1);t.geometryInfo=s;const{materialDefines:r,textureImageMap:o,textureArrayRes:l,materialBuffer:c}=await Zt(this.gl,a,!0);this.resourcePool.setResource("MaterialBuffer",c,"Buffer"),this.resourcePool.setResource("MaterialTextureArray",l),t.materialDefines=r;const{uvTransDefines:u,uvTransformBufferTex:d}=Jt(this.gl,i);this.resourcePool.setResource("TextureUVTransformBuffer",d),this.lastMaterialBuffer=c,await this.buildBVH(t,e),Object.assign(t.bvhDefines,u)}updateMaterialParams(t){const{materials:e}=t;Yt(this.lastMaterialBuffer,e)}rebuildTLAS(t,e=!1){const{tlasBuffer:n,transformBuffer:a}=this.bvhBuilder.rebuildTLAS(t,e);this.resourcePool.updateResource("TLASBuffer",n,"Buffer"),this.resourcePool.updateResource("TLASTransformBuffer",a,"Buffer")}async rebuildMaterialBuffer(t){const{materials:e}=t,{textureArrayRes:n}=await Qt(this.gl,this.lastMaterialBuffer,e);this.resourcePool.setResource("MaterialTextureArray",n)}}class Me{constructor(t){this.gl=t,this.curTileNum=-1,this.totalTileNum=-1,this.columns=0,this.rows=0,this.tileWidth=0,this.tileHeight=0,this.viewWidth=0,this.viewHeight=0}reset(){this.curTileNum=-1}setSize(t,e){this.viewWidth=t,this.viewHeight=e,this.computeTileDimensions()}setTileCount(t){this.totalTileNum=t,this.computeTileDimensions(),this.reset()}computeTileDimensions(){const{viewWidth:t,viewHeight:e}=this,n=Math.sqrt(this.totalTileNum);this.tileWidth=Math.ceil(t/n),this.tileHeight=Math.ceil(e/n),this.columns=Math.ceil(t/this.tileWidth),this.rows=Math.ceil(e/this.tileHeight),this.columns&&this.rows&&(this.totalTileNum=this.columns*this.rows)}nextTile(){const{totalTileNum:t,tileWidth:e,tileHeight:n,viewHeight:a,columns:i,rows:s}=this;this.curTileNum++,this.curTileNum%t==0&&(this.curTileNum=0);const r=this.curTileNum===t-1,o=this.curTileNum%i,l=Math.floor(this.curTileNum/i)%s;return{x:o*e,y:Math.min(a,l*n),tileWidth:e,tileHeight:n,isFirstTile:0===this.curTileNum,isLastTile:r}}}class ye{constructor(t,e){this.gl=t,this.fullscreenTriangle=e}createPipeline(t){const{gl:e,fullscreenTriangle:n}=this,a={gl:e,vertex:n.vertexShader,fragment:"layout(location = 0) out vec4 out_color;\n\nuniform sampler2D inputBuffer;\nuniform vec2 resolution;\nin vec2 vCoord;\n\n// FXAA 3.11 implementation by NVIDIA, ported to WebGL by Agost Biro (biro@archilogic.com)\n//----------------------------------------------------------------------------------\n// File:        es3-keplerFXAAassetsshaders/FXAA_DefaultES.frag\n// SDK Version: v3.00\n// Email:       gameworks@nvidia.com\n// Site:        http://developer.nvidia.com/\n\n// Copyright (c) 2014-2015, NVIDIA CORPORATION. All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions\n// are met:\n//  * Redistributions of source code must retain the above copyright\n//    notice, this list of conditions and the following disclaimer.\n//  * Redistributions in binary form must reproduce the above copyright\n//    notice, this list of conditions and the following disclaimer in the\n//    documentation and/or other materials provided with the distribution.\n//  * Neither the name of NVIDIA CORPORATION nor the names of its\n//    contributors may be used to endorse or promote products derived\n//    from this software without specific prior written permission.\n\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AS IS AND ANY\n// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n// PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n//----------------------------------------------------------------------------------\n\n#define FXAA_PC 1\n#define FXAA_GLSL_100 1\n#define FXAA_QUALITY_PRESET 12\n\n#define FXAA_GREEN_AS_LUMA 1\n\n/*--------------------------------------------------------------------------*/\n#ifndef FXAA_PC_CONSOLE\n    //\n    // The console algorithm for PC is included\n    // for developers targeting really low spec machines.\n    // Likely better to just run FXAA_PC, and use a really low preset.\n    //\n    #define FXAA_PC_CONSOLE 0\n#endif\n/*--------------------------------------------------------------------------*/\n#ifndef FXAA_GLSL_120\n    #define FXAA_GLSL_120 0\n#endif\n/*--------------------------------------------------------------------------*/\n#ifndef FXAA_GLSL_130\n    #define FXAA_GLSL_130 0\n#endif\n/*--------------------------------------------------------------------------*/\n#ifndef FXAA_HLSL_3\n    #define FXAA_HLSL_3 0\n#endif\n/*--------------------------------------------------------------------------*/\n#ifndef FXAA_HLSL_4\n    #define FXAA_HLSL_4 0\n#endif\n/*--------------------------------------------------------------------------*/\n#ifndef FXAA_HLSL_5\n    #define FXAA_HLSL_5 0\n#endif\n/*==========================================================================*/\n#ifndef FXAA_GREEN_AS_LUMA\n    //\n    // For those using non-linear color,\n    // and either not able to get luma in alpha, or not wanting to,\n    // this enables FXAA to run using green as a proxy for luma.\n    // So with this enabled, no need to pack luma in alpha.\n    //\n    // This will turn off AA on anything which lacks some amount of green.\n    // Pure red and blue or combination of only R and B, will get no AA.\n    //\n    // Might want to lower the settings for both,\n    //    fxaaConsoleEdgeThresholdMin\n    //    fxaaQualityEdgeThresholdMin\n    // In order to insure AA does not get turned off on colors\n    // which contain a minor amount of green.\n    //\n    // 1 = On.\n    // 0 = Off.\n    //\n    #define FXAA_GREEN_AS_LUMA 0\n#endif\n/*--------------------------------------------------------------------------*/\n#ifndef FXAA_EARLY_EXIT\n    //\n    // Controls algorithm's early exit path.\n    // On PS3 turning this ON adds 2 cycles to the shader.\n    // On 360 turning this OFF adds 10ths of a millisecond to the shader.\n    // Turning this off on console will result in a more blurry image.\n    // So this defaults to on.\n    //\n    // 1 = On.\n    // 0 = Off.\n    //\n    #define FXAA_EARLY_EXIT 1\n#endif\n/*--------------------------------------------------------------------------*/\n#ifndef FXAA_DISCARD\n    //\n    // Only valid for PC OpenGL currently.\n    // Probably will not work when FXAA_GREEN_AS_LUMA = 1.\n    //\n    // 1 = Use discard on pixels which don't need AA.\n    //     For APIs which enable concurrent TEX+ROP from same surface.\n    // 0 = Return unchanged color on pixels which don't need AA.\n    //\n    #define FXAA_DISCARD 0\n#endif\n/*--------------------------------------------------------------------------*/\n#ifndef FXAA_FAST_PIXEL_OFFSET\n    //\n    // Used for GLSL 120 only.\n    //\n    // 1 = GL API supports fast pixel offsets\n    // 0 = do not use fast pixel offsets\n    //\n    #ifdef GL_EXT_gpu_shader4\n        #define FXAA_FAST_PIXEL_OFFSET 1\n    #endif\n    #ifdef GL_NV_gpu_shader5\n        #define FXAA_FAST_PIXEL_OFFSET 1\n    #endif\n    #ifdef GL_ARB_gpu_shader5\n        #define FXAA_FAST_PIXEL_OFFSET 1\n    #endif\n    #ifndef FXAA_FAST_PIXEL_OFFSET\n        #define FXAA_FAST_PIXEL_OFFSET 0\n    #endif\n#endif\n/*--------------------------------------------------------------------------*/\n#ifndef FXAA_GATHER4_ALPHA\n    //\n    // 1 = API supports gather4 on alpha channel.\n    // 0 = API does not support gather4 on alpha channel.\n    //\n    #if (FXAA_HLSL_5 == 1)\n        #define FXAA_GATHER4_ALPHA 1\n    #endif\n    #ifdef GL_ARB_gpu_shader5\n        #define FXAA_GATHER4_ALPHA 1\n    #endif\n    #ifdef GL_NV_gpu_shader5\n        #define FXAA_GATHER4_ALPHA 1\n    #endif\n    #ifndef FXAA_GATHER4_ALPHA\n        #define FXAA_GATHER4_ALPHA 0\n    #endif\n#endif\n\n\n/*============================================================================\n                        FXAA QUALITY - TUNING KNOBS\n------------------------------------------------------------------------------\nNOTE the other tuning knobs are now in the shader function inputs!\n============================================================================*/\n#ifndef FXAA_QUALITY_PRESET\n    //\n    // Choose the quality preset.\n    // This needs to be compiled into the shader as it effects code.\n    // Best option to include multiple presets is to\n    // in each shader define the preset, then include this file.\n    //\n    // OPTIONS\n    // -----------------------------------------------------------------------\n    // 10 to 15 - default medium dither (10=fastest, 15=highest quality)\n    // 20 to 29 - less dither, more expensive (20=fastest, 29=highest quality)\n    // 39       - no dither, very expensive\n    //\n    // NOTES\n    // -----------------------------------------------------------------------\n    // 12 = slightly faster then FXAA 3.9 and higher edge quality (default)\n    // 13 = about same speed as FXAA 3.9 and better than 12\n    // 23 = closest to FXAA 3.9 visually and performance wise\n    //  _ = the lowest digit is directly related to performance\n    // _  = the highest digit is directly related to style\n    //\n    #define FXAA_QUALITY_PRESET 12\n#endif\n\n\n/*============================================================================\n\n                        FXAA QUALITY - PRESETS\n\n============================================================================*/\n\n/*============================================================================\n                    FXAA QUALITY - MEDIUM DITHER PRESETS\n============================================================================*/\n#if (FXAA_QUALITY_PRESET == 10)\n    #define FXAA_QUALITY_PS 3\n    #define FXAA_QUALITY_P0 1.5\n    #define FXAA_QUALITY_P1 3.0\n    #define FXAA_QUALITY_P2 12.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 11)\n    #define FXAA_QUALITY_PS 4\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 3.0\n    #define FXAA_QUALITY_P3 12.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 12)\n    #define FXAA_QUALITY_PS 5\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 4.0\n    #define FXAA_QUALITY_P4 12.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 13)\n    #define FXAA_QUALITY_PS 6\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 4.0\n    #define FXAA_QUALITY_P5 12.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 14)\n    #define FXAA_QUALITY_PS 7\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 4.0\n    #define FXAA_QUALITY_P6 12.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 15)\n    #define FXAA_QUALITY_PS 8\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 4.0\n    #define FXAA_QUALITY_P7 12.0\n#endif\n\n/*============================================================================\n                    FXAA QUALITY - LOW DITHER PRESETS\n============================================================================*/\n#if (FXAA_QUALITY_PRESET == 20)\n    #define FXAA_QUALITY_PS 3\n    #define FXAA_QUALITY_P0 1.5\n    #define FXAA_QUALITY_P1 2.0\n    #define FXAA_QUALITY_P2 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 21)\n    #define FXAA_QUALITY_PS 4\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 22)\n    #define FXAA_QUALITY_PS 5\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 23)\n    #define FXAA_QUALITY_PS 6\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 24)\n    #define FXAA_QUALITY_PS 7\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 3.0\n    #define FXAA_QUALITY_P6 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 25)\n    #define FXAA_QUALITY_PS 8\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 4.0\n    #define FXAA_QUALITY_P7 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 26)\n    #define FXAA_QUALITY_PS 9\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 2.0\n    #define FXAA_QUALITY_P7 4.0\n    #define FXAA_QUALITY_P8 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 27)\n    #define FXAA_QUALITY_PS 10\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 2.0\n    #define FXAA_QUALITY_P7 2.0\n    #define FXAA_QUALITY_P8 4.0\n    #define FXAA_QUALITY_P9 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 28)\n    #define FXAA_QUALITY_PS 11\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 2.0\n    #define FXAA_QUALITY_P7 2.0\n    #define FXAA_QUALITY_P8 2.0\n    #define FXAA_QUALITY_P9 4.0\n    #define FXAA_QUALITY_P10 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 29)\n    #define FXAA_QUALITY_PS 12\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 2.0\n    #define FXAA_QUALITY_P7 2.0\n    #define FXAA_QUALITY_P8 2.0\n    #define FXAA_QUALITY_P9 2.0\n    #define FXAA_QUALITY_P10 4.0\n    #define FXAA_QUALITY_P11 8.0\n#endif\n\n/*============================================================================\n                    FXAA QUALITY - EXTREME QUALITY\n============================================================================*/\n#if (FXAA_QUALITY_PRESET == 39)\n    #define FXAA_QUALITY_PS 12\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.0\n    #define FXAA_QUALITY_P2 1.0\n    #define FXAA_QUALITY_P3 1.0\n    #define FXAA_QUALITY_P4 1.0\n    #define FXAA_QUALITY_P5 1.5\n    #define FXAA_QUALITY_P6 2.0\n    #define FXAA_QUALITY_P7 2.0\n    #define FXAA_QUALITY_P8 2.0\n    #define FXAA_QUALITY_P9 2.0\n    #define FXAA_QUALITY_P10 4.0\n    #define FXAA_QUALITY_P11 8.0\n#endif\n\n\n\n/*============================================================================\n\n                                API PORTING\n\n============================================================================*/\n#if (FXAA_GLSL_100 == 1) || (FXAA_GLSL_120 == 1) || (FXAA_GLSL_130 == 1)\n    #define FxaaBool bool\n    #define FxaaDiscard discard\n    #define FxaaFloat float\n    #define FxaaFloat2 vec2\n    #define FxaaFloat3 vec3\n    #define FxaaFloat4 vec4\n    #define FxaaHalf float\n    #define FxaaHalf2 vec2\n    #define FxaaHalf3 vec3\n    #define FxaaHalf4 vec4\n    #define FxaaInt2 ivec2\n    #define FxaaSat(x) clamp(x, 0.0, 1.0)\n    #define FxaaTex sampler2D\n#else\n    #define FxaaBool bool\n    #define FxaaDiscard clip(-1)\n    #define FxaaFloat float\n    #define FxaaFloat2 float2\n    #define FxaaFloat3 float3\n    #define FxaaFloat4 float4\n    #define FxaaHalf half\n    #define FxaaHalf2 half2\n    #define FxaaHalf3 half3\n    #define FxaaHalf4 half4\n    #define FxaaSat(x) saturate(x)\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_GLSL_100 == 1)\n#define FxaaTexTop(t, p) texture(t, p, 0.0)\n#define FxaaTexOff(t, p, o, r) texture(t, p + (o * r), 0.0)\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_GLSL_120 == 1)\n    // Requires,\n    //  #version 120\n    // And at least,\n    //  #extension GL_EXT_gpu_shader4 : enable\n    //  (or set FXAA_FAST_PIXEL_OFFSET 1 to work like DX9)\n    #define FxaaTexTop(t, p) textureLod(t, p, 0.0)\n    #if (FXAA_FAST_PIXEL_OFFSET == 1)\n        #define FxaaTexOff(t, p, o, r) textureLodOffset(t, p, 0.0, o)\n    #else\n        #define FxaaTexOff(t, p, o, r) textureLod(t, p + (o * r), 0.0)\n    #endif\n    #if (FXAA_GATHER4_ALPHA == 1)\n        // use #extension GL_ARB_gpu_shader5 : enable\n        #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)\n        #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)\n        #define FxaaTexGreen4(t, p) textureGather(t, p, 1)\n        #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)\n    #endif\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_GLSL_130 == 1)\n    #define FxaaTexTop(t, p) textureLod(t, p, 0.0)\n    #define FxaaTexOff(t, p, o, r) textureLodOffset(t, p, 0.0, o)\n    #if (FXAA_GATHER4_ALPHA == 1)\n        // use #extension GL_ARB_gpu_shader5 : enable\n        #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)\n        #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)\n        #define FxaaTexGreen4(t, p) textureGather(t, p, 1)\n        #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)\n    #endif\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_HLSL_3 == 1)\n    #define FxaaInt2 float2\n    #define FxaaTex sampler2D\n    #define FxaaTexTop(t, p) tex2Dlod(t, float4(p, 0.0, 0.0))\n    #define FxaaTexOff(t, p, o, r) tex2Dlod(t, float4(p + (o * r), 0, 0))\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_HLSL_4 == 1)\n    #define FxaaInt2 int2\n    struct FxaaTex { SamplerState smpl; texture tex; };\n    #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)\n    #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_HLSL_5 == 1)\n    #define FxaaInt2 int2\n    struct FxaaTex { SamplerState smpl; texture tex; };\n    #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)\n    #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)\n    #define FxaaTexAlpha4(t, p) t.tex.GatherAlpha(t.smpl, p)\n    #define FxaaTexOffAlpha4(t, p, o) t.tex.GatherAlpha(t.smpl, p, o)\n    #define FxaaTexGreen4(t, p) t.tex.GatherGreen(t.smpl, p)\n    #define FxaaTexOffGreen4(t, p, o) t.tex.GatherGreen(t.smpl, p, o)\n#endif\n\n\n/*============================================================================\n                GREEN AS LUMA OPTION SUPPORT FUNCTION\n============================================================================*/\n#if (FXAA_GREEN_AS_LUMA == 0)\n    FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.w; }\n#else\n    FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.y; }\n#endif\n\n\n\n\n/*============================================================================\n\n                            FXAA3 QUALITY - PC\n\n============================================================================*/\n#if (FXAA_PC == 1)\n/*--------------------------------------------------------------------------*/\nFxaaFloat4 FxaaPixelShader(\n    //\n    // Use noperspective interpolation here (turn off perspective interpolation).\n    // {xy} = center of pixel\n    FxaaFloat2 pos,\n    //\n    // Used only for FXAA Console, and not used on the 360 version.\n    // Use noperspective interpolation here (turn off perspective interpolation).\n    // {xy_} = upper left of pixel\n    // {_zw} = lower right of pixel\n    FxaaFloat4 fxaaConsolePosPos,\n    //\n    // Input color texture.\n    // {rgb_} = color in linear or perceptual color space\n    // if (FXAA_GREEN_AS_LUMA == 0)\n    //     {__a} = luma in perceptual color space (not linear)\n    FxaaTex tex,\n    //\n    // Only used on the optimized 360 version of FXAA Console.\n    // For everything but 360, just use the same input here as for tex.\n    // For 360, same texture, just alias with a 2nd sampler.\n    // This sampler needs to have an exponent bias of -1.\n    FxaaTex fxaaConsole360TexExpBiasNegOne,\n    //\n    // Only used on the optimized 360 version of FXAA Console.\n    // For everything but 360, just use the same input here as for tex.\n    // For 360, same texture, just alias with a 3nd sampler.\n    // This sampler needs to have an exponent bias of -2.\n    FxaaTex fxaaConsole360TexExpBiasNegTwo,\n    //\n    // Only used on FXAA Quality.\n    // This must be from a constant/uniform.\n    // {x_} = 1.0/screenWidthInPixels\n    // {_y} = 1.0/screenHeightInPixels\n    FxaaFloat2 fxaaQualityRcpFrame,\n    //\n    // Only used on FXAA Console.\n    // This must be from a constant/uniform.\n    // This effects sub-pixel AA quality and inversely sharpness.\n    //   Where N ranges between,\n    //     N = 0.50 (default)\n    //     N = 0.33 (sharper)\n    // {x__} = -N/screenWidthInPixels\n    // {_y_} = -N/screenHeightInPixels\n    // {_z_} =  N/screenWidthInPixels\n    // {__w} =  N/screenHeightInPixels\n    FxaaFloat4 fxaaConsoleRcpFrameOpt,\n    //\n    // Only used on FXAA Console.\n    // Not used on 360, but used on PS3 and PC.\n    // This must be from a constant/uniform.\n    // {x__} = -2.0/screenWidthInPixels\n    // {_y_} = -2.0/screenHeightInPixels\n    // {_z_} =  2.0/screenWidthInPixels\n    // {__w} =  2.0/screenHeightInPixels\n    FxaaFloat4 fxaaConsoleRcpFrameOpt2,\n    //\n    // Only used on FXAA Console.\n    // Only used on 360 in place of fxaaConsoleRcpFrameOpt2.\n    // This must be from a constant/uniform.\n    // {x__} =  8.0/screenWidthInPixels\n    // {_y_} =  8.0/screenHeightInPixels\n    // {_z_} = -4.0/screenWidthInPixels\n    // {__w} = -4.0/screenHeightInPixels\n    FxaaFloat4 fxaaConsole360RcpFrameOpt2,\n    //\n    // Only used on FXAA Quality.\n    // This used to be the FXAA_QUALITY_SUBPIX define.\n    // It is here now to allow easier tuning.\n    // Choose the amount of sub-pixel aliasing removal.\n    // This can effect sharpness.\n    //   1.00 - upper limit (softer)\n    //   0.75 - default amount of filtering\n    //   0.50 - lower limit (sharper, less sub-pixel aliasing removal)\n    //   0.25 - almost off\n    //   0.00 - completely off\n    FxaaFloat fxaaQualitySubpix,\n    //\n    // Only used on FXAA Quality.\n    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD define.\n    // It is here now to allow easier tuning.\n    // The minimum amount of local contrast required to apply algorithm.\n    //   0.333 - too little (faster)\n    //   0.250 - low quality\n    //   0.166 - default\n    //   0.125 - high quality\n    //   0.063 - overkill (slower)\n    FxaaFloat fxaaQualityEdgeThreshold,\n    //\n    // Only used on FXAA Quality.\n    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD_MIN define.\n    // It is here now to allow easier tuning.\n    // Trims the algorithm from processing darks.\n    //   0.0833 - upper limit (default, the start of visible unfiltered edges)\n    //   0.0625 - high quality (faster)\n    //   0.0312 - visible limit (slower)\n    // Special notes when using FXAA_GREEN_AS_LUMA,\n    //   Likely want to set this to zero.\n    //   As colors that are mostly not-green\n    //   will appear very dark in the green channel!\n    //   Tune by looking at mostly non-green content,\n    //   then start at zero and increase until aliasing is a problem.\n    FxaaFloat fxaaQualityEdgeThresholdMin,\n    //\n    // Only used on FXAA Console.\n    // This used to be the FXAA_CONSOLE_EDGE_SHARPNESS define.\n    // It is here now to allow easier tuning.\n    // This does not effect PS3, as this needs to be compiled in.\n    //   Use FXAA_CONSOLE_PS3_EDGE_SHARPNESS for PS3.\n    //   Due to the PS3 being ALU bound,\n    //   there are only three safe values here: 2 and 4 and 8.\n    //   These options use the shaders ability to a free *|/ by 2|4|8.\n    // For all other platforms can be a non-power of two.\n    //   8.0 is sharper (default!!!)\n    //   4.0 is softer\n    //   2.0 is really soft (good only for vector graphics inputs)\n    FxaaFloat fxaaConsoleEdgeSharpness,\n    //\n    // Only used on FXAA Console.\n    // This used to be the FXAA_CONSOLE_EDGE_THRESHOLD define.\n    // It is here now to allow easier tuning.\n    // This does not effect PS3, as this needs to be compiled in.\n    //   Use FXAA_CONSOLE_PS3_EDGE_THRESHOLD for PS3.\n    //   Due to the PS3 being ALU bound,\n    //   there are only two safe values here: 1/4 and 1/8.\n    //   These options use the shaders ability to a free *|/ by 2|4|8.\n    // The console setting has a different mapping than the quality setting.\n    // Other platforms can use other values.\n    //   0.125 leaves less aliasing, but is softer (default!!!)\n    //   0.25 leaves more aliasing, and is sharper\n    FxaaFloat fxaaConsoleEdgeThreshold,\n    //\n    // Only used on FXAA Console.\n    // This used to be the FXAA_CONSOLE_EDGE_THRESHOLD_MIN define.\n    // It is here now to allow easier tuning.\n    // Trims the algorithm from processing darks.\n    // The console setting has a different mapping than the quality setting.\n    // This only applies when FXAA_EARLY_EXIT is 1.\n    // This does not apply to PS3,\n    // PS3 was simplified to avoid more shader instructions.\n    //   0.06 - faster but more aliasing in darks\n    //   0.05 - default\n    //   0.04 - slower and less aliasing in darks\n    // Special notes when using FXAA_GREEN_AS_LUMA,\n    //   Likely want to set this to zero.\n    //   As colors that are mostly not-green\n    //   will appear very dark in the green channel!\n    //   Tune by looking at mostly non-green content,\n    //   then start at zero and increase until aliasing is a problem.\n    FxaaFloat fxaaConsoleEdgeThresholdMin,\n    //\n    // Extra constants for 360 FXAA Console only.\n    // Use zeros or anything else for other platforms.\n    // These must be in physical constant registers and NOT immediates.\n    // Immediates will result in compiler un-optimizing.\n    // {xyzw} = float4(1.0, -1.0, 0.25, -0.25)\n    FxaaFloat4 fxaaConsole360ConstDir\n) {\n/*--------------------------------------------------------------------------*/\n    FxaaFloat2 posM;\n    posM.x = pos.x;\n    posM.y = pos.y;\n    #if (FXAA_GATHER4_ALPHA == 1)\n        #if (FXAA_DISCARD == 0)\n            FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);\n            #if (FXAA_GREEN_AS_LUMA == 0)\n                #define lumaM rgbyM.w\n            #else\n                #define lumaM rgbyM.y\n            #endif\n        #endif\n        #if (FXAA_GREEN_AS_LUMA == 0)\n            FxaaFloat4 luma4A = FxaaTexAlpha4(tex, posM);\n            FxaaFloat4 luma4B = FxaaTexOffAlpha4(tex, posM, FxaaInt2(-1, -1));\n        #else\n            FxaaFloat4 luma4A = FxaaTexGreen4(tex, posM);\n            FxaaFloat4 luma4B = FxaaTexOffGreen4(tex, posM, FxaaInt2(-1, -1));\n        #endif\n        #if (FXAA_DISCARD == 1)\n            #define lumaM luma4A.w\n        #endif\n        #define lumaE luma4A.z\n        #define lumaS luma4A.x\n        #define lumaSE luma4A.y\n        #define lumaNW luma4B.w\n        #define lumaN luma4B.z\n        #define lumaW luma4B.x\n    #else\n        FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);\n        #if (FXAA_GREEN_AS_LUMA == 0)\n            #define lumaM rgbyM.w\n        #else\n            #define lumaM rgbyM.y\n        #endif\n        #if (FXAA_GLSL_100 == 1)\n        FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0, 1.0), fxaaQualityRcpFrame.xy));\n        FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 0.0), fxaaQualityRcpFrame.xy));\n        FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0,-1.0), fxaaQualityRcpFrame.xy));\n        FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 0.0), fxaaQualityRcpFrame.xy));\n        #else\n        FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0, 1), fxaaQualityRcpFrame.xy));\n        FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 0), fxaaQualityRcpFrame.xy));\n        FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0,-1), fxaaQualityRcpFrame.xy));\n        FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 0), fxaaQualityRcpFrame.xy));\n        #endif\n    #endif\n/*--------------------------------------------------------------------------*/\n    FxaaFloat maxSM = max(lumaS, lumaM);\n    FxaaFloat minSM = min(lumaS, lumaM);\n    FxaaFloat maxESM = max(lumaE, maxSM);\n    FxaaFloat minESM = min(lumaE, minSM);\n    FxaaFloat maxWN = max(lumaN, lumaW);\n    FxaaFloat minWN = min(lumaN, lumaW);\n    FxaaFloat rangeMax = max(maxWN, maxESM);\n    FxaaFloat rangeMin = min(minWN, minESM);\n    FxaaFloat rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;\n    FxaaFloat range = rangeMax - rangeMin;\n    FxaaFloat rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);\n    FxaaBool earlyExit = range < rangeMaxClamped;\n/*--------------------------------------------------------------------------*/\n    if(earlyExit)\n        #if (FXAA_DISCARD == 1)\n            FxaaDiscard;\n        #else\n            return rgbyM;\n        #endif\n/*--------------------------------------------------------------------------*/\n    #if (FXAA_GATHER4_ALPHA == 0)\n        #if (FXAA_GLSL_100 == 1)\n        FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0,-1.0), fxaaQualityRcpFrame.xy));\n        FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 1.0), fxaaQualityRcpFrame.xy));\n        FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0,-1.0), fxaaQualityRcpFrame.xy));\n        FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 1.0), fxaaQualityRcpFrame.xy));\n        #else\n        FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1,-1), fxaaQualityRcpFrame.xy));\n        FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 1), fxaaQualityRcpFrame.xy));\n        FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1,-1), fxaaQualityRcpFrame.xy));\n        FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));\n        #endif\n    #else\n        FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, -1), fxaaQualityRcpFrame.xy));\n        FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));\n    #endif\n/*--------------------------------------------------------------------------*/\n    FxaaFloat lumaNS = lumaN + lumaS;\n    FxaaFloat lumaWE = lumaW + lumaE;\n    FxaaFloat subpixRcpRange = 1.0/range;\n    FxaaFloat subpixNSWE = lumaNS + lumaWE;\n    FxaaFloat edgeHorz1 = (-2.0 * lumaM) + lumaNS;\n    FxaaFloat edgeVert1 = (-2.0 * lumaM) + lumaWE;\n/*--------------------------------------------------------------------------*/\n    FxaaFloat lumaNESE = lumaNE + lumaSE;\n    FxaaFloat lumaNWNE = lumaNW + lumaNE;\n    FxaaFloat edgeHorz2 = (-2.0 * lumaE) + lumaNESE;\n    FxaaFloat edgeVert2 = (-2.0 * lumaN) + lumaNWNE;\n/*--------------------------------------------------------------------------*/\n    FxaaFloat lumaNWSW = lumaNW + lumaSW;\n    FxaaFloat lumaSWSE = lumaSW + lumaSE;\n    FxaaFloat edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);\n    FxaaFloat edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);\n    FxaaFloat edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;\n    FxaaFloat edgeVert3 = (-2.0 * lumaS) + lumaSWSE;\n    FxaaFloat edgeHorz = abs(edgeHorz3) + edgeHorz4;\n    FxaaFloat edgeVert = abs(edgeVert3) + edgeVert4;\n/*--------------------------------------------------------------------------*/\n    FxaaFloat subpixNWSWNESE = lumaNWSW + lumaNESE;\n    FxaaFloat lengthSign = fxaaQualityRcpFrame.x;\n    FxaaBool horzSpan = edgeHorz >= edgeVert;\n    FxaaFloat subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;\n/*--------------------------------------------------------------------------*/\n    if(!horzSpan) lumaN = lumaW;\n    if(!horzSpan) lumaS = lumaE;\n    if(horzSpan) lengthSign = fxaaQualityRcpFrame.y;\n    FxaaFloat subpixB = (subpixA * (1.0/12.0)) - lumaM;\n/*--------------------------------------------------------------------------*/\n    FxaaFloat gradientN = lumaN - lumaM;\n    FxaaFloat gradientS = lumaS - lumaM;\n    FxaaFloat lumaNN = lumaN + lumaM;\n    FxaaFloat lumaSS = lumaS + lumaM;\n    FxaaBool pairN = abs(gradientN) >= abs(gradientS);\n    FxaaFloat gradient = max(abs(gradientN), abs(gradientS));\n    if(pairN) lengthSign = -lengthSign;\n    FxaaFloat subpixC = FxaaSat(abs(subpixB) * subpixRcpRange);\n/*--------------------------------------------------------------------------*/\n    FxaaFloat2 posB;\n    posB.x = posM.x;\n    posB.y = posM.y;\n    FxaaFloat2 offNP;\n    offNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;\n    offNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;\n    if(!horzSpan) posB.x += lengthSign * 0.5;\n    if( horzSpan) posB.y += lengthSign * 0.5;\n/*--------------------------------------------------------------------------*/\n    FxaaFloat2 posN;\n    posN.x = posB.x - offNP.x * FXAA_QUALITY_P0;\n    posN.y = posB.y - offNP.y * FXAA_QUALITY_P0;\n    FxaaFloat2 posP;\n    posP.x = posB.x + offNP.x * FXAA_QUALITY_P0;\n    posP.y = posB.y + offNP.y * FXAA_QUALITY_P0;\n    FxaaFloat subpixD = ((-2.0)*subpixC) + 3.0;\n    FxaaFloat lumaEndN = FxaaLuma(FxaaTexTop(tex, posN));\n    FxaaFloat subpixE = subpixC * subpixC;\n    FxaaFloat lumaEndP = FxaaLuma(FxaaTexTop(tex, posP));\n/*--------------------------------------------------------------------------*/\n    if(!pairN) lumaNN = lumaSS;\n    FxaaFloat gradientScaled = gradient * 1.0/4.0;\n    FxaaFloat lumaMM = lumaM - lumaNN * 0.5;\n    FxaaFloat subpixF = subpixD * subpixE;\n    FxaaBool lumaMLTZero = lumaMM < 0.0;\n/*--------------------------------------------------------------------------*/\n    lumaEndN -= lumaNN * 0.5;\n    lumaEndP -= lumaNN * 0.5;\n    FxaaBool doneN = abs(lumaEndN) >= gradientScaled;\n    FxaaBool doneP = abs(lumaEndP) >= gradientScaled;\n    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P1;\n    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P1;\n    FxaaBool doneNP = (!doneN) || (!doneP);\n    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P1;\n    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P1;\n/*--------------------------------------------------------------------------*/\n    if(doneNP) {\n        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n        doneN = abs(lumaEndN) >= gradientScaled;\n        doneP = abs(lumaEndP) >= gradientScaled;\n        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P2;\n        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P2;\n        doneNP = (!doneN) || (!doneP);\n        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P2;\n        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P2;\n/*--------------------------------------------------------------------------*/\n        #if (FXAA_QUALITY_PS > 3)\n        if(doneNP) {\n            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n            doneN = abs(lumaEndN) >= gradientScaled;\n            doneP = abs(lumaEndP) >= gradientScaled;\n            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P3;\n            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P3;\n            doneNP = (!doneN) || (!doneP);\n            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P3;\n            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P3;\n/*--------------------------------------------------------------------------*/\n            #if (FXAA_QUALITY_PS > 4)\n            if(doneNP) {\n                if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                doneN = abs(lumaEndN) >= gradientScaled;\n                doneP = abs(lumaEndP) >= gradientScaled;\n                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P4;\n                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P4;\n                doneNP = (!doneN) || (!doneP);\n                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P4;\n                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P4;\n/*--------------------------------------------------------------------------*/\n                #if (FXAA_QUALITY_PS > 5)\n                if(doneNP) {\n                    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                    doneN = abs(lumaEndN) >= gradientScaled;\n                    doneP = abs(lumaEndP) >= gradientScaled;\n                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P5;\n                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P5;\n                    doneNP = (!doneN) || (!doneP);\n                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P5;\n                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P5;\n/*--------------------------------------------------------------------------*/\n                    #if (FXAA_QUALITY_PS > 6)\n                    if(doneNP) {\n                        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                        doneN = abs(lumaEndN) >= gradientScaled;\n                        doneP = abs(lumaEndP) >= gradientScaled;\n                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P6;\n                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P6;\n                        doneNP = (!doneN) || (!doneP);\n                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P6;\n                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P6;\n/*--------------------------------------------------------------------------*/\n                        #if (FXAA_QUALITY_PS > 7)\n                        if(doneNP) {\n                            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                            doneN = abs(lumaEndN) >= gradientScaled;\n                            doneP = abs(lumaEndP) >= gradientScaled;\n                            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P7;\n                            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P7;\n                            doneNP = (!doneN) || (!doneP);\n                            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P7;\n                            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P7;\n/*--------------------------------------------------------------------------*/\n    #if (FXAA_QUALITY_PS > 8)\n    if(doneNP) {\n        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n        doneN = abs(lumaEndN) >= gradientScaled;\n        doneP = abs(lumaEndP) >= gradientScaled;\n        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P8;\n        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P8;\n        doneNP = (!doneN) || (!doneP);\n        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P8;\n        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P8;\n/*--------------------------------------------------------------------------*/\n        #if (FXAA_QUALITY_PS > 9)\n        if(doneNP) {\n            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n            doneN = abs(lumaEndN) >= gradientScaled;\n            doneP = abs(lumaEndP) >= gradientScaled;\n            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P9;\n            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P9;\n            doneNP = (!doneN) || (!doneP);\n            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P9;\n            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P9;\n/*--------------------------------------------------------------------------*/\n            #if (FXAA_QUALITY_PS > 10)\n            if(doneNP) {\n                if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                doneN = abs(lumaEndN) >= gradientScaled;\n                doneP = abs(lumaEndP) >= gradientScaled;\n                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P10;\n                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P10;\n                doneNP = (!doneN) || (!doneP);\n                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P10;\n                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P10;\n/*--------------------------------------------------------------------------*/\n                #if (FXAA_QUALITY_PS > 11)\n                if(doneNP) {\n                    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                    doneN = abs(lumaEndN) >= gradientScaled;\n                    doneP = abs(lumaEndP) >= gradientScaled;\n                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P11;\n                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P11;\n                    doneNP = (!doneN) || (!doneP);\n                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P11;\n                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P11;\n/*--------------------------------------------------------------------------*/\n                    #if (FXAA_QUALITY_PS > 12)\n                    if(doneNP) {\n                        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                        doneN = abs(lumaEndN) >= gradientScaled;\n                        doneP = abs(lumaEndP) >= gradientScaled;\n                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P12;\n                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P12;\n                        doneNP = (!doneN) || (!doneP);\n                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P12;\n                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P12;\n/*--------------------------------------------------------------------------*/\n                    }\n                    #endif\n/*--------------------------------------------------------------------------*/\n                }\n                #endif\n/*--------------------------------------------------------------------------*/\n            }\n            #endif\n/*--------------------------------------------------------------------------*/\n        }\n        #endif\n/*--------------------------------------------------------------------------*/\n    }\n    #endif\n/*--------------------------------------------------------------------------*/\n                        }\n                        #endif\n/*--------------------------------------------------------------------------*/\n                    }\n                    #endif\n/*--------------------------------------------------------------------------*/\n                }\n                #endif\n/*--------------------------------------------------------------------------*/\n            }\n            #endif\n/*--------------------------------------------------------------------------*/\n        }\n        #endif\n/*--------------------------------------------------------------------------*/\n    }\n/*--------------------------------------------------------------------------*/\n    FxaaFloat dstN = posM.x - posN.x;\n    FxaaFloat dstP = posP.x - posM.x;\n    if(!horzSpan) dstN = posM.y - posN.y;\n    if(!horzSpan) dstP = posP.y - posM.y;\n/*--------------------------------------------------------------------------*/\n    FxaaBool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;\n    FxaaFloat spanLength = (dstP + dstN);\n    FxaaBool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;\n    FxaaFloat spanLengthRcp = 1.0/spanLength;\n/*--------------------------------------------------------------------------*/\n    FxaaBool directionN = dstN < dstP;\n    FxaaFloat dst = min(dstN, dstP);\n    FxaaBool goodSpan = directionN ? goodSpanN : goodSpanP;\n    FxaaFloat subpixG = subpixF * subpixF;\n    FxaaFloat pixelOffset = (dst * (-spanLengthRcp)) + 0.5;\n    FxaaFloat subpixH = subpixG * fxaaQualitySubpix;\n/*--------------------------------------------------------------------------*/\n    FxaaFloat pixelOffsetGood = goodSpan ? pixelOffset : 0.0;\n    FxaaFloat pixelOffsetSubpix = max(pixelOffsetGood, subpixH);\n    if(!horzSpan) posM.x += pixelOffsetSubpix * lengthSign;\n    if( horzSpan) posM.y += pixelOffsetSubpix * lengthSign;\n    #if (FXAA_DISCARD == 1)\n        return FxaaTexTop(tex, posM);\n    #else\n        return FxaaFloat4(FxaaTexTop(tex, posM).xyz, lumaM);\n    #endif\n}\n/*==========================================================================*/\n#endif\n\nvoid main() {\nout_color = FxaaPixelShader(\n    vCoord,\n    vec4(0.0),\n    inputBuffer,\n    inputBuffer,\n    inputBuffer,\n    resolution,\n    vec4(0.0),\n    vec4(0.0),\n    vec4(0.0),\n    0.75,\n    0.166,\n    0.0833,\n    0.0,\n    0.0,\n    0.0,\n    vec4(0.0)\n);\n\nout_color.a = texture(inputBuffer, vCoord).a;\n}"};this.renderPass=new ft(e,a),this.fullscreenTriangle=n}setSize(t,e){this.renderPass.setUniform("resolution",1/t,1/e)}draw(t){let{light:e}=t;this.renderPass.setTexture("inputBuffer",e),this.renderPass.useProgram(),this.fullscreenTriangle.draw()}dispose(){this.renderPass.dispose()}}function Le(t,e,n){if(void 0===e)return;const{itemSize:a,array:i}=n;if(t.enableVertexAttribArray(e),t.bindBuffer(t.ARRAY_BUFFER,t.createBuffer()),t.bufferData(t.ARRAY_BUFFER,i,t.STATIC_DRAW),i instanceof Float32Array)t.vertexAttribPointer(e,a,t.FLOAT,!1,0,0);else{if(!(i instanceof Int32Array))throw"Unsupported buffer type";t.vertexAttribIPointer(e,a,t.INT,0,0)}}function Fe(t,e,n,a){Le(t,e.attribLocs.aPosition,n.position),Le(t,e.attribLocs.aNormal,n.normal),Le(t,e.attribLocs.aUv,n.uv),"Static"==a&&n.materialMeshIndex&&Le(t,e.attribLocs.aMaterialMeshIndex,n.materialMeshIndex),t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,t.createBuffer()),t.bufferData(t.ELEMENT_ARRAY_BUFFER,n.indices.array,t.STATIC_DRAW)}class Pe{constructor(t,e,n){this.gl=t,this.resourcePool=n,this.vaos=[],this.fullscreenTriangle=e,this.meshNormalMat=new T}createPipeline(t,e){this.renderSetting=t,this.sceneInfo=e;const{materialDefines:n,sceneMode:a,bvhDefines:i}=t,{gl:s,resourcePool:r}=this,o=new ft(s,{defines:{SUPPORT_UV_TRANS:t.supportUVTrans,...i,...n},vertex:"in vec3 aPosition;\nin vec3 aNormal;\nin vec2 aUv;\n// For batch mesh\n#ifndef BVH_DYNAMIC\n\tin ivec2 aMaterialMeshIndex;\n\t// Each primitive can only have one material index\n\tflat out ivec2 vMaterialMeshIndex;\n#endif\n\nuniform mat4 projView;\n#ifdef BVH_DYNAMIC\n\tuniform mat4 modelMat;\n\tuniform mat3 normalMat;\n#endif\n\nout vec3 vPosition;\nout vec3 vNormal;\nout vec2 vUv;\n\nvoid main() {\n\t#ifdef BVH_DYNAMIC\n\t\tvec4 mPosition = modelMat * vec4(aPosition, 1.);\n\t\t// World space\n\t\tvPosition = mPosition.xyz;\n\t\tvNormal = normalize(normalMat * aNormal);\n\t\tvUv = aUv;\n\t\tgl_Position = projView * mPosition;\n\t#else\n\t\tvPosition = aPosition;\n\t\tvNormal = aNormal;\n\t\tvUv = aUv;\n\t\tvMaterialMeshIndex = aMaterialMeshIndex;\n\t\tgl_Position = projView * vec4(aPosition, 1);\n\t#endif\n}\n",fragment:"\n#define PI 3.14159265359\n#define TWOPI 6.28318530718\n#define INVPI 0.31830988618\n#define INVPI2 0.10132118364\n\n#define EPS 0.0001\n#define ONE_MINUS_EPS 0.999999\n#define INF 1000000.0\n// Mobile sync\n// #define INTERSECT_EPS 1.0e-2\n// #define ROUGHNESS_MIN 0.03 // Blender\n#define ROUGHNESS_MIN 0.001 // PBRT\n// #define ROUGHNESS_MIN 0.01\n\n// Material type\n#define DISNEY 0\n// https://www.w3.org/WAI/GL/wiki/Relative_luminance\nconst vec3 luminance = vec3(0.2126, 0.7152, 0.0722);\nfloat Luminance(vec3 color) { return dot(color, luminance); }\n#define RAY_MAX_DISTANCE 9999.0\n\nstruct Ray {\n\tvec3 o;\n\tvec3 d;\n};\n\nstruct Path {\n\tRay ray;\n\tvec3 li;\n\tfloat alpha;\n\tvec3 beta;\n\tbool abort;\n\tfloat misWeight;\n\n\tvec3 absorption;\n};\n\nstruct Camera {\n\tmat4 viewToWorldMat;\n\tmat4 clipToViewMat;\n\tfloat aperture;\n\tfloat focus;\n};\n\n#if defined(NUM_LIGHTS)\nstruct Lights {\n\tvec3 position[NUM_LIGHTS];\n\tvec3 emission[NUM_LIGHTS];\n\tvec3 p1[NUM_LIGHTS];\n\tvec3 p2[NUM_LIGHTS];\n\tvec4 params[NUM_LIGHTS];\n};\n\nstruct Light {\n\tvec3 position;\n\tfloat radius;\n\tvec3 emission;\n\tfloat area;\n\tvec3 p1; // param1: u, target\n\tfloat type;\n\tvec3 p2; // param2: v\n\tfloat visible;\n};\n#endif\n\nstruct SurfaceInteraction {\n\tbool hit;\n\tbool isEmitter;\n\tfloat t;\n\tvec3 position;\n\tvec3 normal;\n\tvec3 ffnormal;\n\tfloat eta;\n\n\t// Material\n\tvec3 color;\n\tfloat workflow;\n\t\n\tfloat roughness;\n\tfloat metalness;\n\tfloat transmission;\n\tfloat ior;\n\t\n\tfloat sheen;\n\tfloat sheenTint;\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n\t\n\tvec3 emissive;\n\tfloat alpha;\n\t\n\tfloat specularTint;\n\tfloat atDistance;\n\n\n\tvec3 specularColor;\n\tfloat subsurface;\n\n\tvec3 extinction;\n};\n\nstruct BsdfSampleRec {\n\tvec3 L;\n\tvec3 f;\n\tfloat pdf;\n};\n\nstruct LightSampleRec{\n\tvec3 normal;\n\tvec3 emission;\n\tvec3 direction;\n\tfloat dist;\n\tfloat pdf;\n};\n\n// given the index from a 1D array, retrieve corresponding position from packed 2D texture\nivec2 unpackTexel(int i, int columnsLog2) {\n\tivec2 u;\n\tu.y = i >> columnsLog2; // equivalent to (i / 2^columnsLog2)\n\tu.x = i - (u.y << columnsLog2); // equivalent to (i % 2^columnsLog2)\n\treturn u;\n}\nvec4 fetchData(sampler2D s, int i, int columnsLog2) {\n\treturn texelFetch(s, unpackTexel(i, columnsLog2), 0);\n}\nivec4 fetchData(isampler2D s, int i, int columnsLog2) {\n\treturn texelFetch(s, unpackTexel(i, columnsLog2), 0);\n}\n\nuniform Camera camera;\nuniform vec2 pixelSize; // 1 / screenResolution\nuniform vec2 jitter;\nuniform float frameCount;\nuniform sampler2D accumulateTex;\n\nin vec2 vCoord;\n\n#if defined(NUM_LIGHTS)\nuniform Lights lights;\n#endif\n\nuniform int bounces;\nuniform vec3 backgroundColor;\nuniform float envMapIntensity;\nuniform float backgroundAlpha;\nuniform float enviromentVisible;\n\nuniform int useBackgroundColor;\nuniform mat3 envRotMatrix;\nuniform mat3 invEnvRotMatrix;\n\nvec3 ndcToWorld(vec2 coord) {\n\tvec4 worldPos = camera.viewToWorldMat * camera.clipToViewMat * vec4(coord, -1.0, 1.0);\n\treturn worldPos.xyz / worldPos.w;\n}\nvec3 localToWorld(vec3 X, vec3 Y, vec3 Z, vec3 V) {\n    return vec3(\n        X.x * V.x + Y.x * V.y + Z.x * V.z,\n        X.y * V.x + Y.y * V.y + Z.y * V.z,\n        X.z * V.x + Y.z * V.y + Z.z * V.z\n    );\n}\nvec3 worldToLocal(vec3 X, vec3 Y, vec3 Z, vec3 V) {\n    return vec3(dot(V, X), dot(V, Y), dot(V, Z));\n}\n\n// UBO-1\n#ifdef NUM_MATERIALS\nuniform Materials {\n\tvec4 colorWorkflow[NUM_MATERIALS];\n\tvec4 roughMetalTransIOR[NUM_MATERIALS];\n\tvec4 sheenTintClearcoatRoughness[NUM_MATERIALS];\n\tvec4 emissiveAlpha[NUM_MATERIALS];\n\tvec4 specularTintAtDistanceNormalScale[NUM_MATERIALS];\n\tvec4 subsurfaceAndColor[NUM_MATERIALS];\n\tvec4 extinctionSubsurfaceMFP[NUM_MATERIALS];\n\tvec4 specularColorGlossiness[NUM_MATERIALS];\n\n\tivec4 diffuseNormalRoughnessMetalnessMapIndex[NUM_MATERIALS];\n\tivec4 emissiveSpecularGlossinessMapIndex[NUM_MATERIALS];\n\n} materials;\n#endif\n\nuniform mediump sampler2DArray materialTexArray;\nvec3 srgbToLinear(vec3 srgb) { return pow(srgb, vec3(2.2)); }\n\n#if defined(SUPPORT_UV_TRANS) || defined(SUPPORT_TEX_WRAP)\n\tuniform sampler2D uvTransBuffer;\n\t#define UV_TRANS_MAPS_LEN 7\n#endif\n\n#ifdef SUPPORT_UV_TRANS\n\tmat3 getMatUVTransform(int materialID, int mapKey) {\n\t\tint offset = materialID * UV_TRANS_MAPS_LEN * 3;\n\t\tint mapOffset = mapKey * 3;\n\t\tvec3 matRow1 = fetchData(uvTransBuffer, offset + mapOffset + 0, UV_TRANS_COLUMNS).xyz;\n\t\tvec3 matRow2 = fetchData(uvTransBuffer, offset + mapOffset + 1, UV_TRANS_COLUMNS).xyz;\n\t\tvec3 matRow3 = fetchData(uvTransBuffer, offset + mapOffset + 2, UV_TRANS_COLUMNS).xyz;\n\t\tmat3 uvTransMat = mat3(matRow1, matRow2, matRow3);\n\t\treturn uvTransMat;\n\t}\n#endif\n#ifdef SUPPORT_TEX_WRAP\n\tvec3 getMatWrapping(int materialID, int mapKey) {\n\t\tint offset = TEX_WRAP_DATA_INDEX + materialID * UV_TRANS_MAPS_LEN;\n\t\tint mapOffset = mapKey;\n\t\tvec3 wrappingData = fetchData(uvTransBuffer, offset + mapOffset, UV_TRANS_COLUMNS).xyz;\n\t\treturn wrappingData;\n\t}\n\tvec2 applyTextureWrapping(vec2 uv, vec3 warpping) {\n\t\tif (uv.x <= 0. || uv.x >= 1.) {\n\t\t\tint warpS = int(warpping.x);\n\t\t\tif (warpS == 1) {\n\t\t\t\t// ClampToEdgeWrapping\n\t\t\t\tuv.x = uv.x <= 0. ? 0. : 1.;\n\t\t\t} else if (warpS == 2) {\n\t\t\t\t// MirroredRepeatWrapping\n            \tuv.x = 1.0 - abs(fract(uv.x * 0.5) * 2.0 - 1.0);\n\t\t\t} else {\n\t\t\t\t// RepeatWrapping\n\t\t\t\tuv.x = fract(uv.x);\n\t\t\t}\n\t\t}\n\t\tif (uv.y <= 0. || uv.y >= 1.) {\n\t\t\tint warpT = int(warpping.y);\n\t\t\tif (warpT == 1) {\n\t\t\t\tuv.y = uv.y <= 0. ? 0. : 1.;\n\t\t\t} else if (warpT == 2) {\n\t\t\t\tuv.y = 1.0 - abs(fract(uv.y * 0.5) * 2.0 - 1.0);\n\t\t\t} else {\n\t\t\t\tuv.y = fract(uv.y);\n\t\t\t}\n\t\t}\n\n\t\treturn uv;\n\t}\n#endif\n\n#ifdef SUPPORT_SG_WORKFLOW\n\tfloat max3(const vec3 v) { return max(v.x, max(v.y, v.z)); }\n\tfloat computeMetallicFromSpecularColor(const vec3 specularColor) { return max3(specularColor); }\n\tvec3 computeDiffuseColor(const vec3 baseColor, float metallic) { return baseColor * (1.0 - metallic); }\n\n\tvec3 getMatSpecularColor(int materialID, vec2 uv) {\n\t\tvec3 specularColor = materials.specularColorGlossiness[materialID].rgb;\n\t\tint specularMapIndex = materials.emissiveSpecularGlossinessMapIndex[materialID].y;\n\t\tif (specularMapIndex > -1) {\n\n\t#ifdef SUPPORT_UV_TRANS\n\t\tmat3 uvTransMat = getMatUVTransform(materialID, 4);\n\t\tuv = (uvTransMat * vec3(uv, 1)).xy;\n\t#endif\n\t#ifdef SUPPORT_TEX_WRAP\n\t\tvec3 warpping = getMatWrapping(materialID, 4);\n\t\tuv = applyTextureWrapping(uv, warpping);\n\t#endif\n\n\t\t\tvec3 texelSpecular = srgbToLinear(texture(materialTexArray, vec3(uv, specularMapIndex)).rgb);\n\t\t\tspecularColor *= texelSpecular;\n\t\t}\n\n\t\treturn specularColor;\n\t}\n\n\tfloat getMatGlossiness(int materialID, vec2 uv) {\n\t\tfloat glossiness = materials.specularColorGlossiness[materialID].a;\n\t\tint glossinessMapIndex = materials.emissiveSpecularGlossinessMapIndex[materialID].z;\n\t\tif (glossinessMapIndex > -1) {\n\n\t\t#ifdef SUPPORT_UV_TRANS\n\t\t\tmat3 uvTransMat = getMatUVTransform(materialID, 5);\n\t\t\tuv = (uvTransMat * vec3(uv, 1)).xy;\n\t\t#endif\n\t\t#ifdef SUPPORT_TEX_WRAP\n\t\t\tvec3 warpping = getMatWrapping(materialID, 5);\n\t\t\tuv = applyTextureWrapping(uv, warpping);\n\t\t#endif\n\n\t\t\tfloat texelGlossiness = texture(materialTexArray, vec3(uv, glossinessMapIndex)).a;\n\t\t\tglossiness *= texelGlossiness;\n\t\t}\n\t\treturn glossiness;\n\t}\n#endif\n\nvec4 getMatColorAlpha(int materialID, vec2 uv) {\n\tvec3 color = materials.colorWorkflow[materialID].rgb;\n\tfloat alpha =  materials.emissiveAlpha[materialID].a;\n\n\tint diffuseMapIndex = materials.diffuseNormalRoughnessMetalnessMapIndex[materialID].x;\n\tif (diffuseMapIndex > -1) {\n\t\t\n\t#ifdef SUPPORT_UV_TRANS\n\t\tmat3 uvTransMat = getMatUVTransform(materialID, 0);\n\t\tuv = (uvTransMat * vec3(uv, 1)).xy;\n\t#endif\n\t#ifdef SUPPORT_TEX_WRAP\n\t\tvec3 warpping = getMatWrapping(materialID, 0);\n\t\tuv = applyTextureWrapping(uv, warpping);\n\t#endif\n\n\t\tvec4 texData = texture(materialTexArray, vec3(uv, diffuseMapIndex));\n\t\tcolor *= srgbToLinear(texData.rgb);\n\t\talpha *= texData.a;\n\t}\n\n#ifdef SUPPORT_SG_WORKFLOW\n\tfloat workflow = materials.colorWorkflow[materialID].w;\n\tif (workflow > 0.1) {\n\t\tvec3 specularFactor = getMatSpecularColor(materialID, uv);\n\t\tcolor = computeDiffuseColor(color, computeMetallicFromSpecularColor(specularFactor));\n\t}\n#endif\n\n\treturn vec4(color, alpha);\n}\n\nfloat getMatRoughness(int materialID, vec2 uv) {\n\tfloat workflow = materials.colorWorkflow[materialID].w;\n\tfloat roughness = 0.0;\n\n#ifdef SUPPORT_SG_WORKFLOW\n\tif (workflow > 0.1) {\n\t\troughness = 1.0 - getMatGlossiness(materialID, uv);\n\t} else \n#endif\n\n\t{\n\t\troughness = materials.roughMetalTransIOR[materialID].x;\n\n\t\tint roughnessMapIndex = materials.diffuseNormalRoughnessMetalnessMapIndex[materialID].z;\n\t\tif (roughnessMapIndex > -1) {\n\t\t\n\t\t#ifdef SUPPORT_UV_TRANS\n\t\t\tmat3 uvTransMat = getMatUVTransform(materialID, 2);\n\t\t\tuv = (uvTransMat * vec3(uv, 1)).xy;\n\t\t#endif\n\t\t#ifdef SUPPORT_TEX_WRAP\n\t\t\tvec3 warpping = getMatWrapping(materialID, 2);\n\t\t\tuv = applyTextureWrapping(uv, warpping);\n\t\t#endif\n\n\t\t\troughness *= texture(materialTexArray, vec3(uv, roughnessMapIndex)).g;\n\t\t}\n\t}\n\t// Remap\n\treturn roughness * roughness;\n}\n\nfloat getMatMetalness(int materialID, vec2 uv) {\n\tfloat workflow = materials.colorWorkflow[materialID].w;\n\tfloat metalness = 0.0;\n\n#ifdef SUPPORT_SG_WORKFLOW\n\tif (workflow > 0.1) {\n\t\tvec3 specularFactor = getMatSpecularColor(materialID, uv);\n\t\tmetalness = computeMetallicFromSpecularColor(specularFactor);\n\t} else \n#endif\n\n\t{\n\t\tmetalness = materials.roughMetalTransIOR[materialID].y;\n\n\t\tint metalnessMapIndex = materials.diffuseNormalRoughnessMetalnessMapIndex[materialID].w;\n\t\tif (metalnessMapIndex > -1) {\n\n\t\t#ifdef SUPPORT_UV_TRANS\n\t\t\tmat3 uvTransMat = getMatUVTransform(materialID, 3);\n\t\t\tuv = (uvTransMat * vec3(uv, 1)).xy;\n\t\t#endif\n\t\t#ifdef SUPPORT_TEX_WRAP\n\t\t\tvec3 warpping = getMatWrapping(materialID, 3);\n\t\t\tuv = applyTextureWrapping(uv, warpping);\n\t\t#endif\n\n\t\t\tmetalness *= texture(materialTexArray, vec3(uv, metalnessMapIndex)).b;\n\t\t}\n\t}\n\n\treturn metalness;\n}\n\nvec3 getMatEmissive(int materialID, vec2 uv) {\n\tvec3 emissive = materials.emissiveAlpha[materialID].xyz;\n\n\tint emissiveMapIndex = materials.emissiveSpecularGlossinessMapIndex[materialID].x;\n\tif (emissiveMapIndex > -1) {\n\n\t#ifdef SUPPORT_UV_TRANS\n\t\tmat3 uvTransMat = getMatUVTransform(materialID, 6);\n\t\tuv = (uvTransMat * vec3(uv, 1)).xy;\n\t#endif\n\t#ifdef SUPPORT_TEX_WRAP\n\t\tvec3 warpping = getMatWrapping(materialID, 6);\n\t\tuv = applyTextureWrapping(uv, warpping);\n\t#endif\n\n\t\temissive *= srgbToLinear(texture(materialTexArray, vec3(uv, emissiveMapIndex)).rgb);\n\t}\n\t\n\treturn emissive;\n}\n\nvec3 getMatNormal(int materialID, vec2 uv, vec3 normal, vec3 dp1, vec3 dp2, vec2 duv1, vec2 duv2) {\n\t// http://www.thetenthplanet.de/archives/1180\n\t// Compute co-tangent and co-bitangent vectors\n\tvec3 dp2perp = cross(dp2, normal);\n\tvec3 dp1perp = cross(normal, dp1);\n\tvec3 dpdu = dp2perp * duv1.x + dp1perp * duv2.x;\n\tvec3 dpdv = dp2perp * duv1.y + dp1perp * duv2.y;\n\tfloat invmax = inversesqrt(max(dot(dpdu, dpdu), dot(dpdv, dpdv)));\n\tdpdu *= invmax;\n\tdpdv *= invmax;\n\n\t// All world space\n\tint normalMapIndex = materials.diffuseNormalRoughnessMetalnessMapIndex[materialID].y;\n\tif (normalMapIndex > -1) {\n\t\t\n\t#ifdef SUPPORT_UV_TRANS\n\t\tmat3 uvTransMat = getMatUVTransform(materialID, 1);\n\t\tuv = (uvTransMat * vec3(uv, 1)).xy;\n\t#endif\n\t#ifdef SUPPORT_TEX_WRAP\n\t\tvec3 warpping = getMatWrapping(materialID, 1);\n\t\tuv = applyTextureWrapping(uv, warpping);\n\t#endif\n\n\t\tvec3 n = 2.0 * texture(materialTexArray, vec3(uv, normalMapIndex)).rgb - 1.0;\n\t\tn.xy *= materials.specularTintAtDistanceNormalScale[materialID].zw;\n\n\t\tmat3 tbn = mat3(dpdu, dpdv, normal);\n\n\t\treturn normalize(tbn * n);\n\t} else {\n\t\treturn normal;\n\t}\n\n\treturn normal;\n}\n\n\n// specularTintAtDistanceNormalScale\nfloat getMatSpecularTint(int materialID) {\n\treturn materials.specularTintAtDistanceNormalScale[materialID].x;\n}\nfloat getMatAtDistance(int materialID) {\n\treturn materials.specularTintAtDistanceNormalScale[materialID].y;\n}\n\n// subsurfaceAndColor\nfloat getMatSubface(int materialID) {\n\treturn materials.subsurfaceAndColor[materialID].x;\n}\nvec3 getMatSubfaceColor(int materialID) {\n\treturn materials.subsurfaceAndColor[materialID].yzw;\n}\n\n// extinctionSubsurfaceMFP\nvec3 getMatExtinction(int materialID) {\n\treturn materials.extinctionSubsurfaceMFP[materialID].rgb;\n}\nfloat getMatSubsurfaceMFP(int materialID) {\n\treturn materials.extinctionSubsurfaceMFP[materialID].a;\n}\n\nfloat getMatCastShadow(int materialID) {\n\tfloat workflow = materials.colorWorkflow[materialID].w;\n\tfloat castShadow = 0.0;\n\t\n\tif (workflow > 0.1) {\n\t\tcastShadow = materials.roughMetalTransIOR[materialID].x;\n\t} else {\n\t\tcastShadow = materials.specularColorGlossiness[materialID].a;\n\t}\n\n\treturn castShadow;\n}\n\nlayout(location = 0) out vec4 out_position;\nlayout(location = 1) out vec4 out_normal;\nlayout(location = 2) out vec4 out_color;\n\nin vec3 vPosition;\nin vec3 vNormal;\nin vec2 vUv;\n\n#ifdef BVH_DYNAMIC\n\tuniform int meshIndex;\n\tuniform int materialID;\n#else\n\tflat in ivec2 vMaterialMeshIndex;\n#endif\n\nvec3 faceNormals(vec3 pos) {\n\tvec3 fdx = dFdx(pos);\n\tvec3 fdy = dFdy(pos);\n\treturn cross(fdx, fdy);\n}\n\nvoid main() {\n\n#ifndef BVH_DYNAMIC\n\tint materialID = vMaterialMeshIndex.x;\n\tint meshIndex = vMaterialMeshIndex.y;\n#endif\n\n\tvec2 uv = vUv;\n\n\tvec3 color = getMatColorAlpha(materialID, uv).rgb;\n\tvec3 normal = normalize(vNormal);\n\tvec3 faceNormal = normalize(faceNormals(vPosition));\n\tnormal *= sign(dot(normal, faceNormal));\n\n\tint normalMapIndex = materials.diffuseNormalRoughnessMetalnessMapIndex[materialID].y;\n\tif (normalMapIndex >= 0) {\n\t\tvec3 dp1 = dFdx(vPosition);\n\t\tvec3 dp2 = dFdy(vPosition);\n\t\tvec2 duv1 = dFdx(vUv);\n\t\tvec2 duv2 = dFdy(vUv);\n\t\tnormal = getMatNormal(materialID, uv, normal, dp1, dp2, duv1, duv2);\n\t}\n\n\tout_position = vec4(vPosition, float(meshIndex) + EPS);\n\tout_normal = vec4(normal, 0);\n\tout_color = vec4(color, 0.);\n}"}),l="Static"==this.renderSetting.sceneMode?[e.mergedMesh]:e.meshes;this.meshes=l,this.renderPass=o,o.setTexture("materialTexArr",r.getRawResourceByName("MaterialTextureArray")),(t.supportUVTrans||t.supportTexWrap)&&o.setTexture("uvTransBuffer",r.getRawResourceByName("TextureUVTransformBuffer")),this.vaos=[];for(let c=0;c<l.length;c++){const t=l[c].geometry,e=s.createVertexArray();s.bindVertexArray(e),Fe(s,o,t,a),s.bindVertexArray(null),this.vaos.push(e)}this.projView=new m}setCamera(t){this.currentCamera=t}calcCamera(){const{projView:t,currentCamera:e,renderPass:n}=this;t.copy(e.viewToClipMat),t.multiply(e.worldToViewMat),n.setUniform("projView",t)}draw(){const{gl:t,renderSetting:e,renderPass:n,vaos:a,meshes:i}=this,{materialIndexMap:s}=this.sceneInfo;this.calcCamera(),t.enable(t.DEPTH_TEST),t.disable(t.CULL_FACE);for(let r=0;r<i.length;r++){const o=i[r];if(0==o.visible)continue;const l=o.geometry,c=l.indices.array,u=l.indices.count;if("Dynamic"==e.sceneMode){const t=o;n.setUniform("modelMat",t.localToWorldMat),this.meshNormalMat.getNormalMatrix(t.localToWorldMat),n.setUniform("normalMat",this.meshNormalMat),n.setUniform("meshIndex",r);const e=s.get(t.material);n.setUniform("materialID",e)}const d=a[r];t.bindVertexArray(d),n.useProgram(),c instanceof Uint16Array?t.drawElements(t.TRIANGLES,u,t.UNSIGNED_SHORT,0):c instanceof Uint32Array&&t.drawElements(t.TRIANGLES,u,t.UNSIGNED_INT,0)}t.enable(t.CULL_FACE),t.disable(t.DEPTH_TEST)}dispose(){this.renderPass.dispose()}}class Re{constructor(t,e){this.gl=t,this.level=3,this.colorFactor=o,this.normalFactor=l,this.positionFactor=c,this.fullscreenTriangle=e}createPipeline(t){const{gl:e,fullscreenTriangle:n}=this,a={gl:e,vertex:n.vertexShader,fragment:"\nvec4 textureLinear(sampler2D map, vec2 uv) {\n\t#ifdef EXT_FLOAT_LINEAR\n\t\treturn texture(map, uv);\n\t#else\n\t\tvec2 size = vec2(textureSize(map, 0));\n\t\tvec2 texelSize = 1.0 / size;\n\n\t\tuv = uv * size - 0.5;\n\t\tvec2 f = fract(uv);\n\t\tuv = floor(uv) + 0.5;\n\n\t\tvec4 s1 = texture(map, (uv + vec2(0, 0)) * texelSize);\n\t\tvec4 s2 = texture(map, (uv + vec2(1, 0)) * texelSize);\n\t\tvec4 s3 = texture(map, (uv + vec2(0, 1)) * texelSize);\n\t\tvec4 s4 = texture(map, (uv + vec2(1, 1)) * texelSize);\n\n\t\treturn mix(mix(s1, s2, f.x), mix(s3, s4, f.x), f.y);\n\t#endif\n}\n\nlayout(location = 0) out vec4 out_color;\n\nin vec2 vCoord;\n\n// Pre pass's filtered result\nuniform sampler2D lightTex;\n\n// G-Buffer\nuniform sampler2D gPosition;\nuniform sampler2D gNormal;\nuniform sampler2D gColor;\n\n// exp curve: https://www.desmos.com/calculator?lang=zh-CN\n// It can be simply understood as a range threshold\n// The greater the factor => the greater the distance, the greater the contribution\nuniform float colorFactor;\nuniform float normalFactor;\nuniform float positionFactor;\nuniform float stepwidth;\nuniform int level;\n\nfloat safeAcos(float v) {\n\treturn acos(min(max(v, 0.0), 1.0));\n}\n\nvec4 DenoiseImage() {\n\t// Fetch origin data\n\tvec4 upscaledLight = texture(lightTex, vCoord);\n\tfloat sampleFrame = upscaledLight.a;\n\tfloat sf2 = sampleFrame*sampleFrame;\n\tvec3 color = upscaledLight.rgb / upscaledLight.a;\n\tvec3 normal = texture(gNormal, vCoord).rgb;\n\tvec4 positionAndMeshIndex = textureLinear(gPosition, vCoord);\n\tvec3 position = positionAndMeshIndex.rgb;\n\n\t// BG\n\tfloat meshIndex = positionAndMeshIndex.w;\n\tbool isBG = meshIndex > 0.0 ? false : true;\n\tif (isBG) {\n\t\treturn upscaledLight;\n\t}\n\n\tvec2 size = vec2(textureSize(lightTex, 0));\n\tint kernelRadius = 9;\n\tfloat dx = 1. / size.x;\n\tfloat dy = 1. / size.y;\n\tfloat kernel[9] = float[9](\n\t\t1.0 / 16.0, 1.0 / 8.0, 1.0 / 16.0,\n\t\t1.0 / 8.0,  1.0 / 4.0, 1.0 / 8.0,\n\t\t1.0 / 16.0, 1.0 / 8.0, 1.0 / 16.0\n\t);\n\tvec2 offset[9] = vec2[9](\n\t\tvec2(-dx, -dy), vec2(0, -dy), vec2(dx, -dy),\n\t\tvec2(-dx, 0),  vec2(0, 0), vec2(dx, 0),\n\t\tvec2(-dx, dy),  vec2(0, dy), vec2(dx, dy)\n\t);\n\n\tvec3 colorSum = vec3(0.);\n\tfloat weightSum = 0.;\n\n\tfloat var;\n\tfloat varSum;\n\tfloat varSumWeight;\n\n\tfor (int i = 0; i < kernelRadius; i++) {\n\t\tvec2 uv = vCoord + offset[i] * float(stepwidth);\n\t\t// Bound\n\t\tif (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) {\n\t\t\tcontinue;\n\t\t}\n\t\t// BG\n\t\tvec4 positionAndMeshIndex = texture(gPosition, uv);\n\t\tfloat meshIndex = positionAndMeshIndex.w;\n\t\tbool isBG = meshIndex > 0.0 ? false : true;\n\t\tif (isBG) {\n\t\t\tcontinue;\n\t\t}\n\t\t// Edge-stopping weights\n\t\t// Color\n\t\tvec4 upscaledLight = texture(lightTex, uv);\n\t\tvec3 kernelColor = upscaledLight.rgb / upscaledLight.a;\n\t\t// Method 1:\n\t\t// vec3 t = color - kernelColor;\n\t\t// float Wc = min(exp(1.0-dot(t, t) / colorFactor * sf2), 1.0);\n\t\t// Method 2:\n\t\tfloat Dc = distance(color, kernelColor);\n\t\tfloat Wc;\n\t\tWc = min(exp(-Dc / (colorFactor + 1e-6)), 1.0);\n\t\t// Method 3:\n\t\t// vec3 t = color - kernelColor;\n\t\t// float dist2 = dot(t,t);\n\t\t// float Wc = min(exp(-dist2 / colorFactor), 1.0);\n\n\t\t// Normal\n\t\tvec3 kernelNormal = texture(gNormal, uv).rgb;\n\t\t// Method 1:\n\t\tfloat Dn = distance(normal, kernelNormal);\n\t\tfloat dist2 = max(Dn / (stepwidth * stepwidth + 1e-6), 0.0);\n\t\tfloat Wn = min(exp(-(dist2) / normalFactor + 1e-6), 1.0);\n\t\t// Method 2:\n\t\t// float Dn = dot(normal, kernelNormal);\n\t\t// Dn = Dn / float(stepwidth * stepwidth + 1e-6);\n\t\t// if (Dn < 1e-3) {\n\t\t// \tcontinue;\n\t\t// }\n\t\t// float Wn = Dn;\n\n\t\t// Position\n\t\tvec3 kernelPosition = positionAndMeshIndex.rgb;\n\t\t// Method 1:\n\t\t// t = abs(position - kernelPosition); // use Depth?\n\t\t// float Wp = max(min(exp(1.0-dot(t, t) / positionFactor), 1.0),0.0);\n\t\t// Method 2:\n\t\tfloat Dp = distance(position, kernelPosition);\n\t\tfloat Wp = min(exp(-Dp / (positionFactor + 1e-6)), 1.0);\n\t\t// Method 3:\n\t\t// t = position - kernelPosition;\n\t\t// dist2 = dot(t,t);\n\t\t// float Wp = min(exp(-dist2 / positionFactor), 1.0);\n\t\t\n\t\tfloat weight = Wc * Wn * Wp * kernel[i];\n\t\tweightSum += weight;\n\t\tcolorSum += kernelColor * weight;\n\t}\n\tcolorSum = colorSum / weightSum;\n\n\t// Keep next/toneMapping pass correct\n\treturn vec4(colorSum * sampleFrame, sampleFrame);\n}\n\nvoid main() {\n\tvec4 light = DenoiseImage();\n\tout_color = light;\n}"},i=new ft(e,a);this.renderPass=i,this.fullscreenTriangle=n}initFrameBuffers(t,e){const{gl:n}=this;this.readBuffer=new st(n,{color:{0:new St(n,{width:t,height:e,storage:"float",magFilter:n.NEAREST,minFilter:n.NEAREST})}}),this.writeBuffer=new st(n,{color:{0:new St(n,{width:t,height:e,storage:"float",magFilter:n.NEAREST,minFilter:n.NEAREST})}})}swapBuffers(){let t=this.writeBuffer;this.writeBuffer=this.readBuffer,this.readBuffer=t}setSize(t,e){this.initFrameBuffers(t,e)}setGBuffers({position:t,normal:e,color:n}){this.renderPass.setTexture("gPosition",t),this.renderPass.setTexture("gNormal",e),this.renderPass.setTexture("gColor",n)}setColorFactor(t){this.colorFactor=t}setNormalFactor(t){this.normalFactor=t}setPositionFactor(t){this.positionFactor=t}draw(t){let{light:e}=t;const{gl:n,renderPass:a,fullscreenTriangle:i,level:s,colorFactor:r,normalFactor:o,positionFactor:l}=this;for(let c=0;c<s;c++)a.setUniform("level",c),a.setUniform("colorFactor",1/(1<<c)*r),a.setUniform("normalFactor",1/(1<<c)*o),a.setUniform("positionFactor",1/(1<<c)*l),a.setUniform("stepwidth",(1<<c+1)-1),0===c?a.setTexture("lightTex",e):a.setTexture("lightTex",this.readBuffer.color[0]),this.writeBuffer.bind(),n.clear(n.COLOR_BUFFER_BIT),n.viewport(0,0,n.drawingBufferWidth,n.drawingBufferHeight),a.useProgram(),i.draw(),this.writeBuffer.unbind(),this.swapBuffers();return this.readBuffer}dispose(){this.renderPass.dispose()}}class Ie{constructor(t,e,n){this.gl=t,this.resourcePool=n,this.defaultLightScale=[1,1],this.fullscreenTriangle=e}createPipeline(t){const{gl:e,fullscreenTriangle:n}=this;this.renderSetting=t;const{toneMapping:a}=t,i={gl:e,vertex:n.vertexShader,fragment:"\nlayout(location = 0) out vec4 out_color;\n\nin vec2 vCoord;\n\nuniform sampler2D lightTex;\nuniform vec2 lightScale;\nuniform int toneMappingFun;\n\n// Threejs\n#ifndef saturate\n\t#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n\n// uniform float toneMappingExposure;\nconst float toneMappingExposure = 1.0;\n\nvec3 linear(vec3 color) {\n\treturn toneMappingExposure * color;\n}\n\n// source: https://github.com/selfshadow/ltc_code/blob/master/webgl/shaders/ltc/ltc_blit.fs\n// vec3 RRTAndODTFit( vec3 v ) {\n// \tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n// \tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n// \treturn a / b;\n// }\n// https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\n// return clamp((color * (2.51 * color + 0.03)) / (color * (2.43 * color + 0.59) + 0.14), vec3(0.0), vec3(1.0));\n// this implementation of ACES is modified to accommodate a brighter viewing environment.\n// the scale factor of 1/0.6 is subjective. see discussion in #19621.\n// vec3 acesFilmic( vec3 color ) {\n// \t// sRGB => XYZ => D65_2_D60 => AP1 => RRT_SAT\n// \tconst mat3 ACESInputMat = mat3(\n// \t\tvec3( 0.59719, 0.07600, 0.02840 ), // transposed from source\n// \t\tvec3( 0.35458, 0.90834, 0.13383 ),\n// \t\tvec3( 0.04823, 0.01566, 0.83777 )\n// \t);\n// \t// ODT_SAT => XYZ => D60_2_D65 => sRGB\n// \tconst mat3 ACESOutputMat = mat3(\n// \t\tvec3(  1.60475, -0.10208, -0.00327 ), // transposed from source\n// \t\tvec3( -0.53108,  1.10813, -0.07276 ),\n// \t\tvec3( -0.07367, -0.00605,  1.07602 )\n// \t);\n// \tcolor *= toneMappingExposure / 0.6;\n// \tcolor = ACESInputMat * color;\n// \t// Apply RRT and ODT\n// \tcolor = RRTAndODTFit( color );\n// \tcolor = ACESOutputMat * color;\n// \t// Clamp to [0, 1]\n// \treturn saturate( color );\n// }\n// vec3 LinearTosRGB( in vec3 value ) {\n// \treturn vec3( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ));\n// }\n\nvec3 NeutralToneMapping( vec3 color ) {\n\tconst float StartCompression = 0.8 - 0.04;\n\tconst float Desaturation = 0.15;\n\n\tcolor *= toneMappingExposure;\n\n\tfloat x = min( color.r, min( color.g, color.b ) );\n\n\tfloat offset = x < 0.08 ? x - 6.25 * x * x : 0.04;\n\n\tcolor -= offset;\n\n\tfloat peak = max( color.r, max( color.g, color.b ) );\n\n\tif ( peak < StartCompression ) return color;\n\n\tfloat d = 1. - StartCompression;\n\n\tfloat newPeak = 1. - d * d / ( peak + d - StartCompression );\n\n\tcolor *= newPeak / peak;\n\n\tfloat g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );\n\n\treturn mix( color, vec3( newPeak ), g );\n}\n\n// Old version\nvec3 acesFilmic( vec3 color ) {\n\treturn clamp((color * (2.51 * color + 0.03)) / (color * (2.43 * color + 0.59) + 0.14), vec3(0.0), vec3(1.0));\n}\nvec3 LinearTosRGB(in vec3 light) {\n\treturn pow(light, vec3(1.0 / 2.2));\n}\n\nvoid main() {\n\tvec4 upscaledLight = texture(lightTex, lightScale * vCoord);\n\t\n\tvec3 light = upscaledLight.rgb;\n\t\n\t// ToneMapping\n\tif (toneMappingFun == 0) {\n\t\tlight = linear(light);\n\t}\n\tif (toneMappingFun == 1) {\n\t\tlight = acesFilmic(light);\n\t}\n\tif (toneMappingFun == 2) {\n\t\tlight = NeutralToneMapping(light);\n\t}\n\t\n\tlight = LinearTosRGB(light); // gamma correction\n\t\n\t// premultipliedAlpha\n\tout_color = vec4(light * upscaledLight.a, upscaledLight.a);\n}"},s=new ft(e,i);s.setUniform("toneMappingFun",a),this.renderPass=s}initFrameBuffers(t,e){const{gl:n,resourcePool:a}=this,i=new St(n,{width:t,height:e,storage:"byte",magFilter:n.LINEAR,minFilter:n.LINEAR});this.passBuffer=new st(n,{color:{0:i}}),a.updateResource("ScreenPassOutputTexture",i)}draw(t,e=!1){let{light:n,lightScale:a}=t;a||(a=this.defaultLightScale);const{gl:i,renderPass:s,passBuffer:r,fullscreenTriangle:o}=this;if(s.setTexture("lightTex",n),s.setUniform("lightScale",a),e&&r)return r.bind(),i.clear(i.COLOR_BUFFER_BIT),i.viewport(0,0,i.drawingBufferWidth,i.drawingBufferHeight),s.useProgram(),o.draw(),r.unbind(),r;s.useProgram(),o.draw()}setSize(t,e){this.initFrameBuffers(t,e)}setToneMapping(t){this.renderPass.setUniform("toneMappingFun",t)}dispose(){this.renderPass.dispose()}}class Ne{constructor(t,e){this.gl=t,this.fullscreenTriangle=e}createPipeline(){const{gl:t,fullscreenTriangle:e}=this,n={vertex:e.vertexShader,fragment:"layout(location = 0) out vec4 out_color;\nin vec2 vCoord;\nuniform sampler2D inputTex;\n\nvoid main() {\n\tvec2 size = vec2(textureSize(inputTex, 0));\n\tvec4 accumulatedLight = texelFetch(inputTex, ivec2(vCoord * size), 0);\n\t\n\tout_color = accumulatedLight;\n}"},a=new ft(t,n);this.renderPass=a}draw(t){const{gl:e,renderPass:n,fullscreenTriangle:a}=this;let{inputTex:i,outputTex:s,width:r=e.drawingBufferWidth,height:o=e.drawingBufferHeight}=t;return n.setTexture("inputTex",i),s.bind(),e.viewport(0,0,r,o),n.useProgram(),a.draw(),s.unbind(),s}dispose(){this.renderPass.dispose()}}class Xe{constructor(t,e){this.strata=[];const n=t**e;for(let a=0;a<n;a++)this.strata[a]=a;this.index=this.strata.length,this.sample=[],this.strataCount=t,this.dimensions=e}restart(){this.index=0}next(){const{strata:t,strataCount:e,dimensions:n}=this;this.index>=t.length&&(!function(t){for(let e=t.length-1;e>0;e--){const n=Math.floor(Math.random()*(e+1)),a=t[e];t[e]=t[n],t[n]=a}}(this.strata),this.restart());let a=t[this.index++];for(let i=0;i<n;i++)this.sample[i]=a%e+Math.random(),a=Math.floor(a/e);return this.sample}}class we{constructor(t,e){this.strataObjs=[];for(const n of e)this.strataObjs.push(new Xe(t,n));this.combined=[],this.strataCount=t}next(){const{strataObjs:t,combined:e}=this;let n=0;for(const a of t){const t=a.next();for(const a of t)e[n++]=a}return e}restart(){for(const t of this.strataObjs)t.restart()}}const We=class{constructor(t,e,n){this.gl=t,this.fullscreenTriangle=e,this.resourcePool=n,this.samplingDimensions=[],this.samples=new we(1,this.samplingDimensions)}createPipeline(t,e=!1){const{gl:n,fullscreenTriangle:a,resourcePool:i}=this;let s;this.renderSetting=t;const r={SUPPORT_SG_WORKFLOW:t.supportSGWorkflow,SUPPORT_UV_TRANS:t.supportUVTrans,SUPPORT_TEX_WRAP:t.supportTexWrap,SUPPORT_ALPHA:t.supportAlpha,SUPPORT_ALPHA_SHADOW:t.supportAlphaShadow,SUPPORT_CAST_SHADOW:t.supportCastShadow,EXT_FLOAT_LINEAR:t.isFloatLinearSupport,NUM_LIGHTS:t.lightsNum,MAX_ALPHA_DEPTH:t.maxAlphaDepth,INTERSECT_EPS:t.minIntersectDistance,...t.bvhDefines,...t.materialDefines},o=JSON.stringify(r),l=i.getPipelineByCacheKey(We.ID,o);if(l){if(s=l,e)return}else s=new ft(n,{defines:r,fragment:"\n#define PI 3.14159265359\n#define TWOPI 6.28318530718\n#define INVPI 0.31830988618\n#define INVPI2 0.10132118364\n\n#define EPS 0.0001\n#define ONE_MINUS_EPS 0.999999\n#define INF 1000000.0\n// Mobile sync\n// #define INTERSECT_EPS 1.0e-2\n// #define ROUGHNESS_MIN 0.03 // Blender\n#define ROUGHNESS_MIN 0.001 // PBRT\n// #define ROUGHNESS_MIN 0.01\n\n// Material type\n#define DISNEY 0\n// https://www.w3.org/WAI/GL/wiki/Relative_luminance\nconst vec3 luminance = vec3(0.2126, 0.7152, 0.0722);\nfloat Luminance(vec3 color) { return dot(color, luminance); }\n#define RAY_MAX_DISTANCE 9999.0\n\nstruct Ray {\n\tvec3 o;\n\tvec3 d;\n};\n\nstruct Path {\n\tRay ray;\n\tvec3 li;\n\tfloat alpha;\n\tvec3 beta;\n\tbool abort;\n\tfloat misWeight;\n\n\tvec3 absorption;\n};\n\nstruct Camera {\n\tmat4 viewToWorldMat;\n\tmat4 clipToViewMat;\n\tfloat aperture;\n\tfloat focus;\n};\n\n#if defined(NUM_LIGHTS)\nstruct Lights {\n\tvec3 position[NUM_LIGHTS];\n\tvec3 emission[NUM_LIGHTS];\n\tvec3 p1[NUM_LIGHTS];\n\tvec3 p2[NUM_LIGHTS];\n\tvec4 params[NUM_LIGHTS];\n};\n\nstruct Light {\n\tvec3 position;\n\tfloat radius;\n\tvec3 emission;\n\tfloat area;\n\tvec3 p1; // param1: u, target\n\tfloat type;\n\tvec3 p2; // param2: v\n\tfloat visible;\n};\n#endif\n\nstruct SurfaceInteraction {\n\tbool hit;\n\tbool isEmitter;\n\tfloat t;\n\tvec3 position;\n\tvec3 normal;\n\tvec3 ffnormal;\n\tfloat eta;\n\n\t// Material\n\tvec3 color;\n\tfloat workflow;\n\t\n\tfloat roughness;\n\tfloat metalness;\n\tfloat transmission;\n\tfloat ior;\n\t\n\tfloat sheen;\n\tfloat sheenTint;\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n\t\n\tvec3 emissive;\n\tfloat alpha;\n\t\n\tfloat specularTint;\n\tfloat atDistance;\n\n\n\tvec3 specularColor;\n\tfloat subsurface;\n\n\tvec3 extinction;\n};\n\nstruct BsdfSampleRec {\n\tvec3 L;\n\tvec3 f;\n\tfloat pdf;\n};\n\nstruct LightSampleRec{\n\tvec3 normal;\n\tvec3 emission;\n\tvec3 direction;\n\tfloat dist;\n\tfloat pdf;\n};\n\n// given the index from a 1D array, retrieve corresponding position from packed 2D texture\nivec2 unpackTexel(int i, int columnsLog2) {\n\tivec2 u;\n\tu.y = i >> columnsLog2; // equivalent to (i / 2^columnsLog2)\n\tu.x = i - (u.y << columnsLog2); // equivalent to (i % 2^columnsLog2)\n\treturn u;\n}\nvec4 fetchData(sampler2D s, int i, int columnsLog2) {\n\treturn texelFetch(s, unpackTexel(i, columnsLog2), 0);\n}\nivec4 fetchData(isampler2D s, int i, int columnsLog2) {\n\treturn texelFetch(s, unpackTexel(i, columnsLog2), 0);\n}\n\nuniform Camera camera;\nuniform vec2 pixelSize; // 1 / screenResolution\nuniform vec2 jitter;\nuniform float frameCount;\nuniform sampler2D accumulateTex;\n\nin vec2 vCoord;\n\n#if defined(NUM_LIGHTS)\nuniform Lights lights;\n#endif\n\nuniform int bounces;\nuniform vec3 backgroundColor;\nuniform float envMapIntensity;\nuniform float backgroundAlpha;\nuniform float enviromentVisible;\n\nuniform int useBackgroundColor;\nuniform mat3 envRotMatrix;\nuniform mat3 invEnvRotMatrix;\n\nvec3 ndcToWorld(vec2 coord) {\n\tvec4 worldPos = camera.viewToWorldMat * camera.clipToViewMat * vec4(coord, -1.0, 1.0);\n\treturn worldPos.xyz / worldPos.w;\n}\nvec3 localToWorld(vec3 X, vec3 Y, vec3 Z, vec3 V) {\n    return vec3(\n        X.x * V.x + Y.x * V.y + Z.x * V.z,\n        X.y * V.x + Y.y * V.y + Z.y * V.z,\n        X.z * V.x + Y.z * V.y + Z.z * V.z\n    );\n}\nvec3 worldToLocal(vec3 X, vec3 Y, vec3 Z, vec3 V) {\n    return vec3(dot(V, X), dot(V, Y), dot(V, Z));\n}\n\n// Noise texture used to generate a different random number for each pixel.\n// We use blue noise in particular, but any type of noise will work.\nuniform sampler2D noiseTex;\n\nuniform float stratifiedSamples[71]; // bouncesMax(8) => [2,2,2,2] * 1 + (([2,2,2,2] + 1)* 7)\nuniform float strataSize;\n\nfloat pixelSeed;\n\nfloat hashRandom(vec2 p) {\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// https://www.shadertoy.com/view/wltcRS\nuvec4 seed;\nivec2 pixel;\nvoid initRNGFromScreen(float frame) {\n\tpixel = ivec2(vCoord / pixelSize);\n    seed = uvec4(pixel, int(frame), pixel.x + pixel.y);\n}\nvoid pcg4d(inout uvec4 v) {\n    v = v * 1664525u + 1013904223u;\n    v.x += v.y * v.w; v.y += v.z * v.x; v.z += v.x * v.y; v.w += v.y * v.z;\n    v = v ^ (v >> 16u);\n    v.x += v.y * v.w; v.y += v.z * v.x; v.z += v.x * v.y; v.w += v.y * v.z;\n}\nfloat rand() {\n    pcg4d(seed); \n\treturn float(seed.x) / float(0xffffffffu);\n}\nvec2 rand2() {\n    pcg4d(seed); \n\treturn vec2(seed.xy) / float(0xffffffffu);\n}\n\nvoid initRandom(float frame) {\n\tvec2 noiseSize = vec2(textureSize(noiseTex, 0));\n\t// tile the small noise texture across the entire screen\n\tpixelSeed = texture(noiseTex, vCoord / (pixelSize * noiseSize)).r;\n\tinitRNGFromScreen(frame);\n}\n\n// MaterialSamples\n\n// Every time we call randomSample() in the shader, and for every call to render,\n// we want that specific bit of the shader to fetch a sample from the same position in stratifiedSamples\n// This allows us to use stratified sampling for each random variable in our path tracing\nint sampleIndex = 0;\n\nfloat randomSample() {\n\tfloat stratifiedSample = stratifiedSamples[sampleIndex++];\n\n\t// stratified\n\tfloat random = fract((stratifiedSample + pixelSeed) * strataSize); // blue noise + stratified samples \n\n\t// transform random number between [0, 1] to (0, 1)\n\treturn EPS + (1.0 - 2.0 * EPS) * random;\n}\n\nvec2 randomSampleVec2() {\n\treturn vec2(randomSample(), randomSample());\n}\n\nstruct MaterialSamples {\n\tvec2 s1;\n\tvec2 s2;\n\tvec2 s3;\n\tvec2 s4;\n};\n\nMaterialSamples getRandomMaterialSamples() {\n\tMaterialSamples samples;\n\n\tsamples.s1 = randomSampleVec2();\n\tsamples.s2 = randomSampleVec2();\n\tsamples.s3 = randomSampleVec2();\n\tsamples.s4 = randomSampleVec2();\n\n\treturn samples;\n}\n\nvec4 textureLinear(sampler2D map, vec2 uv) {\n\t#ifdef EXT_FLOAT_LINEAR\n\t\treturn texture(map, uv);\n\t#else\n\t\tvec2 size = vec2(textureSize(map, 0));\n\t\tvec2 texelSize = 1.0 / size;\n\n\t\tuv = uv * size - 0.5;\n\t\tvec2 f = fract(uv);\n\t\tuv = floor(uv) + 0.5;\n\n\t\tvec4 s1 = texture(map, (uv + vec2(0, 0)) * texelSize);\n\t\tvec4 s2 = texture(map, (uv + vec2(1, 0)) * texelSize);\n\t\tvec4 s3 = texture(map, (uv + vec2(0, 1)) * texelSize);\n\t\tvec4 s4 = texture(map, (uv + vec2(1, 1)) * texelSize);\n\n\t\treturn mix(mix(s1, s2, f.x), mix(s3, s4, f.x), f.y);\n\t#endif\n}\n\n// Sample the environment map using a cumulative distribution function as described in\n// http://www.pbr-book.org/3ed-2018/Light_Transport_I_Surface_Reflection/Sampling_Light_Sources.html#InfiniteAreaLights\n\nuniform sampler2D envMap;\nuniform float totalSumValue;\nuniform sampler2D envMarginalWeights;\nuniform sampler2D envConditionalWeights;\n\nvec2 equirectDirToUV(vec3 pointOnSphere) {\n\tfloat phi = atan(pointOnSphere.z, pointOnSphere.x) / TWOPI;\n\tfloat theta = acos(pointOnSphere.y);\n\treturn vec2(phi + 0.5, theta * INVPI);\n}\n\nvec3 equirectUVToDir(vec2 uv) {\n\tuv.x -= 0.5;\n\tfloat theta = uv.x * 2.0 * PI;\n\tfloat phi = uv.y * PI;\n\tfloat sinPhi = sin(phi);\n\treturn vec3(sinPhi * cos(theta), cos(phi), sinPhi * sin(theta));\n}\n\nvec3 sampleEnvmapFromDirection(vec3 d) {\n\tvec2 uv = equirectDirToUV(d);\n\treturn textureLinear(envMap, uv).rgb;\n}\n\nfloat equirectDirectionPdf(vec3 dir) {\n\tvec2 uv = equirectDirToUV(dir);\n\tfloat sinTheta = sin(uv.y * PI);\n\tif (sinTheta == 0.0) {\n\t\treturn 0.0;\n\t}\n\treturn INVPI2 / (2.0 * sinTheta);\n}\n\nfloat envMapPdf(vec3 dir) {\n\tvec2 uv = equirectDirToUV(dir);\n\tvec3 color = textureLinear(envMap, uv).rgb;\n\tfloat lum = Luminance(color);\n\tvec2 size = vec2(textureSize(envMap, 0));\n\n\treturn (size.x * size.y) * (lum / totalSumValue) * equirectDirectionPdf(dir);\n}\n\nvec3 sampleEnvmap(vec2 random, out vec2 uv, out float pdf) {\n\tvec2 size = vec2(textureSize(envMap, 0));\n\tfloat sizeMarginalWeights = size.y;\n\tfloat v = texelFetch(envMarginalWeights, ivec2(random.x * sizeMarginalWeights, 0), 0).x;\n\tfloat u = texelFetch(envConditionalWeights, ivec2(random.y * size.x, v * size.y), 0).x;\n\tuv = vec2(u, v);\n\n\tvec3 dir = equirectUVToDir(uv);\n\n\tvec3 color = textureLinear(envMap, uv).rgb;\n\tfloat lum = Luminance(color);\n\n\tpdf = (size.x * size.y) * (lum / totalSumValue) * equirectDirectionPdf(dir);\n\n\treturn dir;\n}\n\n// https://graphics.pixar.com/library/OrthonormalB/paper.pdf\nvoid OrthonormalBasis(in vec3 N, inout vec3 T, inout vec3 B) {\n    if (N.z < -0.999999) {\n        T = vec3(0., -1., 0.);\n        B = vec3(-1., 0., 0.);\n    } else {\n        float a = 1.0 / (1. + N.z);\n        float b = -N.x * N.y * a;\n        T = vec3(1.0 - N.x * N.x * a, b, -N.x);\n        B = vec3(b, 1.- N.y * N.y * a, -N.y);\n    }\n}\n\n// Sampling the GGX Distribution of Visible Normals\n// https://jcgt.org/published/0007/04/01/paper.pdf\nvec3 SampleGGXVNDF(vec3 V, float rgh, float r1, float r2) {\n    vec3 Vh = normalize(vec3(rgh * V.x, rgh * V.y, V.z));\n\n    float lensq = Vh.x * Vh.x + Vh.y * Vh.y;\n    vec3 T1 = lensq > 0. ? vec3(-Vh.y, Vh.x, 0) * inversesqrt(lensq) : vec3(1., 0., 0.);\n    vec3 T2 = cross(Vh, T1);\n\n    float r = sqrt(r1);\n    float phi = 2.0 * PI * r2;\n    float t1 = r * cos(phi);\n    float t2 = r * sin(phi);\n    float s = 0.5 * (1.0 + Vh.z);\n    t2 = (1.0 - s) * sqrt(1.0 - t1 * t1) + s * t2;\n\n    vec3 Nh = t1 * T1 + t2 * T2 + sqrt(max(0.0, 1.0 - t1 * t1 - t2 * t2)) * Vh;\n\n    return normalize(vec3(rgh * Nh.x, rgh * Nh.y, max(0.0, Nh.z)));\n}\n\n// http://www.pbr-book.org/3ed-2018/Monte_Carlo_Integration/2D_Sampling_with_Multidimensional_Transformations.html#SamplingaUnitDisk\nvec2 sampleCircle(vec2 p) {\n\tp = 2.0 * p - 1.0;\n\n\tbool greater = abs(p.x) > abs(p.y);\n\tfloat r = greater ? p.x : p.y;\n\tfloat theta = greater ? 0.25 * PI * p.y / p.x : PI * (0.5 - 0.25 * p.x / p.y);\n\n\treturn r * vec2(cos(theta), sin(theta));\n}\n\n// http://www.pbr-book.org/3ed-2018/Monte_Carlo_Integration/2D_Sampling_with_Multidimensional_Transformations.html#Cosine-WeightedHemisphereSampling\nvec3 cosineSampleHemisphere(vec2 p) {\n\tvec2 h = sampleCircle(p);\n\tfloat z = sqrt(max(0.0, 1.0 - h.x * h.x - h.y * h.y));\n\treturn vec3(h, z);\n}\nvec3 CosineSampleHemisphere(float r1, float r2) {\n    vec3 dir;\n    float r = sqrt(r1);\n    float phi = TWOPI * r2;\n    dir.x = r * cos(phi);\n    dir.y = r * sin(phi);\n    dir.z = sqrt(max(0.0, 1.0 - dir.x * dir.x - dir.y * dir.y));\n    return dir;\n}\n\nvec3 UniformSampleSphere(float r1, float r2) {\n    float z = 1.0 - 2.0 * r1;\n    float r = sqrt(max(0.0, 1.0 - z * z));\n    float phi = TWOPI * r2;\n\n    return vec3(r * cos(phi), r * sin(phi), z);\n}\n\nfloat powerHeuristic(float f, float g) {\n\treturn (f * f) / (f * f + g * g);\n}\n\nvec3 EmitterSample(in Ray r, int depth, in LightSampleRec lightSampleRec, in BsdfSampleRec bsdfSampleRec) {\n    vec3 Le;\n\n    if (depth == 0) {\n        Le = lightSampleRec.emission;\n    } else {\n        // MIS bsdf\n        Le = powerHeuristic(bsdfSampleRec.pdf, lightSampleRec.pdf) * lightSampleRec.emission;\n    }\n\n    return Le;\n}\n\n#if defined(NUM_LIGHTS)\n\nvoid sampleAreaLight(in Light light, in vec3 surfacePos, inout LightSampleRec lightSampleRec, vec2 random) {\n    float r1 = random.x - 0.5;\n    float r2 = random.y - 0.5;\n\n    vec3 lightSurfacePos = light.position + light.p1 * r1 + light.p2 * r2;\n    lightSampleRec.direction = lightSurfacePos - surfacePos;\n    lightSampleRec.dist = length(lightSampleRec.direction);\n    float distSq = lightSampleRec.dist * lightSampleRec.dist;\n    lightSampleRec.direction /= lightSampleRec.dist;\n    lightSampleRec.normal = normalize(cross(light.p1, light.p2));\n    lightSampleRec.emission = light.emission * float(NUM_LIGHTS);\n    lightSampleRec.pdf = distSq / (light.area * abs(dot(lightSampleRec.normal, lightSampleRec.direction)));\n}\n\nvoid sampleDirectionLight(in Light light, in vec3 surfacePos, inout LightSampleRec lightSampleRec) {\n    lightSampleRec.direction = normalize(light.position - light.p1);\n    lightSampleRec.normal = normalize(surfacePos - light.position);\n    // Keep lighting backface\n    if (dot(lightSampleRec.direction, lightSampleRec.normal) > 0.0) {\n        lightSampleRec.normal = -lightSampleRec.normal;\n    }\n    lightSampleRec.emission = light.emission * float(NUM_LIGHTS);\n    lightSampleRec.dist = INF;\n    lightSampleRec.pdf = 1.0;\n}\n\nvoid samplePointLight(in Light light, in vec3 surfacePos, inout LightSampleRec lightSampleRec) {\n    lightSampleRec.direction = light.position - surfacePos;\n    lightSampleRec.dist = length(lightSampleRec.direction);\n    float distSq = lightSampleRec.dist * lightSampleRec.dist;\n\n    lightSampleRec.direction = normalize(lightSampleRec.direction);\n    lightSampleRec.normal = normalize(surfacePos - light.position);\n    lightSampleRec.emission = light.emission * float(NUM_LIGHTS) / distSq;\n    lightSampleRec.pdf = 1.0;\n}\n\nfloat getSpotAttenuation(const in float coneCosine, const in float penumbraCosine, const in float angleCosine) {\n    return smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n\nvoid sampleSpotLight(in Light light, in vec3 surfacePos, inout LightSampleRec lightSampleRec) {\n    lightSampleRec.direction = light.position - surfacePos;\n    lightSampleRec.dist = length(lightSampleRec.direction);\n\n    lightSampleRec.direction = normalize(lightSampleRec.direction);\n    lightSampleRec.normal = normalize(light.p1);\n    float cosTheta = dot(normalize(surfacePos - light.position), lightSampleRec.normal);\n    // distanceAttenuation\n    float distSq = pow(lightSampleRec.dist, light.p2.z);\n    // spotAttenuation\n    float spotAttenuation = getSpotAttenuation(light.p2.x, light.p2.y, cosTheta);\n    \n    lightSampleRec.emission = light.emission * spotAttenuation *  float(NUM_LIGHTS) / distSq;\n    lightSampleRec.pdf = 1.0;\n}\n\n// Represents a direct illumination estimate for all light sources in the entire scene\nvoid sampleOneLight(in Light light, in vec3 surfacePos, inout LightSampleRec lightSampleRec, vec2 random) {\n\tint type = int(light.type);\n\tif (type == 0) {\n        sampleAreaLight(light, surfacePos, lightSampleRec, random);\n    } else if (type == 1) {\n        sampleDirectionLight(light, surfacePos, lightSampleRec);\n    } else if (type == 2) {\n        samplePointLight(light, surfacePos, lightSampleRec);\n    } else if (type == 3) {\n        sampleSpotLight(light, surfacePos, lightSampleRec);\n    }\n}\n#endif\n\n// UBO-1\n#ifdef NUM_MATERIALS\nuniform Materials {\n\tvec4 colorWorkflow[NUM_MATERIALS];\n\tvec4 roughMetalTransIOR[NUM_MATERIALS];\n\tvec4 sheenTintClearcoatRoughness[NUM_MATERIALS];\n\tvec4 emissiveAlpha[NUM_MATERIALS];\n\tvec4 specularTintAtDistanceNormalScale[NUM_MATERIALS];\n\tvec4 subsurfaceAndColor[NUM_MATERIALS];\n\tvec4 extinctionSubsurfaceMFP[NUM_MATERIALS];\n\tvec4 specularColorGlossiness[NUM_MATERIALS];\n\n\tivec4 diffuseNormalRoughnessMetalnessMapIndex[NUM_MATERIALS];\n\tivec4 emissiveSpecularGlossinessMapIndex[NUM_MATERIALS];\n\n} materials;\n#endif\n\nuniform mediump sampler2DArray materialTexArray;\nvec3 srgbToLinear(vec3 srgb) { return pow(srgb, vec3(2.2)); }\n\n#if defined(SUPPORT_UV_TRANS) || defined(SUPPORT_TEX_WRAP)\n\tuniform sampler2D uvTransBuffer;\n\t#define UV_TRANS_MAPS_LEN 7\n#endif\n\n#ifdef SUPPORT_UV_TRANS\n\tmat3 getMatUVTransform(int materialID, int mapKey) {\n\t\tint offset = materialID * UV_TRANS_MAPS_LEN * 3;\n\t\tint mapOffset = mapKey * 3;\n\t\tvec3 matRow1 = fetchData(uvTransBuffer, offset + mapOffset + 0, UV_TRANS_COLUMNS).xyz;\n\t\tvec3 matRow2 = fetchData(uvTransBuffer, offset + mapOffset + 1, UV_TRANS_COLUMNS).xyz;\n\t\tvec3 matRow3 = fetchData(uvTransBuffer, offset + mapOffset + 2, UV_TRANS_COLUMNS).xyz;\n\t\tmat3 uvTransMat = mat3(matRow1, matRow2, matRow3);\n\t\treturn uvTransMat;\n\t}\n#endif\n#ifdef SUPPORT_TEX_WRAP\n\tvec3 getMatWrapping(int materialID, int mapKey) {\n\t\tint offset = TEX_WRAP_DATA_INDEX + materialID * UV_TRANS_MAPS_LEN;\n\t\tint mapOffset = mapKey;\n\t\tvec3 wrappingData = fetchData(uvTransBuffer, offset + mapOffset, UV_TRANS_COLUMNS).xyz;\n\t\treturn wrappingData;\n\t}\n\tvec2 applyTextureWrapping(vec2 uv, vec3 warpping) {\n\t\tif (uv.x <= 0. || uv.x >= 1.) {\n\t\t\tint warpS = int(warpping.x);\n\t\t\tif (warpS == 1) {\n\t\t\t\t// ClampToEdgeWrapping\n\t\t\t\tuv.x = uv.x <= 0. ? 0. : 1.;\n\t\t\t} else if (warpS == 2) {\n\t\t\t\t// MirroredRepeatWrapping\n            \tuv.x = 1.0 - abs(fract(uv.x * 0.5) * 2.0 - 1.0);\n\t\t\t} else {\n\t\t\t\t// RepeatWrapping\n\t\t\t\tuv.x = fract(uv.x);\n\t\t\t}\n\t\t}\n\t\tif (uv.y <= 0. || uv.y >= 1.) {\n\t\t\tint warpT = int(warpping.y);\n\t\t\tif (warpT == 1) {\n\t\t\t\tuv.y = uv.y <= 0. ? 0. : 1.;\n\t\t\t} else if (warpT == 2) {\n\t\t\t\tuv.y = 1.0 - abs(fract(uv.y * 0.5) * 2.0 - 1.0);\n\t\t\t} else {\n\t\t\t\tuv.y = fract(uv.y);\n\t\t\t}\n\t\t}\n\n\t\treturn uv;\n\t}\n#endif\n\n#ifdef SUPPORT_SG_WORKFLOW\n\tfloat max3(const vec3 v) { return max(v.x, max(v.y, v.z)); }\n\tfloat computeMetallicFromSpecularColor(const vec3 specularColor) { return max3(specularColor); }\n\tvec3 computeDiffuseColor(const vec3 baseColor, float metallic) { return baseColor * (1.0 - metallic); }\n\n\tvec3 getMatSpecularColor(int materialID, vec2 uv) {\n\t\tvec3 specularColor = materials.specularColorGlossiness[materialID].rgb;\n\t\tint specularMapIndex = materials.emissiveSpecularGlossinessMapIndex[materialID].y;\n\t\tif (specularMapIndex > -1) {\n\n\t#ifdef SUPPORT_UV_TRANS\n\t\tmat3 uvTransMat = getMatUVTransform(materialID, 4);\n\t\tuv = (uvTransMat * vec3(uv, 1)).xy;\n\t#endif\n\t#ifdef SUPPORT_TEX_WRAP\n\t\tvec3 warpping = getMatWrapping(materialID, 4);\n\t\tuv = applyTextureWrapping(uv, warpping);\n\t#endif\n\n\t\t\tvec3 texelSpecular = srgbToLinear(texture(materialTexArray, vec3(uv, specularMapIndex)).rgb);\n\t\t\tspecularColor *= texelSpecular;\n\t\t}\n\n\t\treturn specularColor;\n\t}\n\n\tfloat getMatGlossiness(int materialID, vec2 uv) {\n\t\tfloat glossiness = materials.specularColorGlossiness[materialID].a;\n\t\tint glossinessMapIndex = materials.emissiveSpecularGlossinessMapIndex[materialID].z;\n\t\tif (glossinessMapIndex > -1) {\n\n\t\t#ifdef SUPPORT_UV_TRANS\n\t\t\tmat3 uvTransMat = getMatUVTransform(materialID, 5);\n\t\t\tuv = (uvTransMat * vec3(uv, 1)).xy;\n\t\t#endif\n\t\t#ifdef SUPPORT_TEX_WRAP\n\t\t\tvec3 warpping = getMatWrapping(materialID, 5);\n\t\t\tuv = applyTextureWrapping(uv, warpping);\n\t\t#endif\n\n\t\t\tfloat texelGlossiness = texture(materialTexArray, vec3(uv, glossinessMapIndex)).a;\n\t\t\tglossiness *= texelGlossiness;\n\t\t}\n\t\treturn glossiness;\n\t}\n#endif\n\nvec4 getMatColorAlpha(int materialID, vec2 uv) {\n\tvec3 color = materials.colorWorkflow[materialID].rgb;\n\tfloat alpha =  materials.emissiveAlpha[materialID].a;\n\n\tint diffuseMapIndex = materials.diffuseNormalRoughnessMetalnessMapIndex[materialID].x;\n\tif (diffuseMapIndex > -1) {\n\t\t\n\t#ifdef SUPPORT_UV_TRANS\n\t\tmat3 uvTransMat = getMatUVTransform(materialID, 0);\n\t\tuv = (uvTransMat * vec3(uv, 1)).xy;\n\t#endif\n\t#ifdef SUPPORT_TEX_WRAP\n\t\tvec3 warpping = getMatWrapping(materialID, 0);\n\t\tuv = applyTextureWrapping(uv, warpping);\n\t#endif\n\n\t\tvec4 texData = texture(materialTexArray, vec3(uv, diffuseMapIndex));\n\t\tcolor *= srgbToLinear(texData.rgb);\n\t\talpha *= texData.a;\n\t}\n\n#ifdef SUPPORT_SG_WORKFLOW\n\tfloat workflow = materials.colorWorkflow[materialID].w;\n\tif (workflow > 0.1) {\n\t\tvec3 specularFactor = getMatSpecularColor(materialID, uv);\n\t\tcolor = computeDiffuseColor(color, computeMetallicFromSpecularColor(specularFactor));\n\t}\n#endif\n\n\treturn vec4(color, alpha);\n}\n\nfloat getMatRoughness(int materialID, vec2 uv) {\n\tfloat workflow = materials.colorWorkflow[materialID].w;\n\tfloat roughness = 0.0;\n\n#ifdef SUPPORT_SG_WORKFLOW\n\tif (workflow > 0.1) {\n\t\troughness = 1.0 - getMatGlossiness(materialID, uv);\n\t} else \n#endif\n\n\t{\n\t\troughness = materials.roughMetalTransIOR[materialID].x;\n\n\t\tint roughnessMapIndex = materials.diffuseNormalRoughnessMetalnessMapIndex[materialID].z;\n\t\tif (roughnessMapIndex > -1) {\n\t\t\n\t\t#ifdef SUPPORT_UV_TRANS\n\t\t\tmat3 uvTransMat = getMatUVTransform(materialID, 2);\n\t\t\tuv = (uvTransMat * vec3(uv, 1)).xy;\n\t\t#endif\n\t\t#ifdef SUPPORT_TEX_WRAP\n\t\t\tvec3 warpping = getMatWrapping(materialID, 2);\n\t\t\tuv = applyTextureWrapping(uv, warpping);\n\t\t#endif\n\n\t\t\troughness *= texture(materialTexArray, vec3(uv, roughnessMapIndex)).g;\n\t\t}\n\t}\n\t// Remap\n\treturn roughness * roughness;\n}\n\nfloat getMatMetalness(int materialID, vec2 uv) {\n\tfloat workflow = materials.colorWorkflow[materialID].w;\n\tfloat metalness = 0.0;\n\n#ifdef SUPPORT_SG_WORKFLOW\n\tif (workflow > 0.1) {\n\t\tvec3 specularFactor = getMatSpecularColor(materialID, uv);\n\t\tmetalness = computeMetallicFromSpecularColor(specularFactor);\n\t} else \n#endif\n\n\t{\n\t\tmetalness = materials.roughMetalTransIOR[materialID].y;\n\n\t\tint metalnessMapIndex = materials.diffuseNormalRoughnessMetalnessMapIndex[materialID].w;\n\t\tif (metalnessMapIndex > -1) {\n\n\t\t#ifdef SUPPORT_UV_TRANS\n\t\t\tmat3 uvTransMat = getMatUVTransform(materialID, 3);\n\t\t\tuv = (uvTransMat * vec3(uv, 1)).xy;\n\t\t#endif\n\t\t#ifdef SUPPORT_TEX_WRAP\n\t\t\tvec3 warpping = getMatWrapping(materialID, 3);\n\t\t\tuv = applyTextureWrapping(uv, warpping);\n\t\t#endif\n\n\t\t\tmetalness *= texture(materialTexArray, vec3(uv, metalnessMapIndex)).b;\n\t\t}\n\t}\n\n\treturn metalness;\n}\n\nvec3 getMatEmissive(int materialID, vec2 uv) {\n\tvec3 emissive = materials.emissiveAlpha[materialID].xyz;\n\n\tint emissiveMapIndex = materials.emissiveSpecularGlossinessMapIndex[materialID].x;\n\tif (emissiveMapIndex > -1) {\n\n\t#ifdef SUPPORT_UV_TRANS\n\t\tmat3 uvTransMat = getMatUVTransform(materialID, 6);\n\t\tuv = (uvTransMat * vec3(uv, 1)).xy;\n\t#endif\n\t#ifdef SUPPORT_TEX_WRAP\n\t\tvec3 warpping = getMatWrapping(materialID, 6);\n\t\tuv = applyTextureWrapping(uv, warpping);\n\t#endif\n\n\t\temissive *= srgbToLinear(texture(materialTexArray, vec3(uv, emissiveMapIndex)).rgb);\n\t}\n\t\n\treturn emissive;\n}\n\nvec3 getMatNormal(int materialID, vec2 uv, vec3 normal, vec3 dp1, vec3 dp2, vec2 duv1, vec2 duv2) {\n\t// http://www.thetenthplanet.de/archives/1180\n\t// Compute co-tangent and co-bitangent vectors\n\tvec3 dp2perp = cross(dp2, normal);\n\tvec3 dp1perp = cross(normal, dp1);\n\tvec3 dpdu = dp2perp * duv1.x + dp1perp * duv2.x;\n\tvec3 dpdv = dp2perp * duv1.y + dp1perp * duv2.y;\n\tfloat invmax = inversesqrt(max(dot(dpdu, dpdu), dot(dpdv, dpdv)));\n\tdpdu *= invmax;\n\tdpdv *= invmax;\n\n\t// All world space\n\tint normalMapIndex = materials.diffuseNormalRoughnessMetalnessMapIndex[materialID].y;\n\tif (normalMapIndex > -1) {\n\t\t\n\t#ifdef SUPPORT_UV_TRANS\n\t\tmat3 uvTransMat = getMatUVTransform(materialID, 1);\n\t\tuv = (uvTransMat * vec3(uv, 1)).xy;\n\t#endif\n\t#ifdef SUPPORT_TEX_WRAP\n\t\tvec3 warpping = getMatWrapping(materialID, 1);\n\t\tuv = applyTextureWrapping(uv, warpping);\n\t#endif\n\n\t\tvec3 n = 2.0 * texture(materialTexArray, vec3(uv, normalMapIndex)).rgb - 1.0;\n\t\tn.xy *= materials.specularTintAtDistanceNormalScale[materialID].zw;\n\n\t\tmat3 tbn = mat3(dpdu, dpdv, normal);\n\n\t\treturn normalize(tbn * n);\n\t} else {\n\t\treturn normal;\n\t}\n\n\treturn normal;\n}\n\n\n// specularTintAtDistanceNormalScale\nfloat getMatSpecularTint(int materialID) {\n\treturn materials.specularTintAtDistanceNormalScale[materialID].x;\n}\nfloat getMatAtDistance(int materialID) {\n\treturn materials.specularTintAtDistanceNormalScale[materialID].y;\n}\n\n// subsurfaceAndColor\nfloat getMatSubface(int materialID) {\n\treturn materials.subsurfaceAndColor[materialID].x;\n}\nvec3 getMatSubfaceColor(int materialID) {\n\treturn materials.subsurfaceAndColor[materialID].yzw;\n}\n\n// extinctionSubsurfaceMFP\nvec3 getMatExtinction(int materialID) {\n\treturn materials.extinctionSubsurfaceMFP[materialID].rgb;\n}\nfloat getMatSubsurfaceMFP(int materialID) {\n\treturn materials.extinctionSubsurfaceMFP[materialID].a;\n}\n\nfloat getMatCastShadow(int materialID) {\n\tfloat workflow = materials.colorWorkflow[materialID].w;\n\tfloat castShadow = 0.0;\n\t\n\tif (workflow > 0.1) {\n\t\tcastShadow = materials.roughMetalTransIOR[materialID].x;\n\t} else {\n\t\tcastShadow = materials.specularColorGlossiness[materialID].a;\n\t}\n\n\treturn castShadow;\n}\n\nuniform sampler2D positionBuffer;\nuniform sampler2D normalBuffer;\n\n#if defined(BVH_DYNAMIC)\n\tuniform sampler2D blasBuffer;\n\tuniform sampler2D tlasBuffer;\n\tuniform sampler2D tlasTransformBuffer;\n#else\n\tuniform sampler2D bvhBuffer;\n#endif\n\n\nstruct Triangle {\n\tvec3 p0;\n\tvec3 p1;\n\tvec3 p2;\n};\n\nstruct TriangleIntersect {\n\tfloat t;\n\tvec3 barycentric;\n};\n\nfloat rectIntersect(in vec3 pos, in vec3 u, in vec3 v, in vec4 plane, in Ray r) {\n    vec3 n = vec3(plane);\n    float dt = dot(r.d, n);\n    float t = (plane.w - dot(n, r.o)) / dt;\n\t// Plane\n    if (t > EPS) {\n        vec3 p = r.o + r.d * t;\n        vec3 vi = p - pos;\n        float a1 = dot(u, vi);\n        if (abs( a1 ) <= 0.5) {\n            float a2 = dot(v, vi);\n            if (abs( a2 ) <= 0.5)\n                return t;\n        }\n    }\n\n    return INF;\n}\n\n// MllerTrumbore closest intersection\n// Method2: http://www.pbr-book.org/3ed-2018/Shapes/Triangle_Meshes.html#TriangleIntersection\nTriangleIntersect intersectTriangle(Ray r, Triangle tri, float tMax) {\n\tvec3 v0 = tri.p0;\n\tvec3 v1 = tri.p1;\n\tvec3 v2 = tri.p2;\n\n\tTriangleIntersect ti;\n\n\tvec3 e0 = v1 - v0;\n\tvec3 e1 = v2 - v0;\n\tvec3 pv = cross(r.d, e1);\n\tfloat det = dot(e0, pv);\n\n\tvec3 tv = r.o - v0;\n\tvec3 qv = cross(tv, e0);\n\n\tvec4 uvt;\n\tuvt.x = dot(tv, pv);\n\tuvt.y = dot(r.d, qv);\n\tuvt.z = dot(e1, qv);\n\tuvt.xyz = uvt.xyz / det;\n\tuvt.w = 1.0 - uvt.x - uvt.y;\n\n\t// Check if closer intersection already exists\n\tif(uvt.z >= tMax) {\n\t\treturn ti;\n\t}\n\n\t// Check if intersection is inside triangle\n\tif (all(greaterThanEqual(uvt, vec4(0.0))) && uvt.z < INF) {\n\t\tti.t = uvt.z;\n\t\tti.barycentric = uvt.wxy;\n\t}\n\t\n\treturn ti;\n}\n\n// Branchless ray/box intersection\n// https://tavianator.com/fast-branchless-raybounding-box-intersections/\nfloat intersectBox(Ray r, vec3 aabbMin, vec3 aabbMax, vec3 invDir, float tMax) {\n\tvec3 tBot = (aabbMin - r.o) * invDir;\n\tvec3 tTop = (aabbMax - r.o) * invDir;\n\tvec3 tNear = min(tBot, tTop);\n\tvec3 tFar = max(tBot, tTop);\n\tfloat t0 = max(tNear.x, max(tNear.y, tNear.z));\n\tfloat t1 = min(tFar.x, min(tFar.y, tFar.z));\n\n\treturn (t0 > t1 || t0 > tMax) ? -1.0 : (t0 > 0.0 ? t0 : t1);\n}\n\nvoid surfaceInteractionFromBVH(inout SurfaceInteraction si, Triangle tri, vec3 barycentric, ivec3 index, vec3 u, int materialID) {\n\tsi.hit = true;\n\tsi.position = barycentric.x * tri.p0 + barycentric.y * tri.p1 + barycentric.z * tri.p2;\n\tivec2 i0 = unpackTexel(index.x, VERTEX_COLUMNS);\n\tivec2 i1 = unpackTexel(index.y, VERTEX_COLUMNS);\n\tivec2 i2 = unpackTexel(index.z, VERTEX_COLUMNS);\n\n\tvec4 nv0 = texelFetch(normalBuffer, i0, 0);\n\tvec4 nv1 = texelFetch(normalBuffer, i1, 0);\n\tvec4 nv2 = texelFetch(normalBuffer, i2, 0);\n\tvec3 n0 = nv0.xyz;\n\tvec3 n1 = nv1.xyz;\n\tvec3 n2 = nv2.xyz;\n\tvec3 normal = normalize(barycentric.x * n0 + barycentric.y * n1 + barycentric.z * n2);\n\n\tvec2 uv0 = vec2(u.x, nv0.w);\n\tvec2 uv1 = vec2(u.y, nv1.w);\n\tvec2 uv2 = vec2(u.z, nv2.w);\n\n\t// vec2 uv = fract(barycentric.x * uv0 + barycentric.y * uv1 + barycentric.z * uv2);\n\tvec2 uv = barycentric.x * uv0 + barycentric.y * uv1 + barycentric.z * uv2;\n\n\tvec3 dp1 = tri.p0 - tri.p2;\n\tvec3 dp2 = tri.p1 - tri.p2;\n\tvec2 duv1 = uv0 - uv2;\n\tvec2 duv2 = uv1 - uv2;\n\tsi.normal = getMatNormal(materialID, uv, normal, dp1, dp2, duv1, duv2);\n\n\t// Material\n\tsi.workflow = materials.colorWorkflow[materialID].w;\n\tvec4 colorAlpha = getMatColorAlpha(materialID, uv);\n\tsi.color = colorAlpha.rgb;\n\tsi.alpha = colorAlpha.a;\n\tsi.emissive = getMatEmissive(materialID, uv);\n\n\tsi.roughness = clamp(getMatRoughness(materialID, uv), ROUGHNESS_MIN, 1.0);\n\tsi.metalness = getMatMetalness(materialID, uv);\n\tsi.transmission = materials.roughMetalTransIOR[materialID].z;\n\tsi.ior = materials.roughMetalTransIOR[materialID].w;\n\n\tsi.sheen = materials.sheenTintClearcoatRoughness[materialID].x;\n\tsi.sheenTint = materials.sheenTintClearcoatRoughness[materialID].y;\n\tsi.clearcoat = materials.sheenTintClearcoatRoughness[materialID].z;\n\tsi.clearcoatRoughness = materials.sheenTintClearcoatRoughness[materialID].w;\n\n    si.specularTint = materials.specularTintAtDistanceNormalScale[materialID].x;\n\tsi.atDistance = materials.specularTintAtDistanceNormalScale[materialID].y;\n\n\tsi.subsurface = materials.subsurfaceAndColor[materialID].x;\n\tsi.extinction =  materials.extinctionSubsurfaceMFP[materialID].rgb;\n\n#ifdef SUPPORT_SG_WORKFLOW\n\tsi.specularColor = getMatSpecularColor(materialID, uv);\n#endif\n}\n\nfloat surfaceMaterialAlphaFromBVH(Triangle tri, vec3 barycentric, ivec3 index, vec3 u, int materialID) {\n\tivec2 i0 = unpackTexel(index.x, VERTEX_COLUMNS);\n\tivec2 i1 = unpackTexel(index.y, VERTEX_COLUMNS);\n\tivec2 i2 = unpackTexel(index.z, VERTEX_COLUMNS);\n\n\tvec4 nv0 = texelFetch(normalBuffer, i0, 0);\n\tvec4 nv1 = texelFetch(normalBuffer, i1, 0);\n\tvec4 nv2 = texelFetch(normalBuffer, i2, 0);\n\t\n\tvec2 uv0 = vec2(u.x, nv0.w);\n\tvec2 uv1 = vec2(u.y, nv1.w);\n\tvec2 uv2 = vec2(u.z, nv2.w);\n\n\t// vec2 uv = fract(barycentric.x * uv0 + barycentric.y * uv1 + barycentric.z * uv2);\n\tvec2 uv = barycentric.x * uv0 + barycentric.y * uv1 + barycentric.z * uv2;\n\tfloat alpha = getMatColorAlpha(materialID, uv).a;\n\n\treturn alpha;\n}\n \n\n#ifndef BVH_DYNAMIC\n// Static\nbool intersectSceneShadow(inout Ray ray, float maxDist) {\n\tvec3 invDir = 1. / ray.d;\n\tfloat tMax = maxDist;\n\n\tint nodesToVisit[STACK_SIZE];\n\tnodesToVisit[0] = 0;\n\tint stack = 0;\n\n\twhile(stack >= 0 && stack < STACK_SIZE) {\n\t\tint i = nodesToVisit[stack--];\n\n\t\tvec4 r1 = fetchData(bvhBuffer, i, BVH_COLUMNS);\n\t\tvec4 r2 = fetchData(bvhBuffer, i + 1, BVH_COLUMNS);\n\n\t\t// negative => Primitives\n\t\t// positive => Node\n\t\tint splitAxisOrNumPrimitives = int(r1.w);\n\n\t\tif (splitAxisOrNumPrimitives >= 0) {\n\t\t\t// Intersection is a bounding box. Test for box intersection and keep traversing BVH\n\t\t\tint splitAxis = splitAxisOrNumPrimitives;\n\n\t\t\tif (intersectBox(ray, r1.xyz, r2.xyz, invDir, tMax) > 0.0) {\n\t\t\t\t// traverse near node to ray first, and far node to ray last\n\t\t\t\tif (ray.d[splitAxis] > 0.0) {\n\t\t\t\t\tnodesToVisit[++stack] = int(r2.w);\n\t\t\t\t\tnodesToVisit[++stack] = i + 2;\n\t\t\t\t} else {\n\t\t\t\t\tnodesToVisit[++stack] = i + 2;\n\t\t\t\t\tnodesToVisit[++stack] = int(r2.w);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t\n\t\t\tint materialID = int(r2.w);\n\t\t#ifdef SUPPORT_ALPHA\n\t\t\t// Sync shadow casting\n\t\t\tfloat castShadow = getMatCastShadow(materialID);\n\t\t\tif (castShadow == 0.) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t#endif\n\t\t\t\n\t\t\tivec3 index = ivec3(r1.xyz);\n\t\t\t\n\t\t\tvec4 pu0 = fetchData(positionBuffer, index.x, VERTEX_COLUMNS);\n\t\t\tvec4 pu1 = fetchData(positionBuffer, index.y, VERTEX_COLUMNS);\n\t\t\tvec4 pu2 = fetchData(positionBuffer, index.z, VERTEX_COLUMNS);\n\t\t\tTriangle tri = Triangle(pu0.xyz, pu1.xyz, pu2.xyz);\n\t\t\t\n\t\t\tTriangleIntersect hit = intersectTriangle(ray, tri, tMax);\n\n\t\t\tif (hit.t > 0.0) {\n\n\t\t\t#ifdef SUPPORT_ALPHA_SHADOW\n\t\t\t\tvec3 u = vec3(pu0.w, pu1.w, pu2.w);\n\t\t\t\tfloat alpha = surfaceMaterialAlphaFromBVH(tri, hit.barycentric, index, u, materialID);\n\t\t\t\tif (rand() > alpha) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t#endif\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n\nvoid intersectScene(Ray ray, inout SurfaceInteraction si, inout LightSampleRec lightSampleRec, int depth, float maxDist) {\n\tsi.hit = false;\n\tfloat tMax = maxDist;\n\tvec3 invDir = 1. / ray.d;\n\tfloat curDist;\n\t// Intersect Emitters\n\t#if defined(NUM_LIGHTS)\n\t\tfor (int i = 0; i < NUM_LIGHTS; i++) {\n\t\t\t// Light Data\n\t\t\tvec4 params = lights.params[i];\n\t\t\tfloat radius = params.x;\n\t\t\tfloat area = params.y;\n\t\t\tfloat type = params.z;\n\t\t\tfloat visible = params.w;\n\t\t\tif (depth == 0 && visible < 0.1) continue;\n\n\t\t\tvec3 position = lights.position[i];\n\t\t\tvec3 emission = lights.emission[i];\n\t\t\tvec3 p1 = lights.p1[i];\n\t\t\tvec3 p2 = lights.p2[i];\n\t\t\t// Area\n\t\t\tif (type == 0.) {\n\t\t\t\tvec3 normal = normalize(cross(p1, p2));\n\t\t\t\t// Hide backface\n\t\t\t\tif (dot(normal, ray.d) > 0.)\n\t\t\t\t\tcontinue;\n\t\t\t\tvec4 plane = vec4(normal, dot(normal, position));\n\t\t\t\tp1 *= 1.0 / dot(p1, p1);\n\t\t\t\tp2 *= 1.0 / dot(p2, p2);\n\t\t\t\tcurDist = rectIntersect(position, p1, p2, plane, ray);\n\n\t\t\t\tif (curDist < 0.)\n\t\t\t\t\tcurDist = INF;\n\t\t\t\tif (curDist < tMax) {\n\t\t\t\t\ttMax = curDist;\n\t\t\t\t\tfloat cosTheta = dot(-ray.d, normal);\n\t\t\t\t\tfloat pdf = (curDist * curDist) / (area * cosTheta);\n\t\t\t\t\tlightSampleRec.emission = emission;\n\t\t\t\t\tlightSampleRec.pdf = pdf;\n\t\t\t\t\tsi.hit = true;\n\t\t\t\t\tsi.isEmitter = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t#endif\n\n\tint nodesToVisit[STACK_SIZE];\n\tnodesToVisit[0] = 0;\n\n\tint stack = 0;\n\t// Recursive => stack\n\twhile(stack >= 0 && stack < STACK_SIZE) {\n\t\tint i = nodesToVisit[stack--];\n\n\t\tvec4 r1 = fetchData(bvhBuffer, i, BVH_COLUMNS);\n\t\tvec4 r2 = fetchData(bvhBuffer, i + 1, BVH_COLUMNS);\n\n\t\t// negative => Primitives\n\t\t// positive => Node\n\t\tint splitAxisOrNumPrimitives = int(r1.w);\n\n\t\tif (splitAxisOrNumPrimitives >= 0) {\n\t\t\t// Intersection is a bounding box. Test for box intersection and keep traversing BVH\n\t\t\tint splitAxis = splitAxisOrNumPrimitives;\n\n\t\t\tif (intersectBox(ray, r1.xyz, r2.xyz, invDir, tMax) > 0.0) {\n\t\t\t\t// traverse near node to ray first, and far node to ray last\n\t\t\t\tif (ray.d[splitAxis] > 0.0) {\n\t\t\t\t\tnodesToVisit[++stack] = int(r2.w);\n\t\t\t\t\tnodesToVisit[++stack] = i + 2;\n\t\t\t\t} else {\n\t\t\t\t\tnodesToVisit[++stack] = i + 2;\n\t\t\t\t\tnodesToVisit[++stack] = int(r2.w);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tivec3 index = ivec3(r1.xyz);\n\t\t\tvec4 pu0 = fetchData(positionBuffer, index.x, VERTEX_COLUMNS);\n\t\t\tvec4 pu1 = fetchData(positionBuffer, index.y, VERTEX_COLUMNS);\n\t\t\tvec4 pu2 = fetchData(positionBuffer, index.z, VERTEX_COLUMNS);\n\t\t\tTriangle tri = Triangle(pu0.xyz, pu1.xyz, pu2.xyz);\n\n\t\t\tTriangleIntersect hit = intersectTriangle(ray, tri, tMax);\n\n\t\t\tif (hit.t > 0.0) {\n\t\t\t\tint materialID = int(r2.w);\n\t\t\t\tvec3 faceNormal = r2.xyz;\n\t\t\t\tsi.t = hit.t;\n\t\t\t\tsi.isEmitter = false;\n\t\t\t\ttMax = hit.t;\n\t\t\t\tvec3 u = vec3(pu0.w, pu1.w, pu2.w);\n\t\t\t\t// get geometry/material info by index\n\t\t\t\tsurfaceInteractionFromBVH(si, tri, hit.barycentric, index, u, materialID);\n\t\t\t\tsi.ffnormal = dot(faceNormal, ray.d) <= 0.0 ? si.normal : -si.normal;\n\t\t\t\t// si.ffnormal = dot(si.normal, ray.d) <= 0.0 ? si.normal : -si.normal;\n\t\t\t\tsi.eta = dot(si.normal, si.ffnormal) > 0.0 ? (1.0 / si.ior) : si.ior;\n\t\t\t}\n\t\t}\n\t}\n}\n\n#endif\n\n\n#ifdef BVH_DYNAMIC\n// Performance\nbool intersectSceneShadow(Ray ray, float maxDist) {\n\tfloat tMax = maxDist;\n\n\tconst int SHADOW_STACK_SIZE = 20;\n\n\tint nodesToVisit[SHADOW_STACK_SIZE];\n\tint nodesLevel[SHADOW_STACK_SIZE];\n\tnodesToVisit[0] = 0;\n\tnodesLevel[0] = 0;\n\tvec3 invDirWorld = 1. / ray.d;\n\tvec3 invDirLocal = vec3(1.);\n\n\tint tlasMatID = 0;\n\tint tlasMeshID = 0;\n\tmat4 tlasTransMat;\n\tmat4 tlasTransMatInverse;\n\tRay rayTrans = Ray(ray.o, ray.d);\n\tbool throughBLASMark = false;\n\n\tint stack = 0;\n\twhile(stack >= 0 && stack < SHADOW_STACK_SIZE) {\n\t\tint i = nodesToVisit[stack];\n\t\tint level = nodesLevel[stack];\n\t\tstack--;\n\n\t\t// If we've traversed the entire BLAS then switch to back to TLAS and resume where we left off\n        if (throughBLASMark && i == -1) {\n\t\t\tthroughBLASMark = false;\n\t\t\trayTrans.o = ray.o;\n\t\t\trayTrans.d = ray.d;\n\t\t\t// Next TLAS Node\n\t\t\tcontinue;\n        }\n\t\t\n\t\tif (level == 0) {\n\t\t\t// TLAS info\n\t\t\tvec4 r1 = fetchData(tlasBuffer, i, TLAS_COLUMNS);\n\t\t\tvec4 r2 = fetchData(tlasBuffer, i + 1, TLAS_COLUMNS);\n\t\t\t// negative => Leaf => -1\n\t\t\t// positive => InteriorNode's splitAxis(0/1/2)\n\t\t\tint typeFlag = int(r1.w);\n\t\t\tif (typeFlag >= 0) {\n\t\t\t\t// TLAS-InteriorNode\n\t\t\t\tif (intersectBox(rayTrans, r1.xyz, r2.xyz, invDirWorld, tMax) > 0.0) {\n\t\t\t\t\tif (rayTrans.d[typeFlag] > 0.0) {\n\t\t\t\t\t\tstack++;\n\t\t\t\t\t\tnodesToVisit[stack] = int(r2.w);\n\t\t\t\t\t\tnodesLevel[stack] = 0;\n\n\t\t\t\t\t\tstack++;\n\t\t\t\t\t\tnodesToVisit[stack] = i + 2;\n\t\t\t\t\t\tnodesLevel[stack] = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstack++;\n\t\t\t\t\t\tnodesToVisit[stack] = i + 2;\n\t\t\t\t\t\tnodesLevel[stack] = 0;\n\n\t\t\t\t\t\tstack++;\n\t\t\t\t\t\tnodesToVisit[stack] = int(r2.w);\n\t\t\t\t\t\tnodesLevel[stack] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// TLAS-Leaf\n\t\t\t\t// r1.xyz => blasBufferSplitIndex[p.geometryID]/materialID/meshID\n\t\t\t\tint visible = int(r2.x);\n\t\t\t\tif (visible == 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint instanceID = int(r1.z);\n\t\t\t\t\n\t\t\t\tvec4 matRow1 = fetchData(tlasTransformBuffer, instanceID * 4 + 0, TLAS_TRANSFORM_COLUMNS).xyzw;\n\t\t\t\tvec4 matRow2 = fetchData(tlasTransformBuffer, instanceID * 4 + 1, TLAS_TRANSFORM_COLUMNS).xyzw;\n\t\t\t\tvec4 matRow3 = fetchData(tlasTransformBuffer, instanceID * 4 + 2, TLAS_TRANSFORM_COLUMNS).xyzw;\n\t\t\t\tvec4 matRow4 = fetchData(tlasTransformBuffer, instanceID * 4 + 3, TLAS_TRANSFORM_COLUMNS).xyzw;\n\n\t\t\t\ttlasTransMat = mat4(matRow1, matRow2, matRow3, matRow4);\n\t\t\t\ttlasTransMatInverse = inverse(tlasTransMat);\n\n\t\t\t\trayTrans.o = vec3(tlasTransMatInverse * vec4(ray.o, 1.0));\n            \trayTrans.d = vec3(tlasTransMatInverse * vec4(ray.d, 0.0));\n\t\t\t\tinvDirLocal = 1. / rayTrans.d;\n\n\t\t\t\t// Mark\n\t\t\t\tstack++;\n\t\t\t\tthroughBLASMark = true;\n\t\t\t\tnodesToVisit[stack] = -1;\n\t\t\t\tnodesLevel[stack] = -1;\n\n\t\t\t\tstack++;\n\t\t\t\tnodesToVisit[stack] = int(r1.x);\n\t\t\t\tnodesLevel[stack] = 1;\n\t\t\t\ttlasMatID = int(r1.y);\n\t\t\t\ttlasMeshID = int(r1.z);\n\t\t\t}\n\t\t} else {\n\t\t\t// BLAS info\n\t\t\tvec4 r1 = fetchData(blasBuffer, i, BLAS_COLUMNS);\n\t\t\tvec4 r2 = fetchData(blasBuffer, i + 1, BLAS_COLUMNS);\n\t\t\tint typeFlag = int(r1.w);\n\t\t\tif (typeFlag >= 0) {\n\t\t\t\t// BLAS-InteriorNode\n\t\t\t\tif (intersectBox(rayTrans, r1.xyz, r2.xyz, invDirLocal, tMax) > 0.0) {\n\t\t\t\t\tif (rayTrans.d[typeFlag] > 0.0) {\n\t\t\t\t\t\tstack++;\n\t\t\t\t\t\tnodesToVisit[stack] = int(r2.w);\n\t\t\t\t\t\tnodesLevel[stack] = 1;\n\n\t\t\t\t\t\tstack++;\n\t\t\t\t\t\tnodesToVisit[stack] = i + 2;\n\t\t\t\t\t\tnodesLevel[stack] = 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstack++;\n\t\t\t\t\t\tnodesToVisit[stack] = i + 2;\n\t\t\t\t\t\tnodesLevel[stack] = 1;\n\n\t\t\t\t\t\tstack++;\n\t\t\t\t\t\tnodesToVisit[stack] = int(r2.w);\n\t\t\t\t\t\tnodesLevel[stack] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// BLAS-Leaf\n\n\t\t\t#ifdef SUPPORT_ALPHA\n\t\t\t\t// Sync shadow casting\n\t\t\t\tfloat castShadow = getMatCastShadow(tlasMatID);\n\t\t\t\tif (castShadow == 0.) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t#endif\n\t\t\t\n\t\t\t\tivec3 index = ivec3(r1.xyz);\n\t\t\t\tvec4 pu0 = fetchData(positionBuffer, index.x, VERTEX_COLUMNS);\n\t\t\t\tvec4 pu1 = fetchData(positionBuffer, index.y, VERTEX_COLUMNS);\n\t\t\t\tvec4 pu2 = fetchData(positionBuffer, index.z, VERTEX_COLUMNS);\n\t\t\t\tTriangle tri = Triangle(pu0.xyz, pu1.xyz,pu2.xyz);\n\n\t\t\t\tTriangleIntersect hit = intersectTriangle(rayTrans, tri, tMax);\n\t\t\t\t\n\t\t\t\tif (hit.t > 0.0) {\n\n\t\t\t\t#ifdef SUPPORT_ALPHA_SHADOW\n\t\t\t\t\tvec3 u = vec3(pu0.w, pu1.w, pu2.w);\n\t\t\t\t\tfloat alpha = surfaceMaterialAlphaFromBVH(tri, hit.barycentric, index, u, tlasMatID);\n\t\t\t\t\tif (rand() > alpha) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t#endif\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n\n// Dynamic\nvoid intersectScene(Ray ray, inout SurfaceInteraction si, inout LightSampleRec lightSampleRec, int depth, float maxDist) {\n\tsi.hit = false;\n\tfloat tMax = maxDist;\n\tfloat curDist;\n\t// Intersect Emitters\n\t#if defined(NUM_LIGHTS)\n\t\tfor (int i = 0; i < NUM_LIGHTS; i++) {\n\t\t\t// Light Data\n\t\t\tvec4 params = lights.params[i];\n\t\t\tfloat radius = params.x;\n\t\t\tfloat area = params.y;\n\t\t\tfloat type = params.z;\n\t\t\tfloat visible = params.w;\n\t\t\tif (depth == 0 && visible < 0.1) continue;\n\n\t\t\tvec3 position = lights.position[i];\n\t\t\tvec3 emission = lights.emission[i];\n\t\t\tvec3 p1 = lights.p1[i];\n\t\t\tvec3 p2 = lights.p2[i];\n\t\t\t// Area\n\t\t\tif (type == 0.) {\n\t\t\t\tvec3 normal = normalize(cross(p1, p2));\n\t\t\t\t// Hide backface\n\t\t\t\tif (dot(normal, ray.d) > 0.)\n\t\t\t\t\tcontinue;\n\t\t\t\tvec4 plane = vec4(normal, dot(normal, position));\n\t\t\t\tp1 *= 1.0 / dot(p1, p1);\n\t\t\t\tp2 *= 1.0 / dot(p2, p2);\n\t\t\t\tcurDist = rectIntersect(position, p1, p2, plane, ray);\n\n\t\t\t\tif (curDist < 0.)\n\t\t\t\t\tcurDist = INF;\n\t\t\t\tif (curDist < tMax) {\n\t\t\t\t\ttMax = curDist;\n\t\t\t\t\tfloat cosTheta = dot(-ray.d, normal);\n\t\t\t\t\tfloat pdf = (curDist * curDist) / (area * cosTheta);\n\t\t\t\t\tlightSampleRec.emission = emission;\n\t\t\t\t\tlightSampleRec.pdf = pdf;\n\t\t\t\t\tsi.hit = true;\n\t\t\t\t\tsi.isEmitter = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t#endif\n\n\tint nodesToVisit[STACK_SIZE];\n\tint nodesLevel[STACK_SIZE];\n\tnodesToVisit[0] = 0;\n\tnodesLevel[0] = 0;\n\tvec3 invDirWorld = 1. / ray.d;\n\tvec3 invDirLocal = vec3(1.);\n\n\tint tlasMatID = 0;\n\tint tlasMeshID = 0;\n\tmat4 tlasTransMat;\n\tmat4 tlasTransMatInverse;\n\tRay rayTrans = Ray(ray.o, ray.d);\n\tbool throughBLASMark = false;\n\n\tint stack = 0;\n\t// Recursive => stack\n\twhile(stack >= 0 && stack < STACK_SIZE) {\n\t\tint i = nodesToVisit[stack];\n\t\tint level = nodesLevel[stack];\n\t\tstack--;\n\n\t\t// If we've traversed the entire BLAS then switch to back to TLAS and resume where we left off\n        if (throughBLASMark && i == -1) {\n\t\t\tthroughBLASMark = false;\n\t\t\trayTrans.o = ray.o;\n\t\t\trayTrans.d = ray.d;\n\t\t\t// Next TLAS Node\n\t\t\tcontinue;\n        }\n\t\t\n\t\tif (level == 0) {\n\t\t\t// TLAS info\n\t\t\tvec4 r1 = fetchData(tlasBuffer, i, TLAS_COLUMNS);\n\t\t\tvec4 r2 = fetchData(tlasBuffer, i + 1, TLAS_COLUMNS);\n\t\t\t// negative => Leaf => -1\n\t\t\t// positive => InteriorNode's splitAxis(0/1/2)\n\t\t\tint typeFlag = int(r1.w);\n\t\t\tif (typeFlag >= 0) {\n\t\t\t\t// TLAS-InteriorNode\n\t\t\t\tif (intersectBox(rayTrans, r1.xyz, r2.xyz, invDirWorld, tMax) > 0.0) {\n\t\t\t\t\tif (rayTrans.d[typeFlag] > 0.0) {\n\t\t\t\t\t\tstack++;\n\t\t\t\t\t\tnodesToVisit[stack] = int(r2.w);\n\t\t\t\t\t\tnodesLevel[stack] = 0;\n\n\t\t\t\t\t\tstack++;\n\t\t\t\t\t\tnodesToVisit[stack] = i + 2;\n\t\t\t\t\t\tnodesLevel[stack] = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstack++;\n\t\t\t\t\t\tnodesToVisit[stack] = i + 2;\n\t\t\t\t\t\tnodesLevel[stack] = 0;\n\n\t\t\t\t\t\tstack++;\n\t\t\t\t\t\tnodesToVisit[stack] = int(r2.w);\n\t\t\t\t\t\tnodesLevel[stack] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// TLAS-Leaf\n\t\t\t\t// r1.xyz => blasBufferSplitIndex[p.geometryID]/materialID/meshID\n\t\t\t\tint visible = int(r2.x);\n\t\t\t\tif (visible == 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint instanceID = int(r1.z);\n\t\t\t\t\n\t\t\t\tvec4 matRow1 = fetchData(tlasTransformBuffer, instanceID * 4 + 0, TLAS_TRANSFORM_COLUMNS).xyzw;\n\t\t\t\tvec4 matRow2 = fetchData(tlasTransformBuffer, instanceID * 4 + 1, TLAS_TRANSFORM_COLUMNS).xyzw;\n\t\t\t\tvec4 matRow3 = fetchData(tlasTransformBuffer, instanceID * 4 + 2, TLAS_TRANSFORM_COLUMNS).xyzw;\n\t\t\t\tvec4 matRow4 = fetchData(tlasTransformBuffer, instanceID * 4 + 3, TLAS_TRANSFORM_COLUMNS).xyzw;\n\t\t\t\t\n\t\t\t\ttlasTransMat = mat4(matRow1, matRow2, matRow3, matRow4);\n\t\t\t\ttlasTransMatInverse = inverse(tlasTransMat);\n\n\t\t\t\trayTrans.o = vec3(tlasTransMatInverse * vec4(ray.o, 1.0));\n            \trayTrans.d = vec3(tlasTransMatInverse * vec4(ray.d, 0.0));\n\t\t\t\tinvDirLocal = 1. / rayTrans.d;\n\n\t\t\t\t// Mark\n\t\t\t\tstack++;\n\t\t\t\tthroughBLASMark = true;\n\t\t\t\tnodesToVisit[stack] = -1;\n\t\t\t\tnodesLevel[stack] = -1;\n\n\t\t\t\tstack++;\n\t\t\t\tnodesToVisit[stack] = int(r1.x);\n\t\t\t\tnodesLevel[stack] = 1;\n\t\t\t\ttlasMatID = int(r1.y);\n\t\t\t\ttlasMeshID = int(r1.z);\n\t\t\t}\n\t\t} else {\n\t\t\t// BLAS info\n\t\t\tvec4 r1 = fetchData(blasBuffer, i, BLAS_COLUMNS);\n\t\t\tvec4 r2 = fetchData(blasBuffer, i + 1, BLAS_COLUMNS);\n\t\t\tint typeFlag = int(r1.w);\n\t\t\t\n\t\t\tif (typeFlag >= 0) {\n\t\t\t\t// BLAS-InteriorNode\n\t\t\t\tif (intersectBox(rayTrans, r1.xyz, r2.xyz, invDirLocal, tMax) > 0.0) {\n\t\t\t\t\tif (rayTrans.d[typeFlag] > 0.0) {\n\t\t\t\t\t\tstack++;\n\t\t\t\t\t\tnodesToVisit[stack] = int(r2.w);\n\t\t\t\t\t\tnodesLevel[stack] = 1;\n\n\t\t\t\t\t\tstack++;\n\t\t\t\t\t\tnodesToVisit[stack] = i + 2;\n\t\t\t\t\t\tnodesLevel[stack] = 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstack++;\n\t\t\t\t\t\tnodesToVisit[stack] = i + 2;\n\t\t\t\t\t\tnodesLevel[stack] = 1;\n\n\t\t\t\t\t\tstack++;\n\t\t\t\t\t\tnodesToVisit[stack] = int(r2.w);\n\t\t\t\t\t\tnodesLevel[stack] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// BLAS-Leaf\n\t\t\t\tivec3 index = ivec3(r1.xyz);\n\t\t\t\tvec4 pu0 = fetchData(positionBuffer, index.x, VERTEX_COLUMNS);\n\t\t\t\tvec4 pu1 = fetchData(positionBuffer, index.y, VERTEX_COLUMNS);\n\t\t\t\tvec4 pu2 = fetchData(positionBuffer, index.z, VERTEX_COLUMNS);\n\t\t\t\tTriangle tri = Triangle(pu0.xyz, pu1.xyz,pu2.xyz);\n\n\t\t\t\tTriangleIntersect hit = intersectTriangle(rayTrans, tri, tMax);\n\t\t\t\t\n\t\t\t\tif (hit.t > 0.0) {\n\t\t\t\t\tvec3 faceNormal = r2.xyz;\n\t\t\t\t\tsi.t = hit.t;\n\t\t\t\t\tsi.isEmitter = false;\n\t\t\t\t\ttMax = hit.t;\n\t\t\t\t\tvec3 u = vec3(pu0.w, pu1.w, pu2.w);\n\t\t\t\t\t// get geometry/material info by index\n\t\t\t\t\tsurfaceInteractionFromBVH(si, tri, hit.barycentric, index, u, tlasMatID);\n\t\t\t\t\t// To world space\n\t\t\t\t\tsi.position = vec3(tlasTransMat * vec4(si.position, 1.0));\n\t\t\t\t\tmat3 inverseNormalMat = transpose(mat3(tlasTransMatInverse));\n\t\t\t\t\tsi.normal = normalize(inverseNormalMat * si.normal);\n\n\t\t\t\t\tsi.ffnormal = dot(normalize(inverseNormalMat * faceNormal), ray.d) <= 0.0 ? si.normal : -si.normal;\n\t\t\t\t\tsi.eta = dot(si.normal, si.ffnormal) > 0.0 ? (1.0 / si.ior) : si.ior;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n#endif\n\n\nfloat SchlickR0FromEta(float eta) { \n    float sqrtR0 = (eta - 1.) / (eta + 1.);\n    return sqrtR0 * sqrtR0;\n}\n\nfloat SchlickWeight(float u) {\n    float m = clamp(1.0 - u, 0.0, 1.0);\n    float m2 = m * m;\n    return m2 * m2 * m; // pow(m,5)\n}\n\nfloat SchlickFresnel(float F0, float cosTheta) {\n    return mix(F0, 1.0, SchlickWeight(cosTheta));\n}\nvec3 SchlickFresnel(vec3 F0, float cosTheta) {\n    return mix(F0, vec3(1.), SchlickWeight(cosTheta));\n}\n\nfloat DielectricFresnel(float cosThetaI, float eta) {\n    float sinThetaTSq = eta * eta * (1.0f - cosThetaI * cosThetaI);\n    // Total internal reflection\n    if (sinThetaTSq > 1.0)\n        return 1.0;\n\n    float cosThetaT = sqrt(max(1.0 - sinThetaTSq, 0.0));\n    float rs = (eta * cosThetaT - cosThetaI) / (eta * cosThetaT + cosThetaI);\n    float rp = (eta * cosThetaI - cosThetaT) / (eta * cosThetaI + cosThetaT);\n\n    return 0.5 * (rs * rs + rp * rp);\n}\n\nvec3 DisneyFresnel(vec3 F0, float metalness, float eta, float cosThetaI) {\n    // F0 Effect\n    vec3 FrSchlick = SchlickFresnel(F0, cosThetaI);\n    // IOR Effect\n    float FrDielectric = DielectricFresnel(cosThetaI, eta);\n    return mix(vec3(FrDielectric), FrSchlick, metalness);\n}\n\n// Fresnel estimates\nfloat DisneyFresnel(float metalness, float eta, float cosThetaI) {\n    float FrSchlick = SchlickWeight(cosThetaI);\n    float FrDielectric = DielectricFresnel(cosThetaI, eta);\n    return mix(FrDielectric, FrSchlick, metalness);\n}\n\n// The Implicit Masking Function\n// https://zhuanlan.zhihu.com/p/81708753\nfloat SmithG_GGX(float NDotV, float alphaG) {\n    float a = alphaG * alphaG;\n    float b = NDotV * NDotV;\n    return 1.0 / (NDotV + sqrt(a + b - a * b));\n}\n\nfloat GTR1(float NDotH, float alpha) {\n    float alpha2 = alpha * alpha;\n    float t = 1.0 + (alpha2 - 1.0) * NDotH * NDotH;\n    return (alpha2 - 1.0) / (PI * log(alpha2) * t);\n}\n\nfloat GTR2(float NDotH, float a) {\n    float a2 = a * a;\n    float t = 1.0 + (a2 - 1.0) * NDotH * NDotH;\n    return a2 / (PI * t * t);\n}\n\nvec3 ISGTR1(float rgh, float r1, float r2) {\n    float a = max(0.001, rgh);\n    float a2 = a * a;\n\n    float phi = r1 * TWOPI;\n\n    float cosTheta = sqrt((1.0 - pow(a2, 1.0 - r1)) / (1.0 - a2));\n    float sinTheta = clamp(sqrt(1.0 - (cosTheta * cosTheta)), 0.0, 1.0);\n    float sinPhi = sin(phi);\n    float cosPhi = cos(phi);\n\n    return vec3(sinTheta * cosPhi, sinTheta * sinPhi, cosTheta);\n}\n\nvec3 ISGTR2(float rgh, float r1, float r2) {\n    float a = max(0.001, rgh);\n\n    float phi = r1 * TWOPI;\n\n    float cosTheta = sqrt((1.0 - r2) / (1.0 + (a * a - 1.0) * r2));\n    float sinTheta = clamp(sqrt(1.0 - (cosTheta * cosTheta)), 0.0, 1.0);\n    float sinPhi = sin(phi);\n    float cosPhi = cos(phi);\n\n    return vec3(sinTheta * cosPhi, sinTheta * sinPhi, cosTheta);\n}\n\n\nvec3 DisneyDiffuse(SurfaceInteraction si, vec3 Csheen, vec3 V, vec3 L, vec3 H, out float pdf) {\n    pdf = 0.0;\n    if (L.z <= 0.0)\n        return vec3(0.0);\n    // CosineHemispherePdf => cosTheta * InvPi;\n    pdf = L.z * INVPI;\n    \n    float LDotH = dot(L, H);\n\n    // Diffuse\n    float FL = SchlickWeight(L.z);\n    float FV = SchlickWeight(V.z);\n    float Fh = SchlickWeight(LDotH);\n    float Fd90 = 0.5 + 2.0 * LDotH * LDotH * si.roughness;\n    float Fd = mix(1.0, Fd90, FL) * mix(1.0, Fd90, FV);\n\n    // Disney Fake Subsurface(BRDF approximate)\n    // https://cseweb.ucsd.edu/~ravir/6998/papers/p165-hanrahan.pdf\n    float Fss90 = LDotH * LDotH * si.roughness;\n    float Fss = mix(1.0, Fss90, FL) * mix(1.0, Fss90, FV);\n    float DisneyFakeSS = 1.25 * (Fss * (1.0 / (L.z + V.z) - 0.5) + 0.5);\n\n    vec3 Fsheen = Fh * si.sheen * Csheen;\n    // https://github.com/wdas/brdf/blob/main/src/brdfs/disney.brdf\n    return (INVPI * mix(Fd, DisneyFakeSS, si.subsurface) * si.color + Fsheen) * (1.0 - si.metalness) * (1.0 - si.transmission);\n}\n\nvec3 DisneySpecular(SurfaceInteraction si, vec3 Cspec0, vec3 V, vec3 L, vec3 H, out float pdf) {\n    pdf = 0.0;\n    if (L.z <= 0.0)\n        return vec3(0.0);\n\n    float LDotH = dot(L, H);\n\n    float D = GTR2(H.z, si.roughness);\n    pdf = D * H.z / (4.0 * LDotH);\n    \n    // For the Fresnel call, make sure that wh is in the same hemisphere\n    // as the surface normal, so that TIR is handled correctly.\n    // PBRT:\n    vec3 F = DisneyFresnel(Cspec0, si.metalness, si.eta, LDotH);\n    // Blender\n    // vec3 F = SchlickFresnel(Cspec0, LDotH);\n    float G = SmithG_GGX(abs(L.z), si.roughness) * SmithG_GGX(abs(V.z), si.roughness);\n    return F * D * G;\n}\n\n// https://www.pbr-book.org/3ed-2018/Reflection_Models/Microfacet_Models\nvec3 DisneyTransmission(SurfaceInteraction si, vec3 Cspec0, vec3 V, vec3 L, vec3 H, out float pdf) {\n    pdf = 0.0;\n    if (L.z >= 0.0)\n        return vec3(0.0);\n\n    float F = DielectricFresnel(abs(dot(V, H)), si.eta);\n    \n    float D = GTR2(H.z, si.roughness);\n    // DisneyTransmission::Pdf\n    float denomSqrt = dot(L, H) + dot(V, H) * si.eta;\n    pdf = D * H.z * abs(dot(L, H)) / (denomSqrt * denomSqrt);\n\n    float G = SmithG_GGX(abs(L.z), si.roughness) * SmithG_GGX(abs(V.z), si.roughness);\n    // Walter et al's model, with the provided transmissive term scaled\n    // by sqrt(color), so that after two refractions, we're back to the\n    // provided color.\n    // Blender no do this\n    vec3 specColor = pow(si.color, vec3(0.5));\n    return specColor * (1.0 - si.metalness) * si.transmission * (1.0 - F) * D * G * abs(dot(V, H)) * abs(dot(L, H)) * 4.0 * si.eta * si.eta / (denomSqrt * denomSqrt);\n}\n\nvec3 DisneyClearcoat(SurfaceInteraction si, vec3 V, vec3 L, vec3 H, out float pdf) {\n    pdf = 0.0;\n    if (L.z <= 0.0)\n        return vec3(0.0);\n    \n    float LDotH = dot(L, H);\n    \n    // float FH = DielectricFresnel(dot(V, H), 1.0 / 1.5);\n    // float F = mix(0.04, 1.0, FH);\n    // PBRT:\n    float F = SchlickFresnel(.04, LDotH);\n    \n    float D = GTR1(H.z, mix(0.1, 0.001, 1. - si.clearcoatRoughness));\n    pdf = D * H.z / (4.0 * LDotH);\n\n    float G = SmithG_GGX(L.z, 0.25) * SmithG_GGX(V.z, 0.25);\n    return vec3(0.25 * si.clearcoat * F * D * G);\n}\n\nvec3 ComputeColorTint(vec3 baseColor) {\n    float luminance = Luminance(baseColor);\n    return (luminance > 0.0) ? baseColor / luminance : vec3(1.);\n}\n\nvoid ComputeSpecularColor(SurfaceInteraction si, out vec3 Cspec0, out vec3 Csheen) {\n    vec3 tint = ComputeColorTint(si.color);\n\n#ifdef SUPPORT_SG_WORKFLOW\n    if(si.workflow > 0.1) {\n        Cspec0 = si.specularColor;\n    } else \n#endif    \n\n    {\n        Cspec0 = mix(SchlickR0FromEta(si.ior) * mix(vec3(1.0), tint, min(si.specularTint, 0.99)), si.color, si.metalness);\n    }\n    Csheen = mix(vec3(1.0), tint, si.sheenTint);\n}\n\nvoid ComputeLobe(SurfaceInteraction si, vec3 Cspec0, float fresnelWeight, out float diffuseLobeWt, out float specularLobeWt, out float transLobeWt, out float clearcoatLobeWt) {\n    diffuseLobeWt = max(Luminance(si.color), si.sheen) * (1.0 - si.metalness) * (1.0 - si.transmission);\n    specularLobeWt = Luminance(Cspec0);\n    transLobeWt = (1.0 - fresnelWeight) * (1.0 - si.metalness) * si.transmission * Luminance(si.color);\n    clearcoatLobeWt = si.clearcoat * (1.0 - si.metalness);\n\n    float weightSum = diffuseLobeWt + specularLobeWt + transLobeWt + clearcoatLobeWt;\n\n    diffuseLobeWt /= weightSum;\n    specularLobeWt /= weightSum;\n    transLobeWt /= weightSum;\n    clearcoatLobeWt /= weightSum;\n}\n\nvec3 PrincipledBSDFSample(SurfaceInteraction si, vec3 V, vec3 N, out vec3 L, out float pdf, MaterialSamples randomSamples) {\n    pdf = 0.0;\n    vec3 f = vec3(0.0);\n\n    vec2 bounceDirSample = randomSamples.s3;\n    // To use more\n    vec2 diffuseOrSpecular = randomSamples.s4;\n    float r1 = bounceDirSample.x;\n    float r2 = bounceDirSample.y;\n    \n    vec3 Cspec0, Csheen;\n    ComputeSpecularColor(si, Cspec0, Csheen);\n\n    vec3 T, B;\n    OrthonormalBasis(N, T, B);\n    V = worldToLocal(T, B, N, V); // NDotL = L.z; NDotV = V.z; NDotH = H.z\n\n    float diffuseLobeWt, specularLobeWt, transLobeWt, clearcoatLobeWt;\n    // No L/H, use VoN here\n    float fresnelWeight = DisneyFresnel(si.metalness, si.eta, V.z);\n    ComputeLobe(si, Cspec0, fresnelWeight, diffuseLobeWt, specularLobeWt, transLobeWt, clearcoatLobeWt);\n\n    float cdf[4];\n    cdf[0] = diffuseLobeWt;\n    cdf[1] = cdf[0] + specularLobeWt;\n    cdf[2] = cdf[1] + transLobeWt;\n    cdf[3] = cdf[2] + clearcoatLobeWt;\n\n    // Diffuse Reflection Lobe\n    if (r1 < cdf[0]) {\n        r1 /= cdf[0];\n        L = CosineSampleHemisphere(r1, r2);\n\n        vec3 H = normalize(L + V);\n\n        f = DisneyDiffuse(si, Csheen, V, L, H, pdf);\n        pdf *= diffuseLobeWt;\n    } else if (r1 < cdf[1]) {\n        // Specular Reflection Lobe\n        r1 = (r1 - cdf[0]) / (cdf[1] - cdf[0]);\n        // vec3 H = SampleGGXVNDF(V, si.roughness, r1, r2);\n        vec3 H = ISGTR2(si.roughness, r1, r2);\n\n        if (dot(V, H) < 0.0)\n            H = -H;\n\n        L = normalize(reflect(-V, H));\n\n        f = DisneySpecular(si, Cspec0, V, L, H, pdf);\n        pdf *= specularLobeWt;\n    } else if (r1 < cdf[2]) {\n        // Transmission Lobe\n        r1 = (r1 - cdf[1]) / (cdf[2] - cdf[1]);\n        // vec3 H = SampleGGXVNDF(V, si.roughness, r1, r2);\n        vec3 H = ISGTR2(si.roughness, r1, r2);\n\n        if (dot(V, H) < 0.0)\n            H = -H;\n\n        vec3 R = reflect(-V, H);\n        L = normalize(refract(-V, H, si.eta));\n        f = DisneyTransmission(si, Cspec0, V, L, H, pdf);\n        pdf *= transLobeWt;\n    } else {\n        // Clearcoat Lobe\n        r1 = (r1 - cdf[2]) / (1.0 - cdf[2]);\n        vec3 H = ISGTR1(mix(0.1, 0.001, 1. - si.clearcoatRoughness), r1, r2);\n\n        if (dot(V, H) < 0.0)\n            H = -H;\n\n        L = normalize(reflect(-V, H));\n\n        f = DisneyClearcoat(si, V, L, H, pdf);\n        pdf *= clearcoatLobeWt;\n    }\n\n    L = localToWorld(T, B, N, L);\n    return f * abs(dot(N, L));\n}\n\nvec3 PrincipledBSDFMaterial(inout SurfaceInteraction si, vec3 V, vec3 L, out float bsdfPdf) {\n    bsdfPdf = 0.0;\n    vec3 f = vec3(0.0);\n\n    vec3 N = si.ffnormal;\n    vec3 T, B;\n    OrthonormalBasis(N, T, B);\n    V = worldToLocal(T, B, N, V); // NDotL = L.z; NDotV = V.z; NDotH = H.z\n    L = worldToLocal(T, B, N, L);\n    \n    vec3 H;\n    \n\tif (L.z > 0.0) {\n        H = normalize(L + V);\n    } else {\n        H = normalize(L + V * si.eta);\n    }\n\n    if (dot(V, H) < 0.0) {\n        H = -H;\n    }\n    \n    vec3 Cspec0, Csheen;\n    ComputeSpecularColor(si, Cspec0, Csheen);\n\n    float diffuseLobeWt, specularLobeWt, transLobeWt, clearcoatLobeWt;\n    float fresnelWeight = DisneyFresnel(si.metalness, si.eta, abs(dot(L, H)));\n    ComputeLobe(si, Cspec0, fresnelWeight, diffuseLobeWt, specularLobeWt, transLobeWt, clearcoatLobeWt);\n\n    float pdf;\n\n    // Diffuse\n    if (diffuseLobeWt > 0.0 && L.z > 0.0) {\n        f += DisneyDiffuse(si, Csheen, V, L, H, pdf);\n\t\tbsdfPdf += pdf * diffuseLobeWt;\n    }\n\n    // Specular Reflection\n    if (specularLobeWt > 0.0 && L.z > 0.0 && V.z > 0.0) {\n        f += DisneySpecular(si, Cspec0, V, L, H, pdf);\n        bsdfPdf += pdf * specularLobeWt;\n    }\n\n    // Transmission\n    if (transLobeWt > 0.0 && L.z < 0.0) {\n        f += DisneyTransmission(si, Cspec0, V, L, H, pdf);\n        bsdfPdf += pdf * transLobeWt;\n    }\n\n    // Clearcoat\n    if (clearcoatLobeWt > 0.0 && L.z > 0.0 && V.z > 0.0)  {\n        f += DisneyClearcoat(si, V, L, H, pdf);\n        bsdfPdf += pdf * clearcoatLobeWt;\n    }\n\n\treturn f * abs(L.z);\n}\n\n// Estimate the direct lighting(Env Light + Analytic light) integral using multiple importance sampling\n// http://www.pbr-book.org/3ed-2018/Light_Transport_I_Surface_Reflection/Direct_Lighting.html#EstimatingtheDirectLightingIntegral\n// NEE End: Env/Analytic lights interaction\n\nvec3 computeDirectLight(inout SurfaceInteraction si, in Path path, in vec2 s1, in vec2 s2) {\n\tvec3 viewDir = -path.ray.d;\n\tvec3 surfacePos = si.position + INTERSECT_EPS * si.ffnormal;\n\n\tvec3 Li = vec3(0.0);\n\tBsdfSampleRec bsdfSampleRec;\n\n\t// Stratified sample\n\tvec2 lightDirSample = s1;\n\tvec2 envDirSample = s2;\n\n\tvec3 lightDir;\n\tvec2 uv;\n\tfloat lightPdf;\n\tbool brdfSample = false;\n\n\t// Env light\n\tlightDir = invEnvRotMatrix * sampleEnvmap(envDirSample, uv, lightPdf);\n\tpath.ray = Ray(surfacePos, lightDir);\n\tif (!intersectSceneShadow(path.ray, INF - EPS)) {\n\t\tvec3 irr = textureLinear(envMap, uv).rgb * envMapIntensity;\n\t\tbsdfSampleRec.f = PrincipledBSDFMaterial(si, viewDir, lightDir, bsdfSampleRec.pdf);\n\n\t\tif (bsdfSampleRec.pdf > 0.0) {\n\t\t\tfloat misWeight = powerHeuristic(lightPdf, bsdfSampleRec.pdf);\n\t\t\tif (misWeight > 0.0) {\n\t\t\t\tLi += misWeight * bsdfSampleRec.f * irr / lightPdf;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Analytic lights\n\t#if defined(NUM_LIGHTS)\n\t\tLightSampleRec lightSampleRec;\n\t\tLight light;\n\n\t\tint i = int(lightDirSample.x * float(NUM_LIGHTS));\n\n\t\t// Light Data\n\t\tvec3 position = lights.position[i];\n\t\tvec3 emission = lights.emission[i];\n\t\tvec3 p1 = lights.p1[i];\n\t\tvec3 p2 = lights.p2[i];\n\t\tvec4 params = lights.params[i];\n\t\tfloat radius = params.x;\n\t\tfloat area = params.y;\n\t\tfloat type = params.z;\n\t\tfloat visible = params.w;\n\n\t\tlight = Light(position, radius, emission, area, p1, type, p2, visible);\n\t\tsampleOneLight(light, surfacePos, lightSampleRec, lightDirSample);\n\n\t\tif (dot(lightSampleRec.direction, lightSampleRec.normal) < 0.0) {\n\t\t\tpath.ray = Ray(surfacePos, lightSampleRec.direction);\n\t\t\tif (!intersectSceneShadow(path.ray, lightSampleRec.dist - EPS)) {\n\t\t\t\t// Check between si.position and light\n\t\t\t\tbsdfSampleRec.f = PrincipledBSDFMaterial(si, viewDir, lightSampleRec.direction, bsdfSampleRec.pdf);\n\t\t\t\tfloat misWeight = 1.0;\n\t\t\t\tif(light.area > 0.0 && bsdfSampleRec.pdf > 0.0) {\n\t\t\t\t\tmisWeight = powerHeuristic(lightSampleRec.pdf, bsdfSampleRec.pdf);\n\t\t\t\t}\n\t\t\t\tif (misWeight > 0.0) {\n\t\t\t\t\tLi += misWeight * bsdfSampleRec.f * lightSampleRec.emission / lightSampleRec.pdf;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t#endif\n\t\n\treturn Li;\n}\n\nlayout(location = 0) out vec4 out_light;\n\nvoid computeBounce(inout Path path, int depth, inout SurfaceInteraction si, inout BsdfSampleRec bsdfSampleRec, in LightSampleRec lightSampleRec) {\n\t\n\tif (!si.hit) {\n\t\tvec3 envSampleDir = envRotMatrix * path.ray.d;\n\n\t\tif (depth == 0) {\n\t\t\tpath.li += useBackgroundColor == 1 ? backgroundColor : sampleEnvmapFromDirection(envSampleDir) * envMapIntensity;\n\t\t\tpath.alpha = backgroundAlpha;\n\t\t\tpath.abort = true;\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tvec3 irr = sampleEnvmapFromDirection(envSampleDir) * envMapIntensity;\n\t\tfloat misWeight = 1.0;\n\t\tfloat lightPdf = envMapPdf(envSampleDir);\n\t\t// Trace bsdf sample ray if hit emitter(envmap/light) then use MIS\n\t\tmisWeight = powerHeuristic(bsdfSampleRec.pdf, lightPdf);\n\n\t\t// Hit light source (the hdr map) / add contribution from light source\n\t\tif (misWeight > 0.) {\n\t\t\tpath.li += misWeight * path.beta * irr;\n\t\t}\n\t\tpath.abort = true;\n\t\treturn;\n\t}\n\t\n\tif (si.isEmitter) {\n\t\tpath.li += EmitterSample(path.ray, depth, lightSampleRec, bsdfSampleRec) * path.beta;\n\t\tpath.abort = true;\n\t\treturn;\n\t}\n\n\t// Reset absorption when ray is going out of surface\n\tif (dot(si.normal, si.ffnormal) > 0.0) {\n\t\tpath.absorption = vec3(0.0);\n\t}\n\t\n\t// Emissive\n\tpath.li += path.beta * si.emissive;\n\n\t// Add absoption\n\tpath.beta *= exp(-path.absorption * si.t);\n\n\t// Stratified sample\n\t// lightDirSample/envDirSample/diffuseOrSpecular\n\tMaterialSamples randomSamples = getRandomMaterialSamples();\n\n\t// Sample Material\n\tpath.li += computeDirectLight(si, path, randomSamples.s1, randomSamples.s2) * path.beta;\n\t\n\t// NEENext Event Estimation\n\tbsdfSampleRec.f = PrincipledBSDFSample(si, -path.ray.d, si.ffnormal, bsdfSampleRec.L, bsdfSampleRec.pdf, randomSamples);\n\t\n\t// Set absorption only if the ray is currently inside the object.\n\tif (dot(si.ffnormal, bsdfSampleRec.L) < 0.0) {\n\t\tpath.absorption = -log(si.extinction) / si.atDistance;\n\t}\n\n\tif (bsdfSampleRec.pdf > 0.0) {\n\t\tpath.beta *= bsdfSampleRec.f / bsdfSampleRec.pdf;\n\t} else {\n\t\tpath.abort = true;\n\t\treturn;\n\t}\n\n\t// Russian Roulette sampling\n\tif (depth >= 2) {\n\t\t// Luminance smooth\n\t\tfloat q = 1.0 - Luminance(path.beta);\n\t\tif (randomSample() < q) {\n\t\t\tpath.abort = true;\n\t\t\treturn;\n\t\t}\n\t\tpath.beta /= 1.0 - q;\n\t}\n\n\t// Next\n\tpath.ray = Ray(si.position + INTERSECT_EPS * bsdfSampleRec.L, bsdfSampleRec.L);\n}\n\nvec4 integrator(inout Ray ray) {\n\tSurfaceInteraction si;\n\tPath path;\n\tBsdfSampleRec bsdfSampleRec;\n\tLightSampleRec lightSampleRec;\n\t\n\tpath.ray = ray;\n\tpath.li = vec3(0);\n\tpath.alpha = 1.0;\n\tpath.abort = false;\n\tpath.misWeight = 1.0;\n\tpath.absorption = vec3(0.0);\n\tpath.beta = vec3(1.0);\n\n\tint curAlphaDepth = 0;\n\t\n\t// No use GBuffer for first surface interaction because of texture unit limit\n\tfor (int i = 0; i < bounces; i++) {\n\t\tif (path.abort) {\n\t\t\treturn vec4(path.li, path.alpha);\n\t\t}\n\t\tintersectScene(path.ray, si, lightSampleRec, i, INF);\n\t\t\n\t#ifdef SUPPORT_ALPHA\n\t\tif (si.hit && !si.isEmitter && si.alpha < 1.0 && curAlphaDepth < MAX_ALPHA_DEPTH) {\n\t\t\tif (rand() > si.alpha) {\n\t\t\t\tpath.ray.o = si.position + INTERSECT_EPS * path.ray.d;\n\t\t\t\tcurAlphaDepth++;\n\t\t\t\ti--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t#endif\n\n\t\tcomputeBounce(path, i, si, bsdfSampleRec, lightSampleRec);\n\t}\n\n\treturn vec4(path.li, path.alpha);\n}\n\nvoid main() {\n\tinitRandom(frameCount);\n\tvec2 vCoordAntiAlias = vCoord + jitter;\n\n\tvCoordAntiAlias = (vCoordAntiAlias - 0.5) * 2.0;\n\tvec3 origin = ndcToWorld(vCoordAntiAlias);\n\t\n\tvec3 direction;\n\tif (camera.clipToViewMat[2].w == 0.) {\n\t\tdirection = -camera.viewToWorldMat[2].xyz;\n\t} else {\n\t\tdirection = normalize(mat3(camera.viewToWorldMat) * (camera.clipToViewMat * vec4(vCoordAntiAlias, 0.0, 1.0)).xyz);\n\t}\n\n\tif (camera.aperture > 0.0) {\n\t\tvec3 focusPoint = origin + camera.focus * normalize(direction);\n\t\tvec2 lensPoint = camera.aperture * sampleCircle(vec2(hashRandom(vCoordAntiAlias)));\n\t\torigin = vec3(camera.viewToWorldMat * vec4(lensPoint, 0.0, 1.0));\n\t\tdirection = normalize(focusPoint - origin);\n\t}\n\n\tRay cam = Ray(origin, direction);\n\n\tvec4 Li = integrator(cam);\n\n\tif (!(Li.x < INF && Li.x > -EPS)) {\n\t\tLi = vec4(0., 0., 0., 1.);\n\t}\n\n\tif (frameCount > 1.) {\n\t\tvec2 size = vec2(textureSize(accumulateTex, 0));\n\t\tvec4 accColor = texelFetch(accumulateTex, ivec2(vCoord * size), 0);\n\t\tLi = (Li + accColor * frameCount) / (frameCount + 1.);\n\t}\n\n\tout_light = Li;\n\t// Debug\n\t// out_light.rgb = texture(materialTexArray, vec3(vCoord, 0)).rgb;\n\t// out_light.rgb = texture(diffuseMap, vec3(vCoord, 0)).rgb;\n}\n",vertex:a.vertexShader}),i.setPipelineByCacheKey(We.ID,o,s);this.renderPass=s,s.setTexture("materialTexArr",i.getRawResourceByName("MaterialTextureArray")),(t.supportUVTrans||t.supportTexWrap)&&s.setTexture("uvTransBuffer",i.getRawResourceByName("TextureUVTransformBuffer")),s.setTexture("positionBuffer",i.getRawResourceByName("PositionBuffer")),s.setTexture("normalBuffer",i.getRawResourceByName("NormalBuffer")),"Static"==t.sceneMode?s.setTexture("bvhBuffer",i.getRawResourceByName("BVHBuffer")):(s.setTexture("blasBuffer",i.getRawResourceByName("BLASBuffer")),s.setTexture("tlasBuffer",i.getRawResourceByName("TLASBuffer")),s.setTexture("tlasTransformBuffer",i.getRawResourceByName("TLASTransformBuffer"))),this.initBySettingParams()}initBySettingParams(){const{renderSetting:t}=this,{bounces:e,backgroundColor:n,enableBackgroundColor:a,envMapIntensity:i,backgroundAlpha:s,enviromentVisible:r,envRotMatrix:o,invEnvRotMatrix:l}=t;this.updateBounces(e),this.setEnvMapIntensity(i),this.setBackgroundAlpha(s),this.setEnviromentVisible(r),this.enableBackgroundColor(a),this.setBackgroundColor(n),this.setEnvRotMatrix(o,l),this.updateEnvLight(),this.updateMeshLight()}setAccumulateTex(t){this.renderPass&&this.renderPass.setTexture("accumulateTex",t)}updateBounces(t){const{renderPass:e,samples:n,samplingDimensions:a}=this;a.length=0;for(let i=1;i<=t;i++)a.push(2,2,2,2),i>=2&&a.push(1);e.setUniform("bounces",t),n&&(n.strataCount=-1)}updateEnvLight(){const{renderPass:t,resourcePool:e,renderSetting:n}=this,{totalSumValue:a}=n;t.setTexture("envMap",e.getRawResourceByName(wt.ENVMAP_RES_NAME)),t.setUniform("totalSumValue",a),t.setTexture("envMarginalWeights",e.getRawResourceByName(wt.ENVMAP_MARGINAL_WEIGHTS_RES_NAME)),t.setTexture("envConditionalWeights",e.getRawResourceByName(wt.ENVMAP_CONDITIONAL_WEIGHTS_RES_NAME))}updateMeshLight(){const{renderPass:t,renderSetting:e}=this,{lightsData:n}=e;n&&(t.setUniform("lights.position[0]",n.position),t.setUniform("lights.emission[0]",n.emission),t.setUniform("lights.p1[0]",n.p1),t.setUniform("lights.p2[0]",n.p2),t.setUniform("lights.params[0]",n.params))}setEnvRotMatrix(t,e){const{renderPass:n}=this;n.setUniform("envRotMatrix",t),n.setUniform("invEnvRotMatrix",e)}rebindTLASBuffer(){const{renderPass:t,resourcePool:e}=this;t.setTexture("tlasBuffer",e.getRawResourceByName("TLASBuffer")),t.setTexture("tlasTransformBuffer",e.getRawResourceByName("TLASTransformBuffer"))}rebindTextureArr(){const{renderPass:t,resourcePool:e}=this;t.setTexture("materialTexArr",e.getRawResourceByName("MaterialTextureArray"))}updateMeshMaterial(t){}enableBackgroundColor(t){this.renderPass.setUniform("useBackgroundColor",Number(t))}setBackgroundColor(t){this.renderPass.setUniform("backgroundColor",t)}setEnvMapIntensity(t){this.renderPass.setUniform("envMapIntensity",t)}setBackgroundAlpha(t){this.renderPass.setUniform("backgroundAlpha",t)}setEnviromentVisible(t){this.renderPass.setUniform("enviromentVisible",Number(t))}setNoise(t){this.renderPass.setTexture("noiseTex",t)}setFrameCount(t){this.renderPass.setUniform("frameCount",t)}setJitter(t,e){this.renderPass.setUniform("jitter",t,e)}nextSeed(){this.renderPass.setUniform("stratifiedSamples[0]",this.samples.next())}setStrataCount(t){t>1&&t!==this.samples.strataCount?this.samples=new we(t,this.samplingDimensions):this.samples.restart(),this.renderPass.setUniform("strataSize",1/t),this.nextSeed()}setSize(t,e){this.renderPass.setUniform("pixelSize",1/t,1/e)}setCamera(t){const{renderPass:e}=this;e.setUniform("camera.viewToWorldMat",t.viewToWorldMat),e.setUniform("camera.clipToViewMat",t.clipToViewMat),e.setUniform("camera.aperture",t.aperture),e.setUniform("camera.focus",t.focus)}bindTextures(){this.renderPass.bindTextures()}draw(){this.renderPass.useProgram(),this.fullscreenTriangle.draw()}dispose(){}};let _e=We;_e.ID="PTPass";class Ee{constructor(){this.scale=new z(1,1)}get width(){return this.renderWidth}get height(){return this.renderHeight}calcDimensions(t){const{fullWidth:e,fullHeight:n}=this;this.renderWidth=Math.round(e/t),this.renderHeight=Math.round(n/t),this.scale.set(this.renderWidth/e,this.renderHeight/n)}setSize(t,e,n){this.fullWidth=t,this.fullHeight=e,this.calcDimensions(n)}}class ze{constructor(t,e){this.gl=t,this.resourcePool=e,this.sampleCount=0,this.numUniformSamples=4,this.strataCount=6,this.forceUpdate=!1,this.firstFrame=!0,this.needsUpdateBG=!1,this.enableTileRender=i,this.enableDenoise=r,this.movingDownsampling=a,this.downsamplingFactor=n;const s=new ht(t);this.integratorPass=new _e(t,s,e),this.toneMapPass=new Ie(t,s,e),this.accumulatePass=new Ne(t,s),this.gBufferPass=new Pe(t,s,e),this.svgfAtrousPass=new Re(t,s),this.fxaaPass=new ye(t,s),this.tileCalculator=new Me(t),this.previewSize=new Ee}async buildPipeline(t,e,n){this.camera=e,this.lastCamera=e.clone(),this.renderSetting=Z(t,0,n);const a=await this.initNoise();this.integratorPass.createPipeline(this.renderSetting),this.integratorPass.setNoise(a),this.gBufferPass.createPipeline(this.renderSetting,t),this.svgfAtrousPass.createPipeline(this.renderSetting),this.fxaaPass.createPipeline(this.renderSetting),this.toneMapPass.createPipeline(this.renderSetting),this.accumulatePass.createPipeline(),this.updateTileNumber(this.renderSetting.tileNumber)}updateScene(t,e){const{camera:n,resourcePool:a}=this;this.renderSetting=Z(t,0,e),this.integratorPass.createPipeline(this.renderSetting),this.gBufferPass.createPipeline(this.renderSetting,t),this.svgfAtrousPass.createPipeline(this.renderSetting);const i=a.getRawResourceByName("NoiseTexture");this.integratorPass.setNoise(i),this.integratorPass.setAccumulateTex(this.accumulateBuffer.color[0])}async initNoise(){const{gl:t,resourcePool:e}=this,n=e.getRawResourceByName("NoiseTexture");if(n)return n;const a=new Image;return a.src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABAEAAAAADfkvJBAAAbsklEQVR4nA3UhQIIvBoA0E830810M91MN9PNdDPd/ulmupluppvpZrqZbqabe89DHCiDv5GzaossZGYBp2PFIFqKdmMXIKW85edCB/RT11SD3JMQidRlL7n2ufRH1jVkFUNVc3NaZ7DP0T7/112kM1Qc3RDG0K/4uN7CPC7OmtFRZK3Jy3fhSSySKIZXopTsnIhN69JjLHJYYnfpZu44hnV+UkhG/lPd/D+fIVwWtdhhupVPJmtsLFIhjHA7UUqY4fPIQ2qdKxviqH2sugJ2nC+1ZdV0vEF3RGNcMd4KdvIXaJnujdPrKj4ifkeX2f04avjEbqO0ogI/rD7zhmy6GKG/2w32IetIX5vE9DbrS+CNy4sbmgXoiaug48lV4bVKZgluwPujd+Ioa+KjuntypepEEvl/YYCYTq6w4aaReGMShwLkC4nvq7jFKJmLpoepHJTag/h2aMklShou+tyip5wm67P2/CnvH7K6zuq+KGvy2rkkrR4mc4dpUNTEFHDId9TXQiST3RxHO0lHNgNFIA/Ub1kC0pOlNBf77EtyZ0ejxvikzySL8C8hNWyyc1GvcBCusv/otvBO3YSj+KvvRlKgoNaF/GEB64prsx8qFRwVJcRmMk8l5E5swfHMPuhlr9DmtrLeqs7KOrCMQSpeGW/zH5F2dc0AXZhcp9IthLZyuxpHrkNnp0JfnsY+55XkAtgSOvsWzps8uoJ5GtpAXRWZ5TK9cEM1WVRWC81ZUstPZHHkC7GDjZfl7BJ+VcXkI8RfVIMW0Jq95oxE0R+MDQnMX97DPhYjEXzHM0LvUNyODhdDCvJdNmXlfFp0RsbBNclTj8hpXofsCgVYsAnwPRTNTiTLxZkQW43BmK6wHk7Y0iSdXIfyK8/aQULdx1/hJc0JkRE/UgNDc/dGZWanTCs2WQ0W6Xh7PZGuDMXEaLtIRMZcZAM4ieOwO661Qf4xVyhLOOA2mLe0JyvIDrBhUA42ioUiMmrHJ9te6jwtbQ6xWrKf/ED3qKJ0qvzO2of57KkcyMBvNZndbLTX/iWNaWTezm9E8cleKOSEXK1B3LDfeGk4yx/b7L5+uAvp6UVC/UYAhvPLvSwTWm+qqO5saYjh79LadBJaAR90ct9S/GGZ7Q1zhKyTOUJ9MzT85IldVjLLduUOqovEaASJbXeZ37oFv0w/sOGhvMzpVrL/2MeQx8+ldfQU/QBXIqn8NtHAHjCzaTJk+CDS0e6Wk8N7GEDgoR4rG5M/Zig/LD6hEr6VHmxzmijoKu/oZ+p84oEeiwegquE7pBZPYXEoyLeQ66wRicLXmOzWoib6mq6KUoWxuriq62OQh647TUmn0RuuIjtPfuEkcMQtwJ/IaJabRRe9fRX2Q8Z1L2UNlMclpfMFdKYr+XkVEeb6vChZuOBfhNl+l/hly9L0/mzYIxPhBq4oimlnB273mkgwnr+S7Vnp8Fff8/3VC7IJCtqZ9AxZRnujo3wjmQ9n7WtayxwgvUhUNtJ0UjlEU9vPFhePxDLfkl6z43hhdQSW+xbyKooJEEwqTOkL1VHWc1vReFaVxbcnTGM2Uq1XNXRPos0bdtI8VBKXcZdCV1dNpLcL3DE7Cqfmi2w5JGhGFqATTUhzy7sG2+a0II4ZtupikC488mt9abdTvpYXVALXBU6wNzYLXUTPQwTxH/nNttjKDA7pQT47mopOQmxzW/f3GVhXWoguEUl5EHcUoKm8LdpiMoZV9JONpzZa7wa7hG4XzxvquHj2s5lsIrFbtrbew3+SKbiK6Ry+whAyXrTBC0kgDfwZHNOMNRnwOjHVVICdOGVo6LuFsn6GTKN6u4IeZqtN7B6vzlegD7ioW8i/u430kbtO2pABrgTPwb+xchSZ7jK/V6KxPEWK+K+oBXFmeuikt+HzrIU66KQsI9bRaGqQfKqSkMNumbnN4/ljkFsPxqnDElSF32L17D8UhxbUI8xnuwk/0znwXXcGGmD4QpPo5n6kTod70Zb2oI8Y6pFJKiuLoab7bXBEj+CXFTOH4A4kV/1JNjNRLrexaEX5Ht0xQ1RRskzmhCd+rmnFi9hLeqHe7svy7Lq+/+Mq6am+A/X8e+iptvqcbIjzqCOfbW6SpKQ22gPt8HgTFUMPd9kWgKd2O45Pr0EuOlK8waXFfriga7sXrLlKZZbrgeaPnmsrurd+n2H8hugjc+i1OCpJj2vYPyQ27+lT6/f4JM0c6sJIHwm/8AJS4tXuuo6g9qOCjvOZIrI9ZpaaauQAjwb9eTG0RMYPr2y5AHv8YhZLHvZl+DdQqrI5Z1L4QawT/FOLoQCOLR+EyTIrjcqb6YtiA4mg0/L27reYYg7JpvSVOM7G+p2uIb1iJ0hE+/DvvLW+qqfL034nLU5GQh02j8aHi/aDLS2b4ncYk/OcE+V+hhNqmF2rs1j4a1qziXYgaaDWQRetSbOwC60J8VhFSIf62k2osy7FXqpdrDAdZbuQxf5ZOCGLy6Reago9xBydmN9HBdUqX9VtUYdIKZOGbGAFxEDXjLxDmeVXsd5WIOmlhN0kqe2r84o1upy+z9KLRjY/ui5qGkhNiqoL5iXN6hPbeyGa+ckKwRM6l51Ao+EG/yKruXNsrWvHkuDPKKctS4bYRnq7eIQX+at4s8lD2ovy+D/xlXUWuf2jsNiNQx9xDRwjLAgJUSd5AvfTD80U0Qk91fP8DTkBfaXx1Qhv7FMXifZRMw0MlxtxVFVNzoOTrnjoK9ObCZy5HOwjbWgTib1kFo3BJa9t7oojdJK5RpGcifO66LQ2xuIHBvxcnMcLdEoUWc0QjVhs0k3f4dnoXvREODRB5KWJ2UFTX60WcXERxFQ7uo9mDz1YVbzQddDBHQ3QxD0MPfBnsdX+p9+xg+Sybmtum4hKoJW+CG0NGSQxP/TC0AulZ1tozfATr9Ld/QfURp1kg2FqaOQ2QBZ9JNyCoeQfO0eS+SOCa0lLshW6hnulWqHi/qrMTj6Z03gzB/LMzuaXmZXJSUm7nSKACjQDVzafbiNTqUayYpjDNpqhqIzf4SfRU/KF6S+vo0MhAS/v36BoolU4JbKQO3S3nmAL88puH0GoN6tF3vg2rCzscLVcUbmKzHS/dFroBdGk8bP4Hx8DRotKtJdMa4YZKhvR2OgbnULv+lzYUfjhFusD6KaLR8aHFSSPjYmT2MP6tU1L76u4uqJYrqawEqqpW+Onm4G6KIw2CU0Z29/EIc9gKVwjH3wxNV5v8fmxVunIGB94PxYBV+I3RRM4IO8x7Ab6ZXi3aoEeoUXmtzqHVrGCsrUYpOvIFXSMgX4YQp1Qmp6xf/Ae8gR1U19NUzEdSOjApK9nPuoItqt5HE7TXPIm3sff2fm+SbioN9GcPLltyTLKeeGBjGr668sYsfuymdjM8uHjYqL5BLn4SFqRdjbnZJKgyFHIA51lEjEebtEMfqN7LlORlgreiM3B26G2g82iqssbZBQq6k+rGn5J+MMvsVRus95vMpFR9K9K4errLmJFSMO/iepoBu6CfptR4QzqxpOYH6ERP4xmqS4uKzz3V2RS0SnMNwnYKvdW5Bd16FdS0kWlDeQ2VIMEJtgeVJ7GZIdDYQldWQ6UVK2mM1l000/MRyn5GpGZDkRbQ1RUCs/HLcMDV4hV1/OkEZFpRX+f5zfSHGQR7W2obdeiMnK3qQarTK7wEiq5vTqWXayqhyF4By5l6+HDPKK4AZtVRnoHjVBv8Syd1VocyY2UP9g8c15PpXBNVIET8MnVd8/oNlaGcnZJBZoQ7uAe4SjJAWNdX3AkNrQTQ+ClmMxO23i4nXseStC+4agkPDYeChdcOzLRJ2f/2S+ukJqsW/tvKoN4bP5/sOpHxuN5qC3p5VbaizIefWBKkKWkCc+DO5paPAHAP7wQj+VFRVp/zhPy3Ufw+8I4VsE1QVPtS1ZLf6eJ5Qr3Se3GxfURld71EhvEHJXVbLdJzUL/2nk6nX1mGcxdXUpvIg2gt7rADrkoYq0ogKbYXyK1pOwljuEO0rykAh5k2pMp6hR7rVO7h3IY2Y6gOYpsBqhWfp/sQcbbZa6m7uge0dx8pUgjd9GY5CyUldNEXX3L5JRLaHP2G5UhDtfnn8Qk3sak8Y1dUR5BatyTnyTR2PWwnCVCZe09NdwLG8tpvl3nJCd8dfzPNFMp1Wb4YuuihKIPWkP2k5I0o4OVJB96wDby2Oy2TAwv9VAxh8dFJ9EvU1S390Pdekx8d0jrxgik35GaLDoeZR7ZhH4IqyzO+/WiNzkkGNrOm8MvN4dmom9kbtuCzgy14K097SrhJuoeDEMJ7CI5Tjwn+3AmfjkUQpXUTR+DzdDPKVRgh23w1c0MUoI1EYchky6st4hefmS4bhZhr5vJ9/QYfUpbywukv9iib4S8msMqOE6iqH86px6L3oubJike6fJBB1ODDTZb6V+fAvapLL6DTGQ+2hm2k1svL8litoeKxZaRIXq2/U3HsDb6ghQBJqP4OB29iP4Lv/FaVZlctV9QM5tC1UGRbCWRBSfQs/UOFAGtlhX8VJJMLTD7VQY6HRU23ehdXAYlJHN5FlkRvXQHdDzx2I8Lx1A3sxTd8MXdOjVKH4BCOp2pIx6zrHwar6qO6uYB3FaXXdYNycNXCUNlY9TFLwq5SFuemg60UdhieVa8hml4v/2sHOsDNV1JGM5zmx/U2qKhk/lq+7jXaCuuYxaTPba1OuMHhY16GiuJVonzKBUtjEDVtwPxJP+cXUaRfD/1w5zS0Ulr9DXcQPnIK39Xdgkn+WJahGzGkI1cda/xFhfNn6KP1R7c2Y4JZSBnWK26kkJhs51E/tGk8m5oInvSjOI5risjuorqlI8X0oZh+JmKQeuhn7KLjKmvmd6iCVnIKtMH5KOM6zGu5nP5hmixMLo8Ge0P6jWyD0ukR7F0lqIPEMc/gv0OIsqZvCSug8eZ964gnYXr+LsqPmojHrG0apiIzg6TtkyHc7BHIDzTXuL/yQ38Dhsnm5OPfCorYK/LFTKPOU4xr+m/6WzydVCmPWwM5+UuN9e1Ce/8TRbfdJVzbCrWQJTUO+R8V5Ouh6m6T2jpqllYDfew5Ylcb1teraRxUFb8xxp6zFWH+eqtbIhzomc+DRunqvv3doVoKfOEJGoRKilzmAt4B69k+0FyN0m2ED5ss6NkNLTbn1LDAmHU/QDBj5oU8j9cxLxi2dUd+z5E8RfNT9NUHvApzRU/Bv1R0MEPlER9Nzuhpb/lhmsLxUJfP8EkYWdUCbyW3QzlbTco4AfhKEDNUfeY7pLt8U/a063mUaGD+4wtofwtmo0L2WWqlSxHErH0aDltYsbwqHqNq2CnuJ3qdKjJh/hlYYrsKLKwwTy2eOnzyrIMB1A0rmhiNc3Iz9tkvJt44ZqhJQ70F+jhW8CIgNQuO49/Q8bcJ5NxWlaVj6Yx/VVIZWeY2uK+zuw3hSEhIu2hE5NLfiC9p//I7vq6i6+fioJwF2Uyf2lzHoGt521FPlUJrH+AioQzvJtcJnaGEwHewSXxGFExyX7y81hVsQGng6shr9lG74TM5KdX/LyLIevpKyin6sz/Qj/0MjTQh2g594Yct6NVPL5QNUC3QlX/RR3hOXE9th5Nhf2hBswWfdVZVJsvMQNoGnOVfvNx6Qudgo9Ra/hMVJV8wdF1XQwFSYqwzgxjkVQ9kS+cZjHEhzAK6qMKYlZIjg+ZGqIvykCWBy4T0dlkBykCq33WsIAOAoJaQjH/V5w1uekes5plQOPRfBuTFmGvWRueVX9VW2V7GcccoE90CTSW7cXzaU+9hdflUeUTkk001/PDCAnbTRXb2h4jPeCZ2O0Gh1JuOu2M97PnZjBd6QrJDuqBL60+kuH4BK+Fo8uzLjmaoO4Z4DvsCpZM9DJtlWKvUEnVmTVVj/SOUFmOxBHCZV7CJJETIKA8rIuZKavxzKaxvQSlxD/exg9g130ifoH20pBJPKAz2F+bwyVUq2Qrd98mshdVNhVTtjJXSFx4wzegSfhAKECfcY1u4Wamu3pPqogO+Fu4bifDU1MZRfepxAh8EeLYn0i4Ey6NWwYD4Yhp6hfK8uiGimFPubcsYXiI/nO58QmN5V4+zm1kpdl3AtoeFLF0MT0Wbqk5KJ37rmqFTWYR+4vLsGN4BM3uGoYUJgLv5irINGiw+upKhA3qOIxkiQjVGfR+uo7dRAv4B1WLbqApcD472903Hz2T6/0jmR6G0xWmEWz2g3U7uYZF1FNgKX7PK5p85lXoGMBAMzzA17Kb+EnZmFfk/eghNI4W9r1pGjGZ14YvbIHcHQbYy/Cbb0FTcW61x83ySGRGjc0SOC/qqKE+p28MfV0hfJhNV0P4VdGQdICcYrKPz/Lb306IfSKl+66z83LiKPokGeuq4pI5oqFMzY6FSQC50RXxgifnnckXEUfkZS9kFNJCn0b38Q4aWXRRt2Rl/pLMkll4fdwuPNaRXW11xT1lBdE2KfBblwAdDz/dNhIJtSZZzFtdWq+BqHZPKB8ukbZwCkf0Ne19X1hMFAvsLZIWFyPGnTe36TC9Ej8U5Tkk8J/0Ai9JpnCJ7iLz+VWzFqqEdyaXGqSWk8I4vYovWonifKW2Iok7p8boFaozGsinis86MpknWoeJoazD4OW5UEXvcxNoUvdDdDdP5Ag7V2xypbHy/eGcjY56yF2qGQwUz1xSaE2jit++h9mpYZpqYwuYyrAGT+QlXDsjVSrUXcwiiaCxfsYOm2lmszyrh4tY/LbrY9+GQqK8+SdSyYO2qsmqbvEi+old7nrCaL1Ed7Gx8B05gJ82C1FGFds3FM9tDvUJa9E4vNJVZTLzy89i2dg4sLQmFMGZ8TkH61lUf4Q94D1xRPTYMZst/IK9vjhskJdJeTdKfXNMdOfvVR5eDS3STUlGczIYHEvdhxZ2LR1ud/NYpqYIMqEs7P6yTbIpz8eru61QjH4mg1AybF17mgESqAN4PRnl8uvTsBpT9SlsJ4tgBKtjIZXua36TRmirSIo+iqX8FIol7pKx5CNEox1EdpGC3WWR5C4/Qf+wm3Rc9Z+fhdraPGi8KsWdT0Y7idMylzVwldSXGf1MeGZSiFGe+1tin67kr6ixag26TYYaSi771i5ueEjr+U4+neqPY6H37KaEFzBGFqfpuZIXUEsyIJST01xd2walDwvtGd0Xr7al/ALSXKbRNHSh1/xe9cHVDs+1hv7ul6xPX5ppZAjlZm446vuIsuiiW+rf8Yhmil+Bc0N3Ej3UxAXcTzWdZxEhaN3HRJaX5VMyyR3jLXxZDTnkbrsM3cA1eD52UGL2imx3xA7FB2wN+c9Opo3UG3rZDeIn9Wz2kCfTRVwEesH2oCn0MRHFzZWZcHm4y8GmVp/4BBzd7pXZbBd+3Kehjfw/N0duh2e4hTmuouCuvjrbo4uZaX5DqOyT+PxsJXTBMIOfstFd2/BF/8fnyximG1rFk/Bb6AWOywqHHSYhPhjy0zjuOWSndcUAMwVVtGtDZrFT1FCF+Bboxaz+wYujXVBNPSRt3TBel3xHhVk/9xASyFLqjEhr+/FFxMh7YiKktkftn5CDNDW7xTd7kcU1MJRWMm9Vb55YbVIl5D36BxqFk6osFmqjl8GTjLp7qCnHWMPa24NoufkdWuo7+j/zxUx0N+hbaBqQW6VGia52kcsnkb1p1/I5vgo26CIertrZgMfT8jqxrkeJfAMtwmAWX95Uo/g814vXll5BStHMzzG50EN8RE4g1WgWNNwtUpG10jl8S1zZvvfT7Urzi5eCKOEtweoMJWKejoFKoTY0TliqpCCU+WsqI7ywhpzipVFyeKKikfE+o63t11qguWAP/Wau6OEQE52l5dkq3BGeqwimFMnktyn4J4uoS3aNakAj8XbqStjpC/nXpL354q/zo3SxATjjuEtpr7H5uiodjVHoivbLhvoxnCDdMdZn/RMz0x/k0UIz3lv/EdN0K3pYdrO72VeeH24La2aqJ7wjWeFLhjlus/jC89FaKC05oN6biWqpgGjYshGQTpdTP8ggEQ9mkuTmgqglsFkrE4UBUNreIbnEMHcE9xRN8P2wlZTjr0xKv1HOEvn531ApJFLt1WdXRk/UKSyjmdxIkke903Ftc7EEC1PVDiaNfToRT/c2j0km6I6mKqcW44GqobuOOyp4goU26hWewpfxE/QZaoo2+L50vx5N8rmG/IefiDeJeuqDiAUFwjqeWX3VU11fdoFn04N9PVhNJoSdZoDMztbZ42YhfaMvueW4Irkmp+sS+hlJLmL5y6aI2KYvhGr6kG1kopid1vuiNlY4aXO5KhJmmTo8AWmF8/qUugcq5rLxb7gCiunu2jnQhZ2C2CGD6gw71CMzw13kQ0xEVogsZdVtHHjLD4j7LiIvxpxswLwYRguoCG6H7isSi/qwwQ0Rp8U4/IeuNq/oSDsDfto8dJx9ExJJyVqwX3S9Hi2TazjLCsNtu1984NXMdnbPLbaTdCv1Xpf02+UTqMZe8QWquBlDKoeEtp3e6+qTa7gV+SnG+VIhOeWop/0g56o0EFf+QC1wOdwRPyJH1U/AvgPJYffZMqEtzo4jhfoiKdOyrT7uqqA1NIvricqK3ei1gBW8DwE5zM8Jl3CCUC8MRpH0EbscEoihOptLBntDP+/CH5RWLkfvQhn1TCahR/w201XcYEvUGZbJbnajXRWyh/Xgt/TqkIBOcEXkPBsZHtiaaKlMbWbDSdGf7ab3aSl51fe3qf3nMM3e9vF5W5/BwQT/21ZQ611W2YGPtb8hHbuuiBP+nG6Op6HVqJUlEMUexs1YH5qbTBILRCY2nORVUeh0V1X/hwrwJuy5u2KWupx0Bj1NXtBsuKkezra58+Ez9NGN1R3x0VRindg7mRGZMA8XNOd4jXCIL+IfXYMAN3RSbVUT+oTFdmfMOl1R72SvPQtpwl95zZUxn+g9MtnVMOvDbXVcRnOd+Hr6iDcWH0g6/xRvD99FYtwJR/YlbD05AmFUneyl71x3W17k8xNRMrnJR1djaUGxlsThY6ARjgBPUSc7kkeH/GQIKilgG+8KRCv8mVLcW+Z300I7NBzNJ0XZZhSR1OPSLmHdMOJF8Wf5HzD9K5zFFXG/sFIewu1RPFSOrULH1JTwUR1UMdUvNQAv5jHwTb3KxuWt8StXkuz3mfklNIcc0z3DPyhn9opkrClsVI/xqRBbwytYQq7gQTYNXi4bmGPyjk+CYuiHfj8fp3vDMZ+QZSRvzW6Yq7OilGQHFMfx3GyZXBa2DMa7S2YeuWeHyMy6p3lo29LNtDR3rq5Ljf+RI2guPkcHy9rkF2mJEvvqNI+4jRUs50FfgWy+u5uDaynIAq15dF4tPIB9KIp8L7PDUv1NVoWWJht6iQrIdfgcLu05vsbHBkGc5mECeyC2spv8F4rG++C80ICkoNXwOlIwXEOJzSyX23UIU0h/mklVoY9lfNdVL/E36VD20u4QbVxm6GeKyfGkEvrFUqPR/H9s/XjiBWp1EAAAAABJRU5ErkJggg==",new Promise((n=>{a.onload=()=>{const i=new St(t,{data:a,wrapS:t.REPEAT,wrapT:t.REPEAT,storage:"halfFloat"});e.setResource("NoiseTexture",i),n(i)}}))}initFrameBuffers(t,e){const{gl:n,renderSetting:a}=this,i="float";this.lightBuffer=new st(n,{color:{0:new St(n,{width:t,height:e,storage:i})}}),this.accumulateBuffer=new st(n,{color:{0:new St(n,{width:t,height:e,storage:i})}}),this.integratorPass.setAccumulateTex(this.accumulateBuffer.color[0]);const s=new St(n,{width:t,height:e,storage:"float"}),r=new St(n,{width:t,height:e,storage:"halfFloat"}),o=new St(n,{width:t,height:e,storage:"byte"}),l=new bt(n,t,e);this.gBuffer=new st(n,{color:{0:s,1:r,2:o},depth:l})}syncTracerSetting(t){Object.assign(this.renderSetting,t)}updateMaterialParams(t){}rebindTLASBuffer(){this.integratorPass.rebindTLASBuffer()}rebindTextureArr(){this.integratorPass.rebindTextureArr()}updateEnvLight(){this.integratorPass.updateEnvLight()}updateMeshLight(){this.integratorPass.updateMeshLight()}setEnvRotMatrix(t,e){this.integratorPass.setEnvRotMatrix(t,e)}enableBackgroundColor(t){this.integratorPass.enableBackgroundColor(t)}setBackgroundColor(t){this.integratorPass.setBackgroundColor(t)}updateTileNumber(t){this.tileCalculator.setTileCount(t),this.reset()}setTileCountSyncRender(t){this.tileCalculator.setTileCount(t),this.tileCalculator.reset()}updateBounces(t){this.integratorPass.updateBounces(t)}setEnvMapIntensity(t){this.integratorPass.setEnvMapIntensity(t)}setBackgroundAlpha(t){this.integratorPass.setBackgroundAlpha(t)}setEnviromentVisible(t){this.integratorPass.setEnviromentVisible(t)}setToneMapping(t){this.toneMapPass.setToneMapping(t)}setDenoiseColorFactor(t){this.svgfAtrousPass.setColorFactor(t)}setDenoiseNormalFactor(t){this.svgfAtrousPass.setNormalFactor(t)}setDenoisePositionFactor(t){this.svgfAtrousPass.setPositionFactor(t)}setCameras(t){this.integratorPass.setCamera(t),this.gBufferPass.setCamera(t),this.lastCamera.copy(t)}updateSeed(t,e,n=!0){const{enableDenoise:a,integratorPass:i,sampleCount:s,numUniformSamples:r,strataCount:o}=this;i.setSize(t,e),i.setFrameCount(s);const l=n?(Math.random()-.5)/t:0,c=n?(Math.random()-.5)/e:0;a||i.setJitter(l,c),0===s?i.setStrataCount(1):s===r?i.setStrataCount(o):i.nextSeed()}clearBuffer(t){const{gl:e}=this;t&&(t.bind(),e.clear(e.COLOR_BUFFER_BIT),t.unbind())}renderGBuffer(){const{gBuffer:t,gBufferPass:e,svgfAtrousPass:n,gl:a,screenWidth:i,screenHeight:s}=this;t.bind(),a.clear(a.COLOR_BUFFER_BIT|a.DEPTH_BUFFER_BIT),a.viewport(0,0,i,s),e.draw(),t.unbind(),n.setGBuffers({position:t.color[0],normal:t.color[1],color:t.color[2]})}svgfDraw(){const{svgfAtrousPass:t,lightBuffer:e}=this,n=t.draw({light:e.color[0]});this.toneMapWithAAToScreen(n.color[0])}addSampleToBuffer(t,e,n){const{gl:a,integratorPass:i,accumulatePass:s,lightBuffer:r,accumulateBuffer:o}=this;t.bind(),a.viewport(0,0,e,n),i.draw(),t.unbind(),s.draw({inputTex:r.color[0],outputTex:o})}newSampleToBuffer(t,e,n){const{gl:a,integratorPass:i}=this;t.bind(),a.viewport(0,0,e,n),i.draw(),t.unbind()}toneMapToScreen(t,e=[1,1]){const{gl:n,toneMapPass:a}=this,{renderToScreen:i}=this.renderSetting;n.viewport(0,0,n.drawingBufferWidth,n.drawingBufferHeight),a.draw({light:t,lightScale:e},!i)}toneMapWithAAToScreen(t){const{renderToScreen:e}=this.renderSetting;let n=this.toneMapPass.draw({light:t},!0);e&&this.fxaaPass.draw({light:n.color[0]})}reset(){this.forceUpdate=!0,this.sampleCount=0,this.tileCalculator.reset(),this.clearBuffer(this.lightBuffer)}setSize(t,e){this.sampleCount=0,this.screenWidth=t,this.screenHeight=e,this.reset(),this.tileCalculator.setSize(t,e),this.previewSize.setSize(t,e,this.downsamplingFactor),this.initFrameBuffers(t,e),this.svgfAtrousPass.setSize(t,e),this.fxaaPass.setSize(t,e),this.toneMapPass.setSize(t,e)}drawPreview(){const{previewSize:t,lightBuffer:e}=this;this.updateSeed(t.width,t.height,!1),this.newSampleToBuffer(e,t.width,t.height),this.toneMapToScreen(e.color[0],t.scale)}renderPerTile(t,e,n,a,i){const{gl:s,screenWidth:r,screenHeight:o}=this;s.scissor(e,n,a,i),s.enable(s.SCISSOR_TEST),this.addSampleToBuffer(t,r,o),s.disable(s.SCISSOR_TEST)}drawTile(t=!1){const{enableDenoise:e,integratorPass:n,lightBuffer:a,screenWidth:i,screenHeight:s}=this,{x:r,y:o,tileWidth:l,tileHeight:c,isFirstTile:u,isLastTile:d}=this.tileCalculator.nextTile();u&&(0===this.sampleCount&&this.clearBuffer(a),this.updateSeed(i,s,!0),e&&this.renderGBuffer()),this.renderPerTile(a,r,o,l,c),t&&!d&&this.toneMapToScreen(a.color[0]),d&&(e?this.svgfDraw():this.toneMapToScreen(a.color[0]),this.sampleCount++)}renderTile(t){const{lastCamera:e}=this;!Tt(t,e)||this.forceUpdate?(this.forceUpdate=!1,this.setCameras(t),this.firstFrame?this.firstFrame=!1:this.drawPreview(),this.sampleCount=0,this.tileCalculator.reset()):this.drawTile()}renderFull(t){const{enableDenoise:e,integratorPass:n,lightBuffer:a,screenWidth:i,screenHeight:s,lastCamera:r,movingDownsampling:o}=this;if(!Tt(t,r)||this.forceUpdate){if(this.forceUpdate=!1,o)return this.setCameras(t),this.sampleCount=0,void this.drawPreview();this.sampleCount=0,this.clearBuffer(a)}else this.sampleCount++;this.setCameras(t),this.updateSeed(i,s,!0),e&&this.renderGBuffer(),this.addSampleToBuffer(a,i,s),e?this.svgfDraw():this.toneMapToScreen(a.color[0])}render(t){this.enableTileRender?this.renderTile(t):this.renderFull(t)}dispose(){}}var Ce=(t=>(t[t.Linear=0]="Linear",t[t.ACES=1]="ACES",t[t.Neutral=2]="Neutral",t))(Ce||{});class Ge{constructor(t={}){this.pixelRatio=1,this.geoType="Mesh",this.targetSampleCount=0,this._viewportSize=[],this.inited=!1,this.isBuilding=!1,this.needsUpdate=!1,this._bounces=2,this._backgroundColor=new u,this._enableBackgroundColor=!1,this._backgroundAlpha=1,this._envMapIntensity=1,this._envRotation=0,this._envRotMatrix=new T,this._invEnvRotMatrix=new T,this._totalSumValue=0,this._toneMapping="Linear",this._downsamplingFactor=n,this._enviromentVisible=!0,this._tileNumber=s,this._denoiseColorFactor=o,this._denoiseNormalFactor=l,this._denoisePositionFactor=c,this.isFloatLinearSupport=!0,this.forceUpdateOneFullSample=!1,this.onBuildingProgressCallback=()=>{},this.canvas=t.canvas||document.createElement("canvas"),this.gl=this.canvas.getContext("webgl2",{alpha:t.canvasAlpha||!0,depth:!1,stencil:!1,antialias:!1,powerPreference:"high-performance",premultipliedAlpha:!0,failIfMajorPerformanceCaveat:!0}),this.checkSupported(this.gl),this.sceneMode=t.sceneMode||"Static",this.useWebWorker=null==t.useWebWorker||t.useWebWorker,this.renderToScreen=null==t.renderToScreen||t.renderToScreen,this.resourcePool=new Q,this.environmentLoader=new wt(this.gl,this.resourcePool),"Static"==this.sceneMode?this.sceneBuilder=new be(this.gl,this.resourcePool):this.sceneBuilder=new Ae(this.gl,this.resourcePool),this.renderer=new ze(this.gl,this.resourcePool),this.featureOption={supportSGWorkflow:!0,supportUVTrans:!0,supportTexWrap:!0,supportAlpha:!0,supportAlphaShadow:!0,supportCastShadow:!1},t.featureOption&&Object.assign(this.featureOption,t.featureOption),this.rayParamsOption={maxAlphaDepth:5,minIntersectDistance:1e-4},t.rayParamsOption&&Object.assign(this.rayParamsOption,t.rayParamsOption)}checkSupported(n){if(!n)throw new Error("webgl2 no supported!");const a=rt(n,t);for(let t in a)if(!a[t])throw new Error(`require extension ${t} no supported!`);const i=rt(n,e);for(let t in i)i[t]||("OES_texture_float_linear"===t&&(this.isFloatLinearSupport=!1),console.error(`extension ${t} no supported!`))}set bounces(t){this._bounces=mt(t,2,8),this.inited&&this.renderer.updateBounces(t),this._syncTracerSetting()}get bounces(){return this._bounces}set envMapIntensity(t){this._envMapIntensity=t,this.inited&&this.renderer.setEnvMapIntensity(t),this._syncTracerSetting()}get envMapIntensity(){return this._envMapIntensity}set enableBackgroundColor(t){this._enableBackgroundColor=t,this.inited&&this.renderer.enableBackgroundColor(t),this._syncTracerSetting()}get enableBackgroundColor(){return this._enableBackgroundColor}set backgroundColor(t){"string"==typeof t?this._backgroundColor.fromHex(t):Array.isArray(t)&&this._backgroundColor.fromArray(t),this._backgroundColor.SRGBToLinear(),this.inited&&this.renderer.setBackgroundColor(this._backgroundColor),this._syncTracerSetting()}get backgroundColor(){return this._backgroundColor}set backgroundAlpha(t){this._backgroundAlpha=t,this.inited&&this.renderer.setBackgroundAlpha(t),this._syncTracerSetting()}get backgroundAlpha(){return this._backgroundAlpha}set envRotation(t){this._envRotation=t;let e=function(t){return t*Math.PI/180}(t);this._envRotMatrix.fromMatrix4((new m).rotateY(e)),this._invEnvRotMatrix.inverse(this._envRotMatrix),this.inited&&this.renderer.setEnvRotMatrix(this._envRotMatrix,this._invEnvRotMatrix),this._syncTracerSetting()}get envRotation(){return this._envRotation}set toneMapping(t){this._toneMapping=t,this.inited&&this.renderer.setToneMapping(Ce[t]),this.forceUpdateOneFullSample=!0,this._syncTracerSetting()}get toneMapping(){return this._toneMapping}set enableTileRender(t){this.renderer.enableTileRender=t,this.renderer.reset(),this._syncTracerSetting()}get enableTileRender(){return this.renderer.enableTileRender}set tileNumber(t){this._tileNumber=t,this.inited&&this.renderer.updateTileNumber(t)}get tileNumber(){return this._tileNumber}set movingDownsampling(t){this.inited&&(this.renderer.movingDownsampling=t),this._syncTracerSetting()}get movingDownsampling(){return this.renderer.movingDownsampling}set enableDenoise(t){this.renderer.enableDenoise=t,this.forceUpdateOneFullSample=!0,this._syncTracerSetting()}get enableDenoise(){return this.renderer.enableDenoise}set denoiseColorFactor(t){t=Math.max(t,.1),this._denoiseColorFactor=t,this.inited&&this.renderer.setDenoiseColorFactor(t),this._syncTracerSetting(),this.forceUpdateOneFullSample=!0}get denoiseColorFactor(){return this._denoiseColorFactor}set denoiseNormalFactor(t){t=Math.max(t,.1),this._denoiseNormalFactor=t,this.inited&&this.renderer.setDenoiseNormalFactor(t),this._syncTracerSetting(),this.forceUpdateOneFullSample=!0}get denoiseNormalFactor(){return this._denoiseNormalFactor}set denoisePositionFactor(t){t=Math.max(t,.1),this._denoisePositionFactor=t,this.inited&&this.renderer.setDenoisePositionFactor(t),this._syncTracerSetting(),this.forceUpdateOneFullSample=!0}get denoisePositionFactor(){return this._denoisePositionFactor}set downsamplingFactor(t){this._downsamplingFactor=Math.floor(Math.max(t,1)),this.renderer.downsamplingFactor=this._downsamplingFactor,this.renderer.previewSize.calcDimensions(this._downsamplingFactor)}get downsamplingFactor(){return this._downsamplingFactor}get sampleCount(){return this.renderer.sampleCount}get size(){return this._viewportSize}set enviromentVisible(t){this._enviromentVisible=t,this.inited&&this.renderer.setEnviromentVisible(t)}get enviromentVisible(){return this._enviromentVisible}_syncTracerSetting(){const{geoType:t,integrator:e,sceneMode:n,bounces:a,backgroundColor:i,enableBackgroundColor:s,backgroundAlpha:r,envMapIntensity:o,enviromentVisible:l,featureOption:c,rayParamsOption:u,renderToScreen:d,_envRotMatrix:f,_invEnvRotMatrix:h,_toneMapping:p,_totalSumValue:m,isFloatLinearSupport:x,enableTileRender:T,tileNumber:g,enableDenoise:v,denoiseColorFactor:S,denoiseNormalFactor:b,denoisePositionFactor:A}=this;this.tracerSetting={geoType:t,integrator:e,sceneMode:n,bounces:a,backgroundColor:i,enableBackgroundColor:s,backgroundAlpha:r,envMapIntensity:o,enviromentVisible:l,envRotMatrix:f,invEnvRotMatrix:h,totalSumValue:m,toneMapping:Ce[p],supportSGWorkflow:c.supportSGWorkflow,supportUVTrans:c.supportUVTrans,supportTexWrap:c.supportTexWrap,supportAlpha:c.supportAlpha,supportAlphaShadow:c.supportAlphaShadow,supportCastShadow:c.supportCastShadow,maxAlphaDepth:u.maxAlphaDepth,minIntersectDistance:u.minIntersectDistance,renderToScreen:d,isFloatLinearSupport:x,enableTileRender:T,tileNumber:g,enableDenoise:v,denoiseColorFactor:S,denoiseNormalFactor:b,denoisePositionFactor:A},this.inited&&this.renderer.syncTracerSetting(this.tracerSetting)}async buildPipeline(t,e){this.isBuilding=!0;const{sceneInfo:n,camera:a}=function(t,e){return{sceneInfo:tt(t,!0),camera:et(e)}}(t,e);this.sceneInfo=n,this.camera=a,this.onBuildingBeginCallback&&this.onBuildingBeginCallback(),this.environmentLoader.load(this.environment),this._totalSumValue=this.environmentLoader.totalSumValue,this._syncTracerSetting(),await this.sceneBuilder.build(n,this.onBuildingProgressCallback),await this.renderer.buildPipeline(n,a,this.tracerSetting),this.setSize(this.canvas.width,this.canvas.height),this.inited=!0,this.isBuilding=!1,this.onBuildingEndCallback&&this.onBuildingEndCallback()}getRenderResGPUTexture(){if(!this.renderToScreen)return this.resourcePool.getRawResourceByName("ScreenPassOutputTexture").texture;console.error("Need to set init tracer renderToScreen to false first")}getMeshByTHREEID(t){const{meshes:e}=this.sceneInfo,n=`LGL_${t}`;return e.find((t=>n==t.id))}static linkMeshWithTHREEMesh(t,e){var n;t.id=`LGL_${e.id}`,t.name=`LGL_${e.name}`,t.tlasMask=!!(null==(n=e.userData)?void 0:n.lgl_tlasMask),t.visible=e.visible,t.localToWorldMat.fromArray(e.matrixWorld.elements)}updateMeshTransformFromTHREE(t){t.updateMatrixWorld(!0);this.getMeshByTHREEID(t.id).localToWorldMat.fromArray(t.matrixWorld.toArray())}async updateMeshMaterialParamsFromTHREE(t){it(t.material,this.getMeshByTHREEID(t.id).material),await this.updateMaterialParams()}async rebuildMeshMaterialFromTHREE(t){if(gt(),this.isBuilding)return;this.isBuilding=!0;const e=it(t.material);this.getMeshByTHREEID(t.id).material=e,this.updateSceneStructure(),this.needsUpdate=!0,this.isBuilding=!1}updateSceneStructure(t=!1){if("Static"==this.sceneMode)return;const e=$(this.sceneInfo.meshes);this.sceneInfo.materialIndexMap=e,this.sceneInfo.materials=Array.from(e.keys()),this.sceneBuilder.rebuildMaterialBuffer(this.sceneInfo),this.sceneBuilder.rebuildTLAS(this.sceneInfo,!0),this.renderer.rebindTextureArr(),this.renderer.rebindTLASBuffer()}rebuildMaterial(){const{meshes:t}=this.sceneInfo,e=$(t);this.sceneInfo.materialIndexMap=e,this.sceneInfo.materials=Array.from(e.keys()),this.sceneBuilder.rebuildMaterialBuffer(this.sceneInfo),this.renderer.rebindTextureArr()}async addSceneFromTHREE(t){gt(),await this.updateScene(t)}async replaceMainSceneFromTHREE(t){await this.updateScene(t)}setMeshTLASMaskStatusFromTHREE(t,e){const n=this.getMeshByTHREEID(t.id);return n.visible=!e,n}setMeshVisibleFromTHREE(t,e){const n=this.getMeshByTHREEID(t.id);return n.visible=e,n}async syncCastShadowStatusFromTHREE(t){this.featureOption.supportCastShadow?(Array.isArray(t)||(t=[t]),t.forEach((t=>{const e=this.getMeshByTHREEID(t.id).material;"Metalness"==e.workflow?e.glossiness=t.castShadow?1:0:e.roughness=t.castShadow?1:0})),await this.updateMaterialParams()):console.error("Need to set tracer.featureOption.supportCastShadow to true first!")}updateTLAS(){"Static"==this.sceneMode||this.isBuilding||(this.sceneBuilder.rebuildTLAS(this.sceneInfo),this.renderer.rebindTLASBuffer(),this.needsUpdate=!0,this.renderer.forceUpdate=!0)}rebuildTLAS(){this.updateTLAS()}updateMaterialParams(){this.isBuilding||(this.isBuilding=!0,function(t){const{materials:e}=t;let n=!1;e.forEach((t=>{t.subsurface>0&&(n=!0)})),t.includeSSS=n}(this.sceneInfo),this.renderer.updateMaterialParams(this.sceneInfo),this.sceneBuilder.updateMaterialParams(this.sceneInfo),this.renderer.reset(),this.isBuilding=!1)}async updateScene(t){if(this.isBuilding)return;this.isBuilding=!0,this.onBuildingBeginCallback&&this.onBuildingBeginCallback();const e=tt(t);await this.sceneBuilder.build(e,this.onBuildingProgressCallback),this.sceneInfo=e,this.renderer.updateScene(e,this.tracerSetting),this.isBuilding=!1,this.onBuildingEndCallback&&this.onBuildingEndCallback()}updateEnvLight(t){this.environment=t,this.environmentLoader.load(this.environment),this._totalSumValue=this.environmentLoader.totalSumValue,this._syncTracerSetting(),this.renderer.updateEnvLight(),this.needsUpdate=!0}updateMeshLight(){this.renderer.updateMeshLight(),this.needsUpdate=!0}syncGroupVisibleFromTHREE(t){gt()}getLightByTHREEID(t){gt()}static linkLightWithTHREELight(t,e){gt()}async addMeshFromTHREE(t){gt()}async removeMeshFromTHREE(t){gt()}cloneMeshFromTHREE(t,e,n=!0){gt()}updateTextureParamsFromTHREE(t){gt()}addLightFromTHREE(t){gt()}removeLightFromTHREE(t){gt()}updateLightFromTHREE(t){gt()}addTracerInstanceMeshes(t){gt()}syncCamera(t){if(!t)throw new Error("Need to pass camera into render(camera) method!");t.updateMatrixWorld(),et(t,this.renderer.camera)}setTileCountSyncRender(t){this._tileNumber=t,this.renderer.setTileCountSyncRender(t)}setSize(t,e,n=!0){const{canvas:a,pixelRatio:i}=this,s=Math.floor(t*i),r=Math.floor(e*i);a.width=s,a.height=r,this._viewportSize=[s,r],n&&(a.style.width=`${t}px`,a.style.height=`${e}px`),this.inited&&this.renderer.setSize(s,r)}setPixelRatio(t,e=!1){const{_viewportSize:n}=this;this.pixelRatio=t,this.setSize(n[0]/t,n[1]/t,e)}render(t){if(this.isBuilding||!this.inited)return;this.syncCamera(t);const{camera:e,lastCamera:n}=this.renderer;if(this.needsUpdate&&(this.needsUpdate=!1,this.renderer.reset()),0!=this.targetSampleCount&&this.renderer.sampleCount>=this.targetSampleCount&&!this.forceUpdateOneFullSample&&Tt(e,n))return;let a=this.renderer.sampleCount;this.renderer.render(e);let i=this.renderer.sampleCount;this.onSampleFinCallback&&a!=i&&"function"==typeof this.onSampleFinCallback&&this.onSampleFinCallback(),a!=i&&this.forceUpdateOneFullSample&&(this.forceUpdateOneFullSample=!1)}dispose(){this.renderer.dispose()}}export{Ge as LGLTracer,O as Mesh,V as PrincipledBSDFMaterial};
